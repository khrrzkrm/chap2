% 

\section{Quantitative Violation Semantics}
The basic restriction of the forward-looking tight satisfaction semantics, as defined in the previous section, resides in its binary and prefix-closed nature.
In that framework, the monitoring process halts definitively at the first tight violation.
Despite being computationally efficient for stopping compliance systems (e.g., an access control system that is failing), this ``first-fail'' approach is insufficient for post-hoc auditing or dispute resolution.
It masks the full history of non-compliance, failing to capture cumulative violations or distinct failures by multiple agents over time, a critical requirement for comprehensive legal responsibility.
To tackle this limitation, it is necessary to transition from a boolean verdict to a \emph{quantitative semantics}, changing the emphasis from the question ``Did a violation occur?'' to ``How many violations occurred, and what was their magnitude?''


\paragraph{The Challenge of Temporal Scope.}
A prerequisite for counting violations is defining the temporal window over which the contract is evaluated.
In contrast to traditional model checking, which commonly analyzes systems that are supposed to run forever, contract monitoring operates on finite, evolving prefixes.
We identify two primary strategies for defining this scope:

\begin{enumerate}
    \item \textbf{Static Pre-computation:} One might attempt to calculate a fixed duration $T$ for a contract $C$.
    However, contracts containing unbounded repetitions ($\repit{C}$) or input-dependent regular expressions (guards/triggers) do not have a statically determinable length.
   
    \item \textbf{Dynamic On-the-Fly Detection:} The alternative is to determine the contract's status dynamically at every step.
    Here, the monitor continuously computes a \emph{residual contract}â€”a formula representing what remains to be fulfilled given the history of events.
   
\end{enumerate}

This work adopts a \emph{Dynamic On-the-Fly} approach, utilizing a structural tracking mechanism formalized as the \emph{Contract Progress Monitor} (\CPM). The \CPM functions as a derivative operator: given a contract $C$ and an incoming event, it computes the residual contract $C'$ to be enforced in the next time step. By decoupling the maintenance of contract state (via the \CPM) from the evaluation of compliance (via a scoring function), this architecture enables a modular framework that tracks active duties, manages contrary-to-duty (CTD) transitions, and attributes blame with precision over time. The scoring function is critical, providing a quantitative measure of adherence that transcends binary verification to assess the \emph{degree} of compliance. This interaction with the \CPM quantifies the magnitude of violations, yielding a nuanced view of contractual performance that enhances both accountability and enforcement precision.

Regarding computational complexity, we rely on the following finiteness hypothesis: the set of reachable residual contracts is finite.
We state this property formally in Claim~\ref{clm:rrcs-finite} and leave a complete proof and an effective enumeration algorithm to future work.

\subsection{Contract Progress Monitor}

The core of our measurement framework is the \emph{progression function}, $\Prog$.
This function consumes the current single event and the current \emph{state of a contract} to produce the \emph{residual contract} for the subsequent step.

\begin{definition}[Contract Progression Function]
Let $\Gamma = 2^\Sigma$ be the event alphabet.
We extend the set of contracts $\mathcal{C}$ with a distinguished symbol $\emptc$, representing a \emph{discharged contract} (one that implies no further obligations).

The progression function $\Prog: \Gamma^* \times \cDL \to \cDL \cup \{\emptc\}$ is defined recursively.
For the empty trace $\emptytrace$, $\Prog(\emptytrace, C) := C$.
For a single event step $\trace{A}$ with $A \in \Gamma$, the function is defined on the structure of $C$ as follows.

\paragraph{Literals (State Update).}
For any literal $\ell$ (obligation, permission, or prohibition):
\[
\Prog(\trace{A}, \ell) := \emptc.
\]
\emph{Rationale:} Structurally, a literal applies to a single time step.
Once the $A$ step occurs, the literal is consumed.
Whether $A$ satisfied or violated $\ell$ is immaterial to the \emph{progression} (the duty is passed); the violation is recorded separately by the quantitative scoring function defined later.


\paragraph{Conjunction (Parallel Progress).}
\[
\Prog(\trace{A}, C_1 \wedge C_2) := \Prog(\trace{A}, C_1) \wedge \Prog(\trace{A}, C_2)
\]
We assume the symbolic identity where $\emptc$ is the neutral element for conjunction: $\emptc \wedge C' \equiv C'$.


\paragraph{Sequence (Sequential Handover).}
For a sequence $C_1 ; C_2$, progression determines if the current step concludes $C_1$:
\[
\Prog(\trace{A}, C_1 ; C_2) := 
\begin{cases}
  \Prog(\trace{A}, C_1) ; C_2 & \text{if } \Prog(\trace{A}, C_1) \neq \emptc, \\
  \Prog(\trace{A}, C_2) & \text{if } \Prog(\trace{A}, C_1) = \emptc.
\end{cases}
\]
If $C_1$ is discharged by step $A$ (i.e., its residual is $\emptc$), the monitor immediately activates the first step of the next portion $C_2$.


\paragraph{Reparation (Contrary-to-Duty Branching).}
The reparation construct is unique because its structural progression depends on the satisfaction of the primary obligation.
This is the only case where $\Prog$ relies on the tight satisfaction relation ($\satt, \violt, \presat$) to determine the path:
\[
\Prog(\trace{A}, C_1 \repair C_2) := 
\begin{cases}
  \Prog(\trace{A}, C_1) \repair C_2 & \text{if } \trace{A} \presat C_1 \text{ (Pending)}, \\
  \Prog(\trace{A}, C_2) & \text{if } \trace{A} \violt C_1 \text{ (Repair)}, \\
  \emptc & \text{if } \trace{A} \satt C_1 \text{ (Discharge)}.
\end{cases}
\]
If a violation occurs ($\trace{A} \violt C_1$), the primary contract is discarded, and the secondary contract $C_2$ is activated immediately for the \emph{next} step.


\paragraph{Repetition.}
Repetition unrolls the contract one step at a time:
\[
\Prog(\trace{A}, \repit{C}) := \Prog(\trace{A}, C) ; \repit{C}
\]


\paragraph{Guarded and Triggered Contracts.}
These constructs rely on regular expression matching.
\[
\Prog(\trace{A}, \guard[re]{C}) :=
\begin{cases}
  \emptc & \text{if } \trace{A} \satt \guard[re]{C} \text{ (release)}, \\
  \guard[\Prog_{re}(\trace{A}, re)]{\Prog(\trace{A}, C)} & \text{otherwise (Guard persists)}.
\end{cases}
\]
\[
\Prog(\trace{A}, \trig[re]{C}) :=
\begin{cases}
  \emptc & \text{if } \trace{A} \violt re \text{ (Trigger failed)}, \\
  C & \text{if } \trace{A} \satt re \text{ (Trigger fires)}, \\
  \trig[\Prog_{re}(\trace{A}, re)]{C} & \text{if } \trace{A} \presat re \text{ (Trigger pending)}.
\end{cases}
\]

Where the regular progress function $\Prog_{re}: \Gamma^1 \times \cDL_{re} \to \cDL_{re} $ is defined for traces of length 1, and is defined only when $\trace{A} \presat \re$ (where $\trace{A}$ is the trace consisting of the single event $A$).
 We do not need to use $\epsilon_{re}$ as we did for the contract as $\epsilon$ is already defined in the syntax of regular expression, with $\Prog_{re}(\trace{A},\epsilon):= \epsilon$.

 \paragraph{Atomic regular expressions.}
 For an atomic letter-test $B \in \Gamma$,
 \[
 \Prog_{re}(A, B) :=
 \begin{cases}
 \epsilon & \text{if } A = B,\\
 \emptyset & \text{otherwise}.
 \end{cases}
 \]
  
 \paragraph{Concatenation}
For $\re \cdot \re'$, the progression is defined as:
\[
\Prog_{re}(\trace{A}, \re \cdot \re') := 
    \Prog_{re}(\trace{A}, re) \cdot re'.
\]
\noindent\emph{Remark.} whenever a residual of the left part reduces to $\epsilon$, we use the standard identity $(\epsilon)\cdot re' \equiv re'$ to simplify the resulting expression.



\paragraph{Union}
For $re \mid re'$, the progression is defined by distinguishing cases based on violation:
\[
\Prog_{re}(\trace{A}, re \mid re') := \begin{cases} 
\Prog_{re}(\trace{A}, re') & \text{if } \trace{A} \violt re ,\\
\Prog_{re}(\trace{A}, re) & \text{if } \trace{A} \violt re' ,\\
\Prog_{re}(\Prog_{re}(\trace{A}, re) \mid \Prog_{re}(\trace{A}, re') & \text{otherwise}.
\end{cases}
\]

\paragraph{n-repetition}
For $\re^n$, with $n \in \mathbb{N}^*$ the progression is defined as:
\[
\Prog_{re}(\trace{A}, re^n) := \Prog_{re}(\trace{A},re)\cdot re^{n-1}.
\]


\paragraph{$+$ Operator}
For $\re^+$, the progression is defined as:
\[
\Prog_{re}(\trace{A}, re^+) := \Prog_{re}(\trace{A}, re) \mid \Prog_{re}(\trace{A},re)\cdot re^+.
\]

Moving up for the special case of single event traces, for $\pi = \trace{A} \circ \pi'$ with
$A \in \Gamma$ the first event and $\pi' \in \Gamma^*$ the remaining suffix. Then:
\[
  \Prog(\trace{A} \circ \pi', C) :=
  \begin{cases}
    \emptc & \text{if } \Prog(\trace{A}, C) = \emptc, \\[4pt]
    \Prog\bigl(\pi',\,\Prog(\trace{A}, C)\bigr) & \text{otherwise}.
  \end{cases}
\]


\end{definition}
The helper function $\Prog_{re}$ computes the residual regular expression following an idea from Brzozowski's derivative~\cite{brzozowski1964derivatives} of the regular expression. In our case, it is tuned for the tight semantics.

\begin{lemma}[Termination]
  For each finite trace $\pi$ and contract $C$, the computation of $\Prog(\pi,C)$ terminates.
  Moreover, the recursion on the trace unfolds for at most $|\pi|$ steps.
  \end{lemma}
To illustrate the \CPM, the evolution of the residual contract under different traces is examined. The evaluation initiates with the fundamental building block of normative enforcement: the reparation.

\begin{example}[Progression of Reparation]
\label{ex:prog-repit}
Consider the basic rental reparation clause:
\[ C_3 := \obl[1]{\PAY}\ \repair\ \obl[1]{\PAYF}. \]


\noindent\textbf{Scenario 1: Compliance.}
Consider the trace $\pi=\trace{A_1,A_2}$. We illustrate this scenario in \ref{example:prog-repair1}.
In Month~1, the tenant pays rent, that is,
$\PAY^{(1)}\in A_1$ and $\PAY^{(2)}\in A_1$.
Hence $\trace{A_1}\ \satt\ \obl[1]{\PAY}$, and the reparation clause is immediately discharged.
The residual contract after Month~1 is therefore $\emptc$, meaning that no further obligations exist for Month~2.

    \boxalignfigure{\resizebox{0.7\textwidth}{!}{%
 
    \begin{tikzpicture}[y=1.6cm,x=3.0cm]
      \tikzset{
        cell/.style={
          draw, rectangle, text width=26mm,
          minimum height=7mm, align=center, font=\small
        }
      }
    
      % Labels
      \node at (0,0)   {Month $i$};
      \node at (0,-1)  {Event at i $A_i$};
      \node at (0,-2)  {$\Prog(\pi_{i},C)$};
      % Row 1: time
      \node[cell] at (1,0) (t1) {$1$};
      \node[cell] at (2,0) (t2) {$2$};
      % Row 2: events
      \node[cell] at (1,-1) (e1) {$\{\PAY^{(12)}\}$};
      \node[cell] at (2,-1) (e2) {$\{\OCC^{(1)}\}$};
      % Row 3: residuals
      \node[cell] at (1,-2) (r1) {\emptc};
      \node[cell] at (2,-2) (r2) {\emptc};
      % Arrows
      \draw (t1)--(t2);
      \draw (e1)--(e2);
      \draw (r1)--(r2);
      % Vertical alignment
      \draw[dotted](t1.south)--(e1.north);
      \draw[dotted](e1.south)--(r1.north);
    
      \draw[dotted](t2.south)--(e2.north);
      \draw[dotted](e2.south)--(r2.north);
    \end{tikzpicture}
    }}
    {Progression on $ \obl[1]{\PAY}\ \repair\ \obl[1]{\PAYF}$ with a trace for which no reparation is  required}
    {example:prog-repair1}
    {\vspace{8pt}}{\vspace{-12pt}}

\medskip
\noindent\textbf{Scenario 2: Violation and Repair.}
Consider the trace $\pi=\trace{A_1,A_2}$.
In Month~1, the tenant fails to pay rent, that is,
$\PAY^{(1)}\notin A_1$ (or equivalently, $\trace{A_1}\ \violt\ \obl[1]{\PAY}$). We illustrate this scenario in \ref{example:prog-repair2}
As a consequence, the \CPM activates the reparation branch.
The residual contract after Month~1 is $\obl[1]{\PAYF}$, obliging the tenant to pay the fine in Month~2.

  \boxalignfigure{\resizebox{0.7\textwidth}{!}{%
  \begin{tikzpicture}[y=1.6cm,x=3.0cm]
  
    \tikzset{
      cell/.style={
        draw, rectangle, text width=26mm,
        minimum height=7mm, align=center, font=\small
      }
    }
  
    % Labels
    \node at (0,0)   {Month $i$};
    \node at (0,-1)  {Event at i $A_i$};
    \node at (0,-2)  {$\Prog(\pi'_{i},C)$};
    % Row 1: time
    \node[cell] at (1,0) (t1) {$1$};
    \node[cell] at (2,0) (t2) {$2$};
    % Row 2: events
    \node[cell] at (1,-1) (e1) {$\{\OCC^{(1)}\}$};
    \node[cell] at (2,-1) (e2) {$\{\OCC^{(1)}\}$};
    % Row 3: residuals
    \node[cell] at (1,-2) (r1) {$\obl[1]{\PAYF}$};
    \node[cell] at (2,-2) (r2) {\emptc};
    % Arrows
    \draw (t1)--(t2);
    \draw (e1)--(e2);
    \draw (r1)--(r2);
  
    % Vertical alignment
    \draw[dotted](t1.south)--(e1.north);
    \draw[dotted](e1.south)--(r1.north);
  
    \draw[dotted](t2.south)--(e2.north);
    \draw[dotted](e2.south)--(r2.north);
  
  \end{tikzpicture}
  }}
  {Progression on $ \obl[1]{\PAY}\ \repair\ \obl[1]{\PAYF}$ with a trace for which required a reparation}
  {example:prog-repair2}
  {\vspace{8pt}}{\vspace{-12pt}}
\end{example}

After establishing the evolution of single-step reparations, the analysis is extended to ongoing contracts. The following example demonstrates how the \CPM handles infinite streams with recurring duties, showing how violations in one period persist into subsequent periods.

\begin{example}[Progression of Infinite Repetition]
Consider the recurring contract $\repit{C_3}$, where the tenant must pay rent (or a fine) every month.
\[ \repit{C_3} = \repit{ \obl[1]{\PAY}\ \repair\ \obl[1]{\PAYF}}. \]

\noindent\textbf{Trace Analysis.}
Consider a trace in which the tenant pays in Month 1 but fails to pay in Month 2, instead occupying the property.
\begin{itemize}
    \item \textbf{Step 1 ($A_1$):} The tenant pays. The instance of $C_3$ for Month 1 is discharged. Due to the repetition operator, the residual is $\emptc; \repit{C_3} \equiv \repit{C_3}$. The contract effectively ``resets'' for the next month.
    \item \textbf{Step 2 ($A_2$):} The tenant occupies but does not pay. The instance of $C_3$ for Month 2 violates the condition. Unlike Step 1, the residual does not reset cleanly. Instead, the violated obligation transforms into its reparation $\obl[1]{\PAYF}$, which must be fulfilled in the \emph{next} step (Month 3), alongside the continuing repetition $\repit{C_3}$.
\end{itemize}
This results in an accumulation of duties: the fine from Month 2 and the new rent for Month 3.

  \boxalignfigure{\resizebox{0.7\textwidth}{!}{%
  \begin{tikzpicture}[y=1.6cm,x=3.0cm]
  
    \tikzset{
      cell/.style={
        draw, rectangle, text width=26mm,
        minimum height=7mm, align=center, font=\small
      }
    }
  
    % Labels
    \node at (0,0)   {Month $i$};
    \node at (0,-1)  {Event at i $A_i$};
    \node at (0,-2)  {$\Prog(\pi_{i},C)$};
    % Row 1: time
    \node[cell] at (1,0) (t1) {$1$};
    \node[cell] at (2.5,0) (t2) {$2$};
    % Row 2: events
    \node[cell] at (1,-1) (e1) {$\{\PAY^{(12)}\}$};
    \node[cell] at (2.5,-1) (e2) {$\{\OCC^{(1)}\}$};
    % Row 3: residuals
    \node[cell] at (1,-2) (r1) {$\repit{C_3}$};
    \node[cell] at (2.5,-2) (r2) {$\obl[1]{\PAYF} ;$\\$ \repit{C_3}$};
    % Arrows
    \draw (t1)--(t2);
    \draw (e1)--(e2);
    \draw (r1)--(r2);
  
    % Vertical alignment
    \draw[dotted](t1.south)--(e1.north);
    \draw[dotted](e1.south)--(r1.north);
  
    \draw[dotted](t2.south)--(e2.north);
    \draw[dotted](e2.south)--(r2.north);
  
  \end{tikzpicture}
  }}
  {Progression on $\repit{C_3}$ where the obligation is met in the first month but violated in the second.}
  {example:prog-repitc1}
  {\vspace{8pt}}{\vspace{-12pt}}
\end{example}

While repetitions capture simple recurring duties, more complex contracts are often bound by conditions. The following analysis studies how the \CPM handles \emph{guarded contracts}, in which the outer structure (the guard) and the inner structure (the obligations) evolve independently until a termination event occurs.

\begin{example}[Progression of Guarded Contracts]
A guarded contract that persists until a termination notice ($\notifterm$) is issued is examined.
\[ \guard[\Gamma^+ \cdot \notifterm^{(1)}]{\repit{C_3}} \]

\noindent\textbf{Trace 1: Successful Termination.}
The tenant pays in Month~1 ($A_1$) and issues a termination notice in Month~2 ($A_2$), as illustrated in \ref{example:prog-guard1}.
\begin{itemize}
    \item At $i=1$, the event $A_1$ satisfies the inner contract $C_3$ (rent paid), but does not satisfy the guard (no notice). The residual is the guarded repetition.
    \item At $i=2$, the event $A_2$ contains $\notifterm$. This satisfies the guard expression. The \CPM immediately reduces the entire contract to $\emptc$, signifying the contract has ended.
\end{itemize}

  \boxalignfigure{\resizebox{0.85\textwidth}{!}{%
  \begin{tikzpicture}[y=1.8cm,x=3.8cm]
  
    \tikzset{
      cell/.style={
        draw, rectangle, text width=34mm,
        minimum height=8mm, align=center, font=\small
      }
    }
    % Local definition for the residual regex to fit in the box
    \def\resid{\notifterm^{(1)} \mid \Gamma^+ \cdot \notifterm^{(1)}}
  
    % Labels
    \node at (0,0)   {Month $i$};
    \node at (0,-1)  {Event at i $A_i$};
    \node at (0,-2)  {$\Prog(\pi_{i},C)$};
    % Row 1: time
    \node[cell] at (1,0) (t1) {$1$};
    \node[cell] at (2.4,0) (t2) {$2$};
    % Row 2: events
    \node[cell] at (1,-1) (e1) {$\{\PAY^{(1)}, \PAY^{(2)}\}$};
    \node[cell] at (2.4,-1) (e2) {$\{\OCC^{(1)}, \notifterm^{(1)}\}$};
    % Row 3: residuals
    % Step 1: Contract satisfied (payment made), Guard not satisfied yet (needs >0 length or specific event).
    % Residual guard becomes (Notif | Gamma+ . Notif)
    \node[cell] at (1,-2) (r1) {$\guard[\resid]{\repit{C_3}}$};
    % Step 2: Guard satisfied by NotifTerm in A2. Contract discharges to epsilon.
    \node[cell] at (2.4,-2) (r2) {\emptc};
    % Arrows
    \draw (t1)--(t2);
    \draw (e1)--(e2);
    \draw (r1)--(r2);
  
    % Vertical alignment
    \draw[dotted](t1.south)--(e1.north);
    \draw[dotted](e1.south)--(r1.north);
  
    \draw[dotted](t2.south)--(e2.north);
    \draw[dotted](e2.south)--(r2.north);
  
  \end{tikzpicture}
  }}
  {Trace~1 (Successful Termination): progression of the guarded contract where the termination notice at step~2 discharges the contract.}
  {example:prog-guard1}
  {\vspace{8pt}}{\vspace{-12pt}}

\medskip
\noindent\textbf{Trace 2: Pending Guard with Internal Violation.}
In this scenario, the tenant pays in Month~1 but fails to pay in Month~2 (and gives no notice), as illustrated in \ref{example:prog-guard2}.
\begin{itemize}
    \item At $i=2$, the guard is \emph{not} satisfied.
    \item Simultaneously, the inner contract $\repit{C_3}$ processes the event. Since rent was not paid, the inner contract evolves into a reparation state ($\obl[1]{\PAYF}$).
    \item The resulting residual is a guarded reparation:\\ $\guard[\notifterm^{(1)} \mid \Gamma^+ \cdot \notifterm^{(1)}]{(\obl[1]{\PAYF} ; \repit{C_3})}$.
\end{itemize}
This illustrates how the \CPM maintains the ``wrapper'' (the guard) while the content inside (the obligations) evolves and accumulates violations independently.

  \boxalignfigure{\resizebox{0.95\textwidth}{!}{%
  \begin{tikzpicture}[y=1.8cm,x=4.7cm]
  
    \tikzset{
      cell/.style={
        draw, rectangle, text width=43mm,
        minimum height=8mm, align=center, font=\footnotesize
      }
    }
    \def\resid{\notifterm^{(1)} \mid \Gamma^+ \cdot \notifterm^{(1)}}
  
    % Labels
    \node at (0,0)   {Month $i$};
    \node at (0,-1)  {Event at i $A_i$};
    \node at (0,-2)  {$\Prog(\pi'_{i},C)$};
    
    % Row 1: time
    \node[cell] at (0.8,0) (t1) {$1$};
    \node[cell] at (2,0) (t2) {$2$};
    
    % Row 2: events
    \node[cell] at (0.8,-1) (e1) {$\{\PAY^{(1)}, \PAY^{(2)}\}$};
    \node[cell] at (2,-1) (e2) {$\{\OCC^{(1)}\}$};
    
    % Row 3: residuals
    % Step 1: Manual line break using \\
    \node[cell] at (0.8,-2) (r1) {$\lceil \resid \rceil$ \\ $\repit{C_3}$};
    % Step 2: Manual line break using \\
    \node[cell] at (2,-2) (r2) {$\lceil \resid \rceil$ \\ $(\obl[1]{\PAYF} ; \repit{C_3})$};
    % Arrows
    \draw (t1)--(t2);
    \draw (e1)--(e2);
    \draw (r1)--(r2);
  
    % Vertical alignment
    \draw[dotted](t1.south)--(e1.north);
    \draw[dotted](e1.south)--(r1.north);
  
    \draw[dotted](t2.south)--(e2.north);
    \draw[dotted](e2.south)--(r2.north);
  
  \end{tikzpicture}
  }}
  {Trace~2 (Pending Guard with Internal Violation): progression where the guard is not satisfied and the inner contract triggers a reparation.}
  {example:prog-guard2}
  {\vspace{8pt}}{\vspace{-12pt}}
  
\end{example}

We now turn to the notion of reachable residual contracts. This construction is essential for monitor synthesis under the quantitative semantics introduced above. While the progression function describes how a single event advances a contract, monitor construction requires a global view of all contract states that may arise under arbitrary traces. The reachable residual contract set captures precisely this state space.

\begin{definition}[Reachable Residual Contract Set from a Contract]
  Let $C \in \cDL$. The \emph{reachable residual contract set} of $C$, written $\rrcs{C}$, is
  \[
    \rrcs{C} := \{\, C_r \in (\cDL \cup \{\emptc\}) \mid \exists \pi \in \Gamma^*: \Prog(\pi,C)= C_r \,\}.
  \]
  \end{definition}
\begin{claim}[Finiteness of Reachable Residual Contracts]\label{clm:rrcs-finite}
  For every contract $C \in \cDL$, the reachable residual contract set $\rrcs{C}$ is finite.
  \end{claim}
  \paragraph{Justification (informal).}
The claim follows from the finiteness of the syntactic structure of $C$ and the fact that the progression function $\Prog$ rewrites contracts using only subcontracts of $C$, residuals of regular expressions appearing in $C$, and the distinguished terminal contract $\emptc$. No new contract structure is generated beyond these components.

We plan to make this argument constructive by defining, as future work, a function that computes $\rrcs{C}$ exhaustively and terminates after finitely many steps. This function will form the basis for an explicit monitor construction and for complexity bounds on the quantitative semantics.
\input{qviol}