\section{Tight Forward Reasoning on Contract Compliance}

\paragraph{Methodological overview.}
This section develops the forward-looking semantics and monitoring constructions in a layered manner.
We first introduce tight satisfaction and violation as \emph{frontier-based} judgements over prefixes of a synchronous periodic trace.
These judgements identify the unique decisive point at which a contract becomes irrevocably satisfied or violated.
On top of this core semantics, we derive coarser verdicts, prove coherence properties, and construct Moore-style monitors that operationalize the semantics.
The continuation of this development extends the same methodology to responsibility-aware verdicts and blame monitoring.
\subsection{Denotational Semantics for Forward-Looking Tight Contract Satisfaction}\label{forwardsatsem}
Fix the tagged collaboration alphabet $\Sigma = \Sigma_C^{(1)} \cup \Sigma_C^{(2)}$
and the induced letter alphabet $\Gamma = 2^{\Sigma}$.
Traces, prefixes, suffixes, and their basic operators are as defined in
\ref{traces}.
In this subsection, we only introduce the forward-looking semantic
judgements used to evaluate contracts along such traces.

\medskip
\paragraph{Core tight judgements.}
All semantic clauses below are stated relative to the prefix structure
fixed in \ref{traces}.

We define two tight relations (inductively on the syntax of $C$):
\[
\pi\ \satt\ C \quad\text{(tight satisfaction)},\qquad
\pi\ \violt\ C \quad\text{(tight violation)}.
\]
Intuitively, $\satt$ holds exactly at the \emph{first prefix}
where the contract becomes satisfied (acceptance frontier),
and $\violt$ holds exactly at the \emph{first prefix}
where it becomes violated (rejection frontier).

\medskip
\paragraph{Derived judgements.}
Using these frontiers, we define the remaining derived relations of the five-valued semantics.
By Lemma~\ref{lem:mutual prefix}, at most one tight frontier can occur along a fixed trace, so the clauses below classify a prefix by its position relative to this (unique, if it exists) decisive point.

\begin{definition}[Post and Pre-satisfaction semantic definition]\label{def:postprecont}
For a contract $C$ and trace $\pi$ the Pre satisfaction relation $\presat$, the post satisfaction and violation relations, respectively $\postsat$ and $\postviol$ are defined on the structure of the trace $\pi$ and the tight satisfaction and violation relations:
\[
\begin{array}{rcl}
\pi\ \presat\ C
&\iff&
\forall\,k<|\pi|:\ \neg\big(\pi[1,k]\ \satt\ C\big)\ \nd\ \neg\big(\pi[1,k]\ \violt\ C\big),
\\[0.8ex]
\pi\ \postsat\ C
&\iff&
\exists\,k<|\pi|:\ \pi[1,k]\ \satt\ C,
\\[0.8ex]
\pi\ \postviol\ C
&\iff&
\exists\,k<|\pi|:\ \pi[1,k]\ \violt\ C.
\end{array}
\]
\end{definition}
Each trace prefix is classified relative to the earliest decisive prefix: before it the trace is undecided ($\presat$), at it the contract is decided tightly ($\satt$ or $\violt$), and after it the trace is beyond the decision frontier ($\postsat$ or $\postviol$).
The fact that these five regions are pairwise disjoint and jointly exhaustive is established formally in Theorem~\ref{thm:five-partition}.

\medskip
\paragraph{Collapsed two-valued judgements.}
For downstream use (e.g., compliance checking), we collapse the five tight judgements into a two-valued view.
For conservativeness, undecided prefixes are treated as violating, which prevents premature acceptance.
\[
\begin{array}{rcl}
\pi \models_\top \ C
&\iff&
\big(\pi\ \satt\ C\big)\ \sor\ \big(\pi\ \postsat\ C\big),
\\[0.6ex]
\pi\ \viol\ C
&\iff&
\big(\pi\ \presat\ C\big)\ \sor\ \big(\pi\ \violt\ C\big)\ \sor\ \big(\pi\ \postviol\ C\big).
\end{array}
\]
Exactly one of $\pi\ \sat\ C$ or $\pi\ \viol\ C$ holds for every trace~$\pi$ and contract~$C$.
This conservative collapse treats undecided prefixes as \emph{violating}
(no premature acceptance) while still preserving the tight moment of satisfaction.

\subsubsection*{Literal Tight Semantics}
Literals $\ell$ are decided in a single synchronous step.
We therefore interpret them on a single event word $\trace{A}$ with $A\in\Gamma$
(the set of actions that occurred in one period).

\par
We present the literal clauses for party $p=1$; the case $p=2$ is symmetric (by swapping $(\cdot)^{(1)}$ and $(\cdot)^{(2)}$).

Intuitively, for party~1:
(i) an \emph{obligation} $\obl[1]{a}$ requires the joint execution of $a^{(1)}$ and $a^{(2)}$;
(ii) a \emph{prohibition} $\frb[1]{a}$ is satisfied precisely when that joint execution does not occur; and
(iii) a \emph{power} $\perm[1]{a}$ requires that whenever party~1 attempts $a^{(1)}$,
party~2 simultaneously supports it with $a^{(2)}$.

%
\begin{definition}[Literal tight satisfaction]\label{def:lattsat}
  For the empty trace, we have:
  \[
  \emptytrace\ \presat \ell \quad \text{for any literal } \ell.
  \]
  Literals are decided on a single synchronous step. We define their semantics on a single event word $\trace{A}$ ($A\in\Gamma$) and the empty word $\emptytrace$.
  \[
  \emptytrace\ \presat \ell \quad \text{for any literal } \ell.
  \]
  \smallskip
  \noindent\textbf{Tight satisfaction.}
  For a single event word $\trace{A}$:
  \[
  \begin{array}{l@{\quad}c@{\quad}l}
  \trace{A}\ \satt\ \top      &\mydef& \text{true}.\\[4pt]
  \trace{A}\ \satt\ \bot      &\mydef& \text{false}.\\[6pt]
  \trace{A}\ \satt\ \obl[1]{a} &\mydef& \{a^{(1)},a^{(2)}\}\subseteq A.\\[6pt]
  \trace{A}\ \satt\ \frb[1]{a} &\mydef& \{a^{(1)},a^{(2)}\}\not\subseteq A.\\[6pt]
  \trace{A}\ \satt\ \perm[1]{a} &\mydef& \text{if }(a^{(1)}\in A) \text{ then }(a^{(2)}\in A).
  \end{array}
  \]
  
  \medskip
  
  \noindent\textbf{Tight violation.}
  For a single event word $\trace{A}$:
  \[
  \begin{array}{l@{\quad}c@{\quad}l}
  \trace{A}\ \violt\ \top      &\mydef& \text{false}.\\[4pt]
  \trace{A}\ \violt\ \bot      &\mydef& \text{true}.\\[6pt]
  \trace{A}\ \violt\ \obl[1]{a} &\mydef& \{a^{(1)},a^{(2)}\}\not\subseteq A.\\[6pt]
  \trace{A}\ \violt\ \frb[1]{a} &\mydef& \{a^{(1)},a^{(2)}\}\subseteq A.\\[6pt]
  \trace{A}\ \violt\ \perm[1]{a} &\mydef& (a^{(1)}\in A) \nd (a^{(2)}\notin A).
  \end{array}
  \]
  \end{definition}

\begin{example}[Literal satisfaction and violation]
Let $A=\{a^{(1)},a^{(2)},b^{(2)}\}$ be the joint actions in one period.
Then
\[
\trace{A}\ \satt\ \obl[1]{a},\qquad
\trace{A}\ \satt\ \perm[1]{a},\qquad
\trace{A}\ \satt\ \frb[2]{b}.
\]
Let $A'=\{a^{(1)},b^{(1)},b^{(2)}\}$. Then
\[
\trace{A'}\ \violt\ \perm[1]{a}\quad\text{(since $a^{(2)}\notin A'$)},\qquad
\trace{A'}\ \satt\ \frb[2]{a}\quad\text{(no joint $a^{(1)} \nd a^{(2)}$ occurs).}
\]
Also, $\trace{A'}\ \satt\ \perm[2]{a}$ holds vacuously since $a^{(2)}\notin A'$.

\medskip
\noindent\textbf{Two-event trace.}
Consider $\trace{A,A'}$.
Since literals are decided at the first letter,
the overall collapsed verdict follows from $\trace{A}$ are post satisfaction or post violation:
\[
\begin{array}{l}
\trace{A,A'}\ \postsat\ \obl[1]{a},\\[4pt]
\trace{A,A'}\ \postsat\ \perm[1]{a},\\[4pt]
\trace{A,A'}\ \postviol\ \perm[2]{b}.
\end{array}
\]
\end{example}

\subsubsection*{Binary Contract Operators Tight Semantics}
\label{sec:tight-binary}
Binary contract operators combine two contracts into structured compositions that capture
parallel, sequential, or conditional behavior.  
In \cDL\ we use
\[
\textsf{op} \in \{\wedge,\ ;\ ,\ \repair\},
\]
where $\wedge$ enforces \emph{both} components, $;$ demands \emph{first $C$ then $C'$},
and $\repair$ means “if $C$ fails, \emph{repair} with $C'$.”

\medskip
\noindent\textbf{Reading guide (tight view).}
All clauses below are tight: they identify the \emph{first decisive point}
where satisfaction or violation becomes determined.
For conjunction, the decisive point for satisfaction is the latter of the two individual successes; for violation, the first conjunct that fails.
For sequencing, a split index $k$ witnesses that $C$ succeeds before $C'$ is checked.
Reparation, on the other hand, requires that either $C$ succeeds directly, or, at the first tight violation of $C$, the repair $C'$ must succeed on the remainder.

\begin{definition}[Binary Contract Operators]
  \label{def:binary-contract-semantics}
  Let $\pi$ be a finite trace over $\Gamma = 2^{\Sigma}$ with  $s=\size{\pi}$.
  We use the notation $\pi_k = \pi[1,k]$ for the prefix of length $k$,
  and $\pi^k = \pi[k+1,s]$ for the suffix after $k$.

  \[
  \begin{array}{l@{\quad}c@{\quad}l}
  \multicolumn{3}{l}{\textbf{Conjunction }(C \wedge C')}\rule{0pt}{2.4ex}\\
  \pi\ \satt\ C \wedge C'
  &\mydef&
  \exists\,k,k' \in [1,s]:\
  \pi_{k}\ \satt\ C\ \nd\
  \pi_{k'}\ \satt\ C'\ \nd\ \\
  & &s=\max(k,k'),
  \\[1.2ex]
  \pi\ \violt\ C \wedge C'
  &\mydef&
  (\pi\ \violt\ C\ \sor\ \pi\ \violt\ C')\ \nd\ \\
  & &\forall\,j \in [1, s-1]:\ \lnot(\pi_{j}\ \violt\ (C \wedge C')),
  \\[2ex]

  \multicolumn{3}{l}{\textbf{Sequence }(C\ ;\ C')}\rule{0pt}{2.4ex}\\
  \pi\ \satt\ C ; C'
  &\mydef&
  \exists\,k \in [1, s-1]:\ \pi_k\ \satt\ C\ \nd\ \pi^{k}\ \satt\ C',
  \\[1.2ex]
  \pi\ \violt\ C ; C'
  &\mydef&
  \pi\ \violt\ C\ \sor\
  \exists\,k \in [1, s-1]:\ \pi_k\ \satt\ C\ \nd\ \pi^{k}\ \violt\ C',
  \\[2ex]

  \multicolumn{3}{l}{\textbf{Reparation }(C\ \repair\ C')}\rule{0pt}{2.4ex}\\
  \pi\ \satt\ C \repair C'
  &\mydef&
  \pi\ \satt\ C\ \sor\
  \exists\,k \in [1, s-1]:\ \pi_k\ \violt\ C\ \nd\ \pi^{k}\ \satt\ C',
  \\[1.2ex]
  \pi\ \violt\ C \repair C'
  &\mydef&
  \exists\,k \in [1, s-1]:\ \pi_k\ \violt\ C\ \nd\ \pi^{k}\ \violt\ C'.
  \end{array}
  \]
\end{definition}

\paragraph{Semantics summary.}
\emph{Conjunction} succeeds once both parts succeed (possibly at different times); its decisive index is the latter of the two.  
It fails as soon as either part fails.  
\emph{Sequence} requires a witness split $k$:
first $C$ succeeds on $[1,k]$, then $C'$ on $[k{+}1,s]$.
\emph{Reparation} allows $C'$ to take over at the first violation of $C$; overall success means either direct success of $C$
or a violation-then-repair pattern.


\begin{lemma}[Local disjointness of tight satisfaction and violation for binary operators]
  \label{lem:binary-disjoint}
  Let $C,C'$ be contracts and let $\pi$ be a finite trace. Assume the following
  induction hypotheses hold for the subcontracts:
  \[
  \neg\bigl(\pi \satt C \ \nd\ \pi \violt C\bigr)
  \qquad\text{and}\qquad
  \neg\bigl(\pi \satt C' \ \nd\ \pi \violt C'\bigr),
  \]
  and, moreover, the same disjointness holds for every suffix $\pi^{k}$ in place of $\pi$.
  Then, for each binary operator $\textsf{op}\in\{\wedge,\ ;\ ,\ \repair\}$ we have
  \[
  \neg\bigl(\pi \satt (C\ \textsf{op}\ C') \ \nd\ \pi \violt (C\ \textsf{op}\ C')\bigr).
  \]
  \end{lemma}
  
  \begin{proof}
    We prove the three cases by contradiction, using Definition~\ref{def:binary-contract-semantics}.
    We also use Lemma~\ref{lem:mutual prefix} to rule out an opposite frontier on a strict prefix once a tight verdict holds on the full trace.
    
    \paragraph{Case $\wedge$.}
    Assume $\pi \satt (C\wedge C')$ and $\pi \violt (C\wedge C')$.
    From $\pi \satt (C\wedge C')$ there exist $k,k'\in[1,s]$ such that
    $\pi_k \satt C$, $\pi_{k'} \satt C'$, and $s=\max(k,k')$.
    From $\pi \violt (C\wedge C')$ we obtain $\pi \violt C$ or $\pi \violt C'$.
    
    If $\pi \violt C$, then:
    (i) if $k=s$, we have $\pi \satt C$ and $\pi \violt C$, contradicting the disjointness hypothesis for $C$;
    (ii) if $k<s$, then $\pi_k$ is a strict prefix of $\pi$ with $\pi_k \satt C$, contradicting Lemma~\ref{lem:mutual prefix}(2) instantiated with $C$ (since $\pi \violt C$ forbids any $j<s$ with $\pi_j \satt C$).
    The case $\pi \violt C'$ is symmetric.
    
    \paragraph{Case $;$.}
    Assume $\pi \satt (C;C')$ and $\pi \violt (C;C')$.
    From satisfaction there exists $k\in[1,s-1]$ such that
    $\pi_k \satt C$ and $\pi^{k} \satt C'$.
    From violation either (i) $\pi \violt C$ or (ii) there exists $m\in[1,s-1]$ such that
    $\pi_m \satt C$ and $\pi^{m} \violt C'$.
    
    In case (i), $\pi \violt C$ contradicts Lemma~\ref{lem:mutual prefix}(2) for $C$
    because $\pi_k$ is a strict prefix with $\pi_k \satt C$.
    
    In case (ii), tight satisfaction of $C$ is a frontier event along prefixes of a fixed trace,
    so $\pi_k \satt C$ and $\pi_m \satt C$ imply $k=m$.
    Hence, the same suffix $\pi^{k}$ both tightly satisfies and tightly violates $C'$,
    namely $\pi^{k} \satt C'$ and $\pi^{k} \violt C'$,
    contradicting the suffix-disjointness hypothesis for $C'$.
    
    \paragraph{Case $\repair$.}
    Assume $\pi \satt (C\repair C')$ and $\pi \violt (C\repair C')$.
    From $\pi \violt (C\repair C')$ there exists $k\in[1,s-1]$ such that
    $\pi_k \violt C$ and $\pi^{k} \violt C'$.
    From $\pi \satt (C\repair C')$ either (a) $\pi \satt C$ or (b) there exists $m\in[1,s-1]$ such that
    $\pi_m \violt C$ and $\pi^{m} \satt C'$.
    
    In case (a), $\pi \satt C$ and the strict-prefix violation $\pi_k \violt C$ contradict
    Lemma~\ref{lem:mutual prefix}(1) instantiated with $C$.
    
    In case (b), tight violation of $C$ is also a frontier event along prefixes of a fixed trace,
    so $\pi_k \violt C$ and $\pi_m \violt C$ imply $k=m$.
    Hence, the same suffix $\pi^{k}$ both violates and satisfies $C'$,
    namely $\pi^{k} \violt C'$ and $\pi^{k} \satt C'$,
    contradicting the suffix-disjointness hypothesis for $C'$.
    
    Thus in all three cases we reach a contradiction, so
    $\neg\bigl(\pi \satt (C\ \textsf{op}\ C') \ \nd\ \pi \violt (C\ \textsf{op}\ C')\bigr)$.
    \end{proof}



\begin{example}[Tight satisfaction and violation for $(C_2 \wedge C_3)$]
\label{ex:c2c3-tight}
We reuse the collaboration alphabet
\[
\Sigma_C=\{\PAY,\ \PAYF,\ \OCC,\ \notifrepair,\ \REPAIR\},
\]
and recall
\[
C_2 := \perm[1]{\OCC}, \qquad
C_3 := \obl[1]{\PAY}\ \repair\ \obl[1]{\PAYF}.
\]

\paragraph{Tight satisfaction (the longest prefix).}
Consider the trace
\[
\pi_{\textsf{sat}} = \langle A_1, A_2\rangle,
\qquad
A_1=\{\OCC^{(2)}\},\quad
A_2=\{\PAYF^{(1)},\PAYF^{(2)}\}.
\]
Then
$\trace{A_1}\ \satt\ C_2$
(vacuously, since $\OCC^{(1)}\notin A_1$ and no unsupported attempt occurs),
and
$\pi_{\textsf{sat}}\ \satt\ C_3$
(the rent was not paid in month 1, but the reparation clause succeeds at $t{=}1$).
Hence, by conjunction,
$\pi_{\textsf{sat}}\ \satt\ (C_2 \wedge C_3)$
at the longest decisive prefix.

\paragraph{Tight satisfaction (the shortest prefix).}
For the single-event trace 
\[
\trace{A_1'} \quad\text{with}\quad A_1'=\{\OCC^{(2)},\PAY^{(1)},\PAY^{(2)}\},
\]
we have
$\trace{A_1'}\ \satt\ C_2$
and
$\trace{A_1'}\ \satt\ \obl[1]{\PAY}$,
so both conjuncts hold in month 1:
\[
\trace{A_1'}\ \satt\ (C_2 \wedge C_3),
\quad
\text{and any extension }\trace{A_1',A_2}\text{ yields }\postsat(C_2\wedge C_3).
\]

\paragraph{Tight violation.}
Now consider
\[
\pi_{\textsf{viol}} = \langle A_1, A_2\rangle,
\qquad
A_1=\{\OCC^{(1)}\},\quad
A_2=\emptyset.
\]
In the first month,
$\trace{A_1}\ \satt\ C_2$
and $\trace{A_1}\ \violt\ \obl[1]{\PAY}$,
while
$\trace{A_1}\ \presat\ C_3$
since the reparation in $C_3=\obl[1]{\PAY}\repair\obl[1]{\PAYF}$ has not yet been tested.
At $t{=}1$,
$\pi_{\textsf{viol}}\ \violt\ C_3$
(as $\pi[1,1]\ \violt\ \obl[1]{\PAY}$ and $\pi[2,2]\ \violt\ \obl[1]{\PAYF}$).
Thus, the overall violation arises from $C_3$,
and by conjunction,
$\pi_{\textsf{viol}}\ \violt\ (C_2 \wedge C_3)$.

\medskip
This shows that $(C_2 \wedge C_3)$
satisfies either immediately when both conjuncts hold, or later when a reparation compensates for a missed rent, while violation arises when both payment and its repair fail.
\end{example}

\subsubsection*{Repetition Contracts Tight Semantics}
\begin{definition}[Repetition Contracts]
  Let $\pi$ be a finite trace over the event alphabet $\Gamma = 2^{\Sigma}$, with $s=\size{\pi}$.
  For $k\in\{1,\dots,s-1\}$, we denote by $\pi_k := \pi[1,k]$ the prefix of length $k$,
  and by $\pi^k := \pi[k+1,s]$ the corresponding suffix.
  Let $n \in \mathbb{N}^*$ be a strictly positive natural number.
  
  The semantics for repetition contracts are inductively defined as follows:
  \[
  \begin{array}{lcl}
  \pi\ \satt\ C^n
  &\mydef& 
  \big( \text{if } n > 1 \text{ then } \pi\ \satt\ C ; C^{n-1} \big)\ \nd\ \big( n = 1 \Rightarrow \pi\ \satt\ C \big),
  \\[1.5ex]
  \pi\ \violt\ C^n
  &\mydef&
  \big(\pi\ \violt\ C\big)\ \sor\ \\ & &
  \big(\exists\,k\in[1,s-1],\exists\, 1 \le m < n:\\ & &\ \pi_k\ \satt\ C^m\ \nd\ \pi^{k}\ \violt\ C\big),
  \\[1.5ex]
  \pi\ \satt\ \repit{C}
  &\mydef&
  \text{false},
  \\[1ex]
  \pi\ \violt\ \repit{C}
  &\mydef&
  \exists\,n \in \mathbb{N}^*:\ \pi\ \violt\ C^n.
  \end{array}
  \]
\end{definition}
  
  \paragraph{Intuition.}
  Repetition contracts express the iterative enforcement of a subcontract.
  The finite form $C^n$ requires $C$ to hold $n$ times in sequence, each instance starting
  immediately after the previous one completes.
  The satisfaction condition unfolds recursively:
  a trace satisfies $C^n$ if it can be decomposed into a prefix where $C$ holds,
  followed by a suffix that satisfies $C^{n-1}$.
  A violation occurs either when the first occurrence of $C$ fails, or when some later repetition cannot be fulfilled after a previously satisfied segment (captured by the split $\pi_k \satt C^m$ and $\pi^{k} \violt C$).
  Hence, $C^n$ behaves as a \emph{sequential chain} of responsibilities and rights, and any broken link invalidates the entire chain.
  
  The infinite form $\repit{C}$ captures \emph{unbounded repetition}.
  Since finite traces cannot exhibit infinite iteration,
  $\repit{C}$ is never fully satisfied (\textsf{false} under tight semantics);
  it is only meaningful with respect to violation:
  a trace violates $\repit{C}$ once it violates one of its finite unfolding $C^n$.
  Intuitively, $\repit{C}$ models \emph{renewable or continuing} contracts such as
  subscriptions or recurring payments, where each cycle restarts the same normative
  condition indefinitely.

  % --- BEGIN INSERTED LEMMAS ---
\begin{lemma}[Local disjointness for repetition contracts]
  \label{lem:repetition-disjoint}
  Let $C$ be a contract, $n\in\mathbb{N}^*$, and let $\pi$ be a finite trace.
  Assume the induction hypothesis that for every finite trace $\Pi_{\min}$ we have
  $\neg(\Pi_{\min}\ \satt\ C\ \nd\ \Pi_{\min}\ \violt\ C)$, and moreover the same disjointness
  holds for every suffix $\Pi_{\min}^k$ in place of $\Pi_{\min}$.
  Then:
  \[
  \neg\bigl(\pi\ \satt\ C^n\ \nd\ \pi\ \violt\ C^n\bigr)
  \qquad\text{and}\qquad
  \neg\bigl(\pi\ \satt\ \repit{C}\ \nd\ \pi\ \violt\ \repit{C}\bigr).
  \]
  \end{lemma}
  
  \begin{proof}
  We prove the two claims.
  
  \paragraph{Finite repetition $C^n$.}
  We argue by induction on $n$.
  For $n=1$, we have $C^1\equiv C$ by definition, hence the claim follows from the hypothesis.
  For $n>1$, the definition gives $\pi\ \satt\ C^n$ iff $\pi\ \satt\ C;C^{n-1}$.
  Likewise, the violation clause for $C^n$ can only arise either from an initial violation of $C$,
  or after some satisfied prefix where a later copy of $C$ is violated.
  In either case, if we assume toward contradiction that
  $\pi\ \satt\ C^n$ and $\pi\ \violt\ C^n$, then we obtain a contradiction with
  (i) Lemma~\ref{lem:binary-disjoint} for the sequence operator (applied to $C$ and $C^{n-1}$),
  (ii) the induction hypothesis for $C$, and
  (iii) the induction hypothesis for $C^{n-1}$ together with the suffix-disjointness assumption.
  Thus, $\neg(\pi\ \satt\ C^n\ \nd\ \pi\ \violt\ C^n)$ holds.
  
  \paragraph{Unbounded repetition $\repit{C}$.}
  By definition, $\pi\ \satt\ \repit{C}$ is \emph{false} for every finite trace $\pi$.
  Hence, $\pi$ cannot both tightly satisfy and tightly violate $\repit{C}$.
  \end{proof}
  



  \subsubsection*{Regular Expression Binary Operator Semantics}
  \label{sec:regex-contract}
  Contracts guarded by regular expressions specify that a normative condition becomes active only after the trace matches a given regular pattern.  
  Such patterns, written $re$, are interpreted over the letter alphabet 
  $\Gamma = 2^{\Sigma}$ introduced above.  
  They act as \emph{temporal triggers} that delimit
  where an obligation, prohibition, or reparation clause starts to apply.
  
  Two guarded forms are distinguished:
  \begin{itemize}
    \item The \emph{triggered contract} $\trig[re]{C}$, which activates $C$ as soon as a prefix of the trace matches $re$.
    \item The \emph{guarded contract} $\guard[re]{C}$, which restricts $C$ to hold only while the trace remains within the language induced by $re$.
  \end{itemize}
  The first captures temporal activation (“after the trigger, $C$ must hold”),
  the second conditional persistence (“as long as $re$ remains possible, $C$ must hold”).
  
  \begin{definition}[Triggered and Guarded Contracts]
    \label{def:trigger-guard-semantics}
    Let $\pi$ be a finite trace over $\Gamma = 2^{\Sigma}$ with  $s=\size{\pi}$.
    \[
    \begin{array}{l@{\quad}c@{\quad}l}
    \pi\ \satt\ \trig[re]{C}
      &\mydef& 
      \pi\ \violt\ re\
      \sor\
      \big(\exists\,k \in [1, s-1]:\ \pi_k\ \satt\ re\ \nd\ \pi^{k}\ \satt\ C\big),
      \\[1.2ex]
    
      \pi\ \violt\ \trig[re]{C}
      &\mydef& 
      \exists\,k \in [1, s-1]:\ \pi_k\ \satt\ re\ \nd\ \pi^{k}\ \violt\ C,
      \\[2ex]
    
      \pi\ \satt\ \guard[re]{C}
      &\mydef&
      \big(\pi\ \violt\ re\ \nd\ \pi\ \clossat\ C\big)\
      \sor\
      \big(\pi\ \clossat\ re\ \nd\ \pi\ \satt\ C\big),
      \\[1.2ex]
    
      \pi\ \violt\ \guard[re]{C}
      &\mydef&
      \pi\ \clossat\ re\ \nd\ \pi\ \violt\ C.
    \end{array}
    \]
    Where $\pi\ \clossat\ X$ abbreviates $(\pi\ \presat\ X\ \sor\ \pi\ \satt\ X)$.
  \end{definition}
  
  \begin{lemma}[Local disjointness for triggered and guarded contracts]
    \label{lem:regex-disjoint}
    Let $re$ be a regular expression over $\Gamma$ and let $C$ be a contract.
    Assume disjointness for both components, namely for every finite trace $\Pi_{\min}$:
    \[
    \neg(\Pi_{\min}\ \satt\ re\ \nd\ \Pi_{\min}\ \violt\ re)
    \quad\text{and}\quad
    \neg(\Pi_{\min}\ \satt\ C\ \nd\ \Pi_{\min}\ \violt\ C),
    \]
    and assume the same disjointness holds for every suffix $\Pi_{\min}^k$ in place of $\Pi_{\min}$.
    Then for every finite trace $\pi$:
    \[
    \neg\bigl(\pi\ \satt\ \trig[re]{C}\ \nd\ \pi\ \violt\ \trig[re]{C}\bigr)
    \quad\text{and}\quad
    \neg\bigl(\pi\ \satt\ \guard[re]{C}\ \nd\ \pi\ \violt\ \guard[re]{C}\bigr).
    \]
  \end{lemma}
    
  \begin{proof}
    We treat the two constructors.
    
    \paragraph{Triggered $\trig[re]{C}$.}
    Assume toward contradiction that $\pi\ \satt\ \trig[re]{C}$ and $\pi\ \violt\ \trig[re]{C}$.
    From the violation clause, there exists $k \in [1, s-1]$ such that $\pi_k\ \satt\ re$ and $\pi^{k}\ \violt\ C$.
    
    From the satisfaction clause, either (a) $\pi\ \violt\ re$ or (b) there exists $m \in [1, s-1]$ such that $\pi_m\ \satt\ re$ and $\pi^{m}\ \satt\ C$.
    
    \noindent\emph{Case (a):} We have $\pi_k \satt re$ (from violation) and $\pi \violt re$ (from assumption).
    By Lemma~\ref{lem:mutual prefix} (Mutual Prefix Exclusion applied to $re$), if a prefix $\pi_k$ tightly satisfies $re$, the full trace $\pi$ (which is an extension of $\pi_k$) cannot tightly violate $re$. Contradiction.
    
    \noindent\emph{Case (b):} We have $\pi_k \satt re$ and $\pi_m \satt re$.
    By Lemma~\ref{lem:mutual prefix} applied to $re$, there is at most one prefix of $\pi$ that tightly satisfies $re$. Thus, $k=m$.
    This implies we have both $\pi^{k}\ \violt\ C$ and $\pi^{k}\ \satt\ C$ on the \emph{same} suffix.
    This contradicts the disjointness hypothesis for $C$ on the suffix $\pi^{k}$.
    
    Hence, $\pi$ cannot both tightly satisfy and tightly violate $\trig[re]{C}$.
    
    \paragraph{Guarded $\guard[re]{C}$.}
    Assume toward contradiction that $\pi\ \satt\ \guard[re]{C}$ and $\pi\ \violt\ \guard[re]{C}$.
    By Definition~\ref{def:trigger-guard-semantics}, violation means $\pi\ \clossat\ re$ and $\pi\ \violt\ C$.
    Satisfaction means either (i) $\pi\ \violt\ re$ and $\pi\ \clossat\ C$, or (ii) $\pi\ \clossat\ re$ and $\pi\ \satt\ C$.
    
    \noindent\emph{Case (ii):} This yields $\pi\ \clossat\ re$ (consistent) but $\pi\ \satt\ C$ and $\pi\ \violt\ C$. This contradicts the disjointness hypothesis for $C$.
    
    \noindent\emph{Case (i):} This yields $\pi\ \clossat\ re$ and $\pi\ \violt\ re$.
    Expanding $\clossat$, this means $(\pi\ \presat\ re \sor \pi\ \satt\ re) \nd \pi\ \violt\ re$.
    By the disjointness hypothesis for $re$, $\satt$ excludes $\violt$.
    By Lemma~\ref{lem:mutual prefix}, $\presat$ excludes $\violt$.
    Thus, Case (i) is impossible.
    
    Thus guarded contracts are also disjoint.
  \end{proof}

\begin{example}[Triggered and guarded contracts]
\label{ex:trigger-guard}
Let the collaboration alphabet be
\[
\Sigma_C=\{\PAY,\ \PAYF,\ \OCC,\ \notifrepair,\ \notifterm,\ \REPAIR\}.
\]

\paragraph{(a) Triggered contract.}
Clause~$C_4$ specifies that when the tenant requests a repair, the landlord must perform it within the following period:
\[
C_4 := \trig[\{\notifrepair^{(1)}\}]{\obl[2]{\REPAIR}}.
\]

\emph{Tight satisfaction.}
\[
\pi_{\mathsf{sat}}=\langle A_1,A_2\rangle,
\text{ with }
A_1=\{\notifrepair^{(1)}\} \nd
A_2=\{\REPAIR^{(1)},\REPAIR^{(2)}\}.
\]
In the first month, the trigger $\notifrepair^{(1)}$ occurs,
activating the repair obligation.
In month 2, the landlord performs $\REPAIR^{(1,2)}$,
thus $\pi_{\mathsf{sat}}\ \satt\ C_4$.

\emph{Tight violation.}
\[
\pi_{\mathsf{viol}}=\langle A_1,A_2'\rangle,
\text{ with }
A_1=\{\notifrepair^{(1)}\} \nd
A_2'=\emptyset.
\]
The trigger in month 1, but the obligation is unfulfilled:
$\pi_{\mathsf{viol}}\ \violt\ C_4$.

\paragraph{(b) Guarded repetition.}
To limit repetition to the occupancy period, combine guard and repetition:
\[
C_9 := \guard[\,\Gamma^+\,;\,\{\notifterm^{(1)}\}\,;\,\Gamma^{3}]{\repit{\obl[1]{\PAY}}}.
\]
The guard pattern 
$\Gamma^+;\{\notifterm^{(1)}\};\Gamma^{3}$
means “for any non-empty prefix up to the termination notice
$\notifterm^{(1)}$, and for at most three additional steps afterward.”
Within this region, the obligation to pay rent repeats.
Once $\notifterm^{(1)}$ occurs, the duty remains for three more periods,
and the contract is satisfied at $t{=}1{+}3{=}4$.

\emph{Tight satisfaction.}
\[
\pi_{\mathsf{sat}}=
\langle
A_1,A_2,A_3,A_4,A_5
\rangle,
\quad
\begin{array}{l}
A_1=\{\OCC^{(1)},\PAY^{(1)},\PAY^{(2)}\},\\
A_2=\{\notifterm^{(1)},\PAY^{(1)},\PAY^{(2)}\},\\
A_3=A_4=A_5=\{\PAY^{(1)},\PAY^{(2)}\}.
\end{array}
\]
The guard is satisfied in month 5 and the payments were all successful, hence $\pi_{\mathsf{sat}}\ \satt\ C_9$.

\emph{Tight violation.}
\[
\pi_{\mathsf{viol}}=
\langle
A_1,A_2,A_3,A_4,A_5
\rangle,
\quad
\begin{array}{l}
A_1=\{\OCC^{(1)},\PAY^{(1)},\PAY^{(2)}\},\\
A_2=\{\notifterm^{(1)},\PAY^{(1)},\PAY^{(2)}\},\\
A_3=\{\PAY^{(1)},\PAY^{(2)}\},\\
A_4=\emptyset,\\
A_5=\{\PAY^{(1)},\PAY^{(2)}\}.
\end{array}
\]
A missing payment in the fourth month breaks the repetition duty
while the guard still holds, so
$\pi_{\mathsf{viol}}\ \violt\ C_9$.
\end{example}

\subsubsection*{Coherence of the Forward-Looking Contract Satisfaction Semantics}

Coherence requires that for any fixed contract and trace, there is never more than one decisive verdict. A trace cannot both tightly satisfy and tightly violate the same contract on different prefixes, since this would yield two incompatible outcomes for a single execution. Forward semantics must therefore
rule out situations where tight satisfaction appears on one prefix and tight violation appears on another prefix of the same trace. Ensuring this exclusion
makes the decisive point unique, which is required to justify every verdict from $\tightverdicts$.
The next lemma states this exclusion precisely by showing that the two frontiers cannot arise on distinct prefixes of the same trace.

\begin{lemma}[Mutual prefix exclusion tight satisfaction and violation]
\label{lem:mutual prefix}
For every contract $C$ in \cDL\ and every finite trace $\pi$, the tight satisfaction and tight violation forward semantics are mutually exclusive, that is:
\begin{enumerate}
  \item \emph{No earlier tight violation at or after tight satisfaction.}\\[2pt]
   $\text {If }\displaystyle \pi\ \satt\ C \ \text{then}\ \nexists\,j<|\pi|:\ \pi[1,j]\ \violt\ C\big.$

  \item \emph{No earlier tight satisfaction at or after tight violation.}\\[2pt]
  $\displaystyle \text {if } \pi\ \violt\ C \ \text{then}\ \nexists\,j<|\pi|:\ \pi[1,j]\ \satt\ C\big.$
\end{enumerate}


\end{lemma}

\begin{proof}[Proof sketch]
By structural induction on the syntactical structure of $C$.

\smallskip
\emph{Base case: literals.}
By Definition~\ref{def:lattsat}, a literal is decided on a single letter:
$\trace{A}\ \satt\ \ell$ iff the letter constraint holds, and
$\trace{A}\ \violt\ \ell$ iff it does not. These are complements on that step, so the two implications are immediate, and uniqueness follows.

\medskip
\noindent\textbf{Inductive hypotheses.}
Assume the theorem holds for subcontracts as needed below. We use:
\[
\begin{aligned}
\text{(IH-$C$-sat)}\quad 
&\forall\pi\; \bigl(\pi\ \satt\ C \Rightarrow \forall j<|\pi|:\neg(\pi[1,j]\ \violt\ C)\bigr),\\
\text{(IH-$C$-viol)}\quad 
&\forall\pi\; \bigl(\pi\ \violt\ C \Rightarrow \forall j<|\pi|:\neg(\pi[1,j]\ \satt\ C)\bigr),
\end{aligned}
\]
and similarly (IH-$C'$-sat) and (IH-$C'$-viol) when a second operand $C'$ is present; for regex guards $re$ we use the same two clauses with $re$ in place of $C$.

\paragraph{Conjunction $C\wedge C'$.}
By Definition~\ref{def:binary-contract-semantics}, tight satisfaction requires
first successes at some $k,k'$ with decisive index $j^\star=\max\{k,k'\}$.
For every $j<j^\star$, either $j<k$ or $j<k'$ holds, hence by (IH-$C$-sat) and
(IH-$C'$-sat) neither $\pi[1,j]\ \violt\ C$ nor $\pi[1,j]\ \violt\ C'$ holds.
Since a tight violation of a conjunction is a tight violation of the conjunction,
no $j<j^\star$ violates $C\wedge C'$. This proves the first implication.
For the second, if some prefix tightly violates a conjunct, then by
(IH-$C$-viol) or (IH-$C'$-viol) no earlier prefix tightly satisfies that conjunct, hence, no earlier prefix tightly satisfies the conjunction.

\paragraph{Sequence $C;C'$.}
By Definition~\ref{def:binary-contract-semantics}, tight satisfaction needs a split
$k$ with $\pi[1,k]\ \satt\ C$ and $\pi[k{+}1,|\pi|]\ \satt\ C'$.
For any $j\le k$, (IH-$C$-sat) forbids $\pi[1,j]\ \violt\ C$; for any
$j>k$, (IH-$C'$-sat) applied to the suffix forbids $\violt C'$ before its
own decisive point. A tight violation of $C;C'$ before satisfaction is either
a violation of $C$ before $k$ or a violation of $C'$ after $k$, both excluded.
The dual implication follows from (IH-$C$-viol) and (IH-$C'$-viol).

\paragraph{Reparation $C\repair C'$.}
By Definition~\ref{def:binary-contract-semantics}, either $C$ succeeds, or else at
the first tight violation index $k$ of $C$ the repair $C'$ must succeed on
$\pi^{k}$. In the first branch (IH-$C$-sat), it excludes earlier violations.
In the second branch, (IH-$C$-viol) gives minimal property of the failure point of $C$,
and (IH-$C'$-sat) on the suffix excludes earlier failure of the composite
before its tight success. The dual implication is symmetric, using (IH-$C$-viol) and (IH-$C'$-viol).

\paragraph{Finite repetition $C^n$.}
Unfold $C^n \equiv C;(C^{n-1})$ and argue by a secondary induction on $n$,
using the sequence case and the induction hypotheses for $C$ and $C^{n-1}$.

\paragraph{Unbounded repetition $\repit{C}$.}
Under tight semantics $\repit{C}$ never tightly satisfies and tightly violates
iff some finite unrolling $C^m$ tightly violates. The two implications reduce
to the finite case above.

\paragraph{Triggered $\langle re\rangle C$.}
By Definition~\ref{def:trigger-guard-semantics}, either $re$ is violated and the
contract tightly satisfies vacuously, or there is a first $k$ with $\pi_k\ \satt\ re$
and then the suffix must satisfy $C$. In the vacuous branch,
(IH-$re$-viol) forbids any earlier tight satisfaction of $re$, so there is no
earlier tight violation of the composite. In the active branch, the first match
index $k$ is minimal by (IH-$re$-sat); before $k$ the composite is undecided, and
after $k$ we apply (IH-$C$-sat)/(IH-$C$-viol) on the suffix to obtain both implications.

\paragraph{Guarded $[re]\,C$.}
While $\pi$ \emph{closes} $re$ (that is, $\pi$ is in the open region for $re$), any tight or post failure of $C$ yields a tight or post failure of the composite.
Once $re$ becomes impossible, the composite satisfies provided $C$ has not failed.
Combine (IH-$re$-sat) and (IH-$re$-viol) with (IH-$C$-sat) and (IH-$C$-viol),
and the guarded case table in Definition~\ref{def:trigger-guard-semantics}, to derive the two implications.

\medskip
All constructors preserve the two “no-backtrack” properties; hence, the claim holds for all $C$.
\end{proof}


% --- BEGIN INSERTED LEMMA ---
\begin{lemma}[Constructor-wise disjointness of the tight frontiers]
\label{lem:constructor-disjoint}
For every contract $C$ in \cDL\ and every finite trace $\pi$, we have
\[
\neg\bigl(\pi\ \satt\ C\ \nd\ \pi\ \violt\ C\bigr).
\]
\end{lemma}

\begin{proof}
By structural induction on the syntax of $C$.

\emph{Base: literals.} Disjointedness holds by Definition~\ref{def:lattsat}, since on a single letter the satisfaction and violation clauses are complementary.

\emph{Inductive steps.}
For binary constructors $C_1\wedge C_2$, $C_1;C_2$, and $C_1\repair C_2$, the claim follows from Lemma~\ref{lem:binary-disjoint} and the induction hypotheses for $C_1$ and $C_2$ (including the required suffix form).
For repetition constructors $D^n$ and $\repit{D}$, the claim follows from Lemma~\ref{lem:repetition-disjoint} and the induction hypothesis for $D$.
For triggered and guarded constructors $\trig[re]{D}$ and $\guard[re]{D}$, the claim follows from Lemma~\ref{lem:regex-disjoint} together with the induction hypotheses for $re$ and $D$.
No other constructors exist.
\end{proof}
% --- END INSERTED LEMMA ---

\begin{theorem}[Consistency of the forward-looking five tight semantics for \cDL]\label{thm:five-partition}
The five forward satisfaction relations
$\{\presat,\satt,\violt,\postsat,\postviol\}$ for \cDL are pairwise disjoint and jointly exhaustive.
\end{theorem}
\begin{proof}
Fix a finite trace $\pi$ and contract $C$.
We reason point-wise on prefixes of $\pi$ (as defined in Section~\ref{traces}) and lift the result to the trace-level relations via Definition~\ref{def:postprecont}.

By Lemma~\ref{lem:mutual prefix}, along a fixed trace the two frontiers cannot both occur on (possibly different) prefixes: if some prefix tightly satisfies $C$, then no prefix tightly violates $C$, and conversely.
Moreover, constructor-wise disjointness holds point wise for every prefix, that is, $\neg(\Pi_{\min}\ \satt\ C\ \nd\ \Pi_{\min}\ \violt\ C)$ for every prefix $\Pi_{\min}$.
This is established formally in Lemma~\ref{lem:constructor-disjoint}.

Now consider any prefix position $j$ with $1\le j<|\pi|$ and view the corresponding trace prefix $\pi[1,j]$.
By Definition~\ref{def:postprecont}, for a given prefix $\Pi_{\min}:=\pi[1,j]$ exactly one of the following holds:
(i) $\Pi_{\min}\ \presat\ C$ (no earlier prefix of $\Pi_{\min}$ is decisive),
(ii) $\Pi_{\min}\ \satt\ C$,
(iii) $\Pi_{\min}\ \violt\ C$,
(iv) $\Pi_{\min}\ \postsat\ C$ (some earlier prefix of $\Pi_{\min}$ tightly satisfies $C$), or
(v) $\Pi_{\min}\ \postviol\ C$ (some earlier prefix of $\Pi_{\min}$ tightly violates $C$).
These cases are mutually exclusive by the local disjointness results above together with Lemma~\ref{lem:mutual prefix}, which prevents mixing satisfaction-frontiers and violation-frontiers along the same trace.

Therefore, the five relations $\{\presat,\satt,\violt,\postsat,\postviol\}$ are pairwise disjoint and jointly exhaustive on prefixes of $\pi$.
Since $\pi$ was arbitrary, the claim holds for all finite traces.
\end{proof}




\paragraph{Next step.}
After establishing the forward tight satisfaction semantics in \cDL and studied their soundness. We now move from the denotational clauses to an operational view:  we construct the corresponding Moore-style monitors for the tight five-valued semantics and establish that their outputs coincide with the semantic judgements on every finite trace prefix.


\input{forwardtight1.tex}

\input{forwardtight2.tex}

\input{quantitativeviol.tex}