\section{Discrete-Action Word Models}\label{traces}
Since our normative specifications constrain what agents ought to do, we take discrete actions as primitive and represent executions as discrete-action words.
In contrast to control-theoretic and physical models based on continuous signals or state trajectories, our setting is action-centric: we record which actions occur, and we reason about their order and, when needed, their timing.
Accordingly, a word is a sequence of discrete events that captures ``what happened'', rather than a valuation that describes ``what holds'' over time.
These words form the basic semantic objects for the logics developed in subsequent chapters.
When we speak of traces, we mean recorded words obtained from concrete executions.

We begin by establishing three word models depending on their timing settings and the canonical morphisms between them. Subsequently, we study how to synchronize two words of the same type.

\subsection{Notations on Discrete-Action Words}
For the remainder of this dissertation, let \(\Sigma\) denote a non-empty set of discrete \footnote{instantaneous, with no durations} \emph{actions}. Before introducing the specific timing models, we fix a small algebraic core shared by all discrete-action words, specifically the basic sequence structure and standard operators.

\paragraph{Events and Words.}
We formalize the universe of atomic occurrences of an action as a type called the \emph{event domain}, denoted by $\mathbb{E}$.
An individual object of this type is an \emph{event}, denoted by $e$.
The specific structure of these events is determined by the timing model applied to the alphabet $\Sigma$ (e.g., $\mathbb{E} = \Sigma$ for untimed words).
Sequences of these events form the set of \emph{finite words}, denoted by $\mathbb{E}^*$, and the set of \emph{infinite words}, denoted by $\mathbb{E}^\omega$.
The set of all words is defined as the union $\mathbb{E}^\infty := \mathbb{E}^* \cup \mathbb{E}^\omega$.
% An \emph{event}, denoted by $e$, is an element of an event domain $\mathbb{E}$. The specific structure of $\mathbb{E}$ depends on the timing model derived from $\Sigma$ (e.g., $\mathbb{E} = \Sigma$ for untimed words).
% We denote the set of \emph{finite words} over $\mathbb{E}$ by $\mathbb{E}^*$, the set of \emph{infinite words} by $\mathbb{E}^\omega$, and the set of all words by $\mathbb{E}^\infty := \mathbb{E}^* \cup \mathbb{E}^\omega$.


The empty word, denoted by $\emptytrace$, is the unique finite word containing no events. The set of non-empty finite words is $\Sigma^+$, we have $\Sigma^*= \emptytrace \cup \Sigma^+$.

\paragraph{Notation for non-empty finite words.}
Let \( w = \langle e_1,\,e_2,\,\dots,\,e_{n} \rangle \in \mathbb{E}^+ \) be a non-empty finite word.
We adopt \emph{1-based indexing} where indices correspond to the position of events in the sequence.

\begin{itemize}
    \item \defn{Size}: The length of the word denoted by $\size{w}$, is defined as \( |w| := n \).
    
    \item \defn{Positions}: The set of valid positions is \( \mathsf{pos}(w) := \{1, 2, \dots, n\} \).
    
    \item \defn{Indexing}: For any \( k \in \mathsf{pos}(w) \), the event at position \(k\) is \( w[k] := e_k \).
    
    \item \defn{Prefix}: For any \( 1 \le k \le n \), the prefix of length \( k \) is denoted by \( w_k \):
    \[
        w_k := \langle e_1, \dots, e_k \rangle.
    \]
    By convention, we set up: \( w_0 = \emptytrace \) and \( w_n = w \).
    
    \item \defn{Suffix}: For any \( 0 \le k \le n \), the suffix remaining \emph{after} the first \( k \) events is denoted by \( w^k \):
    \[
        w^k := \langle e_{k+1}, \dots, e_n \rangle.
    \]
    Note that \( w^0 = w \) and \( w^n = \emptytrace \).
\end{itemize}



\paragraph{Words vs. Traces.}
We conceptually distinguish a \emph{finite word} (conceptual model) from a \emph{finite trace} (an observed behavior of a system/agent). However, formally, both are finite sequences of events in $\mathbb{E}^*$. In this dissertation, we use \emph{word} as the default technical term and \emph{trace} when emphasizing that the sequence is the result of a recorded observation.

\paragraph{Omega notation.}
For any non-empty finite word $u \in \mathbb{E}^{+}$, written $u=\langle e_1,\dots,e_n \rangle$ with $n\ge 1$, we write
$u^{\omega}$
to denote the infinite word obtained by repeating $u$ indefinitely:
\[
u^{\omega} \;:=\; \langle e_1,\dots,e_n,\,e_{n+1},\dots,e_{n+n},\,\dots \rangle \;\in\; \mathbb{E}^{\omega}.
\]
where for $k>n$, the event $e_k$ is defined by the modulo relation:
\[
e_k := e_{((k-1) \bmod n)+1},
\]
so that $u^{\omega}$ cycles through the events of $u$ indefinitely.
\paragraph{Prefix of an infinite word.}
Let \(v \in \mathbb{E}^{\omega}\) be an infinite word and let \(u \in \mathbb{E}^{*}\) be a finite word.
We say that \(u\) is a \defn{prefix} of \(v\), written \(u \preceq v\), if there exists
\(k \in \mathbb{N}\) such that \(|u| = k\) and
\[
\forall i \in \{1,\dots,k\},\quad u[i] = v[i].
\]

\paragraph{Prefix order.}
For any finite word \(u \in \mathbb{E}^*\) and any word
\(v \in \mathbb{E}^\infty\), we write \(u \preceq v\) if
\(u = v_k\) for some \(k \in \mathbb{N}\).
If additionally \(u \neq v\), we write \(u \prec v\).


\paragraph{Generic Projection.}
For a subset of events $S \subseteq E$, the projection $w{\upharpoonright}S$ is the subsequence obtained by deleting all events $e_k$ such that $e_k \notin S$.


\subsection{Logical-Time Words}

Logical-time words capture \emph{order only}, abstracting away any notion of specific timing. They are the staple semantic objects in interleaving models of process calculi (such as CCS\cite{Milner89} and CSP\cite{hoare1978communicating}). Moreover, in Mazurkiewicz trace theory, one starts from strings over an alphabet and then forms \emph{traces} by identifying strings that differ only by swapping adjacent independent actions (that is, a trace is an equivalence class of words modulo an independence relation) \cite{diekert1995book}.

\begin{definition}[Logical-time word, notation \(\tault\)]
  A (finite) logical-time word over an alphabet \(\Sigma\) is a sequence:
  \[
  \tault\;=\; \trace{a_1,\, a_2,\,\dots,\,a_{n}}\ \in\ \Sigma^{*},
  \]
  where \(a_k\in\Sigma\) for all \(k\in\{1,\dots,n\}\).
\end{definition}

We now introduce basic operators on logical-time words. We start with concatenation, then define a counting function for action occurrences. Both notions will be reused when relating logical-time words to the richer time models introduced next.


%
\begin{definition}[Concatenation of logical-time words]
  Let $\tault_1=\trace{(a_1),\dots,(a_{n})}\in\Sigma^{*}$ and
  $\tault_2=\trace{(b_1),\dots,(b_{m})}\in\Sigma^{*}$.
  Their \defn{concatenation}, written $\tault_1\concat\tault_2$, is the logical-time word in $\Sigma^{*}$ defined by
  \[
    \tault_1 \concat \tault_2
    \;:=\;
    \trace{(a_1),\dots,(a_{n}),(b_1),\dots,(b_{m})}.
  \]
  \[
    \tault_1 \concat \emptytrace
    \;:=\;
    \tault_1.
  \]
  \[
    \emptytrace \concat \tault_2
    \;:=\;
    \tault_2.
  \]
\end{definition}


Additionally, the following holds for the concatenation of any two logical-time words:
\begin{itemize}
  \item \defn{Length}: $\lvert\tault_1\concat\tault_2\rvert = \lvert\tault_1\rvert + \lvert\tault_2\rvert$.
  \item \defn{Indexing}: for $k\in\mathsf{pos}(\tault_1\concat\tault_2)$,
  \[
  (\tault_1\concat\tault_2)[k] :=
  \begin{cases}
    \tault_1[k], & \text{if } 1\le k \le \lvert\tault_1\rvert,\\
    \tault_2[k-\lvert\tault_1\rvert], & \text{if } \lvert\tault_1\rvert < k \le \lvert\tault_1\rvert+\lvert\tault_2\rvert.
  \end{cases}
  \]
\end{itemize}

The next operator abstracts from positions and records how often a given action occurs in a word.

\begin{definition}[Counting function on logical-time words]
  Let $a\in\Sigma$ and let  $\tault$ be a logical-time word $\tault=\trace{(a_1),\dots,(a_{n})}\in\Sigma^{*}$ .
  The \defn{count} of $a$ in $\tault$, written $\#(a,\tault)$, is defined by
  \[
    \#(a,\tault)
    \;:=\;
    \big|\{\, k\in\mathsf{pos}(\tault) \mid \tault[k]=a \,\}\big|.
  \]
\end{definition}



% \begin{example}[Logical-time operators]
%   Let \( \Sigma=\{\textsf{pick},\textsf{handover}\} \).
%   Consider the word:
%   \[
%   \tault=\trace{(\textsf{pick}),(\textsf{handover})}.
%   \]
%   \emph{Size and Indexing:} \(|\tault|=2\), \(\tault[1]=\textsf{pick}\).\\
%   \emph{Counts:} \(\#({\textsf{handover}},\tault)=1\).\\
%   \emph{Projection:} with \(A=\{\textsf{handover}\}\), \(\tault{\upharpoonright}A=\trace{(\textsf{handover})}\).\\
%   \emph{Concatenation:} \(\tault\concat\trace{(\textsf{pick})} = \trace{(\textsf{pick}),(\textsf{handover}),(\textsf{pick})}\).
% \end{example}


\subsection{Metric-Timed Words}

Metric-time words extend the previous model by recording \emph{which} action occurs and \emph{when} it occurs. They are defined in research works on automata with time \cite{DBLP:journals/tcs/AlurD94}.

\begin{definition}[Finite \timedwords of actions] \label{timedwords} 
    A \emph{finite \timedword} $\tau$ is defined as a finite sequence of time events, $\tau \in ({\timedevents})^*$.
     \[\tau := \trace{(a_1,t_1), (a_2,t_2), \ \dots, \ (a_{n},t_{n}) }\]
     with \(a_k\in\Sigma\), \(t_k\in\mathbb{N}\), and strictly increasing timestamps \(0\le t_1<\cdots<t_{n}\).
\end{definition}

% NOTE: The definition name is left as is, but the surrounding prose and references should use "words"
\begin{definition}[Auxiliary operators on metric-time words]
  Let $\taumt=\trace{(a_1,t_1),\dots,(a_{n},t_{n})}\in(\Sigma\times\mathbb{N})^{*}$.
  \begin{itemize}
    \item The \defn{label} and \defn{timestamp} projections of the $k$th event are defined by
    \[
      \mathsf{lab}(\taumt,k):=a_k,\qquad \mathsf{ts}(\taumt,k):=t_k\qquad (k\in\mathsf{pos}(\taumt)).
    \]
    \item The \defn{time set} of $\taumt$ is
    \[
      \mathsf{time}(\taumt):=\{\, t_k \mid k\in\mathsf{pos}(\taumt)\,\}.
    \]
    \item The \defn{last time point} is defined by
    \[
      \mathsf{last}(\taumt):=
      \begin{cases}
        t_n, & \text{if } n>0,\\
        0, & \text{if } n=0.
      \end{cases}
    \]
    \item The \defn{time span} is
    \[
      \mathsf{span}(\taumt):=
      \begin{cases}
        t_n-t_1, & \text{if } n>0,\\
        0, & \text{if } n=0.
      \end{cases}
    \]
    \item For $a\in\Sigma$, the \defn{count} of $a$ in $\taumt$ is
    \[
      \#(a,\taumt):=\big|\{\, k\in\mathsf{pos}(\taumt) \mid \mathsf{lab}(\taumt,k)=a \,\}\big|.
    \]
  \end{itemize}
\end{definition}

We denote the set of all finite metric-timed words by $\domtr$. Unlike the logical-time setting, where events are compared solely by order, this model supports quantitative reasoning about the precise timing between events. This added expressiveness, however, restricts algebraic composition: concatenation is not defined for arbitrary pairs of words, as the combined sequence must respect the strictly increasing order of timestamps. To formalize these timing properties, the next definitions introduce two auxiliary operators: $\Delta$ measures the elapsed time between positions, while $\rho$ retrieves the action occurring at a specific absolute time.
    \begin{definition}[Timed distance between two events]
        Let $\taumt=\trace{(a_1,t_1),\dots,(a_{n},t_{n})}\in(\Sigma\times\mathbb{N})^{*}$ be a metric-time word.
        For any two indices $i,j\in\mathsf{pos}(\taumt)$ with $i<j$, the \defn{time distance} between event $i$ and event $j$ is
        \[
          \Delta(\taumt,(i,j))\;:=\; t_j-t_i.
        \]
      \end{definition}
    
     \begin{definition}[Action Lookup Function]\label{defrho}
     
     The \emph{action lookup function} $\rho : \domtr \times \mathbb{N} \to \Sigma \cup \{ \Undef \}$ returns the action performed at absolute time $t$ in a metric-time word; if no event occurs at time $t$, it returns the special symbol $\Undef$:
        \[
        \rho\big(\trace{(a_1,t_1), \dots, (a_{n},t_{n})}, t\big) := 
        \begin{cases} 		
            a_i & \text{if  } t_i=t \text{ for some } i \in \{1,\dots,n\},\\
            \Undef & \text{otherwise.}
        \end{cases}
        \]
    \end{definition}


\noindent\textbf{Basic operators and short hands.}
For \(A\subseteq\Sigma\), projection \( \taumt{\upharpoonright}A\in(A\times\mathbb{N})^{*} \) keeps exactly the pairs \((a,t)\) where \(a\in A\).
Prefixes can be defined by \emph{length} \( \taumt[1,k] \), or by \emph{time} \( \taumt{\upharpoonright}\{t\le T\} \) (shorthand: \( \taumt\{t\le T\}\)).


\begin{example}[Metric-timeo perators]
  Consider an alphabet $\Sigma=\{\textsf{badge\_tapped},\textsf{door\_open}\}$.
  \[
  \taumt=\trace{(\textsf{badge\_tapped},1),(\textsf{door\_open},3)}.
  \]
  \emph{Size and Indexing:} \(|\taumt|=2\), \(\taumt[1]=(\textsf{badge\_tapped},1)\).\\
  \emph{Lookup action:} $\rho(\taumt,1)=\textsf{badge\_tapped}$ and $\rho(\taumt,2)= \Undef$.\\
  \emph{Time properties:} \(\mathsf{time}(\taumt)=\{1,3\}\), \(\mathsf{span}(\taumt)=2\).\\
  \emph{Time-prefix:} \(\taumt\{t\le 2\}=\trace{(\textsf{badge\_tapped},1)}\).\\
  \emph{Timed distance}: the distance between event $1$ and event $2$ is $\Delta(\taumt,(1,2))=3-1=2$.
\end{example}

Metric-time words provide \emph{precise} quantitative information, in particular the exact time distance between any two events in the same word, captured by differences of their timestamps.
For this model, concatenation is not defined for arbitrary pairs of words: if two words both contain an event at the same time point, then concatenating them would violate the requirement of strictly increasing timestamps. Hence, concatenation is only defined when the timestamp sets are disjoint and the last time point of the first word is strictly smaller than the first time point of the second word.


\subsection{Synchronous-Time Words}
Synchronous-time words represent behavior under a single global logical clock. Each tick corresponds to one round of computation, and inactivity is made explicit via the stutter symbol ``$-$''. This model underlies synchronous languages such as Esterel\cite{berry1984esterel}, Lustre\cite{Halbwachs93}, and LoLa\cite{d2005lola}.

\paragraph{The synchronous hypothesis.}
The synchronous hypothesis fixes the intended abstraction level: within one clock cycle, the system reads its inputs, computes the next state, and emits its outputs within the same logical instant. Computation is therefore treated as taking zero time, and time advances only between cycles. Accordingly, behavior is naturally represented as a word indexed by $\mathbb{N}$, where each position corresponds to one tick and records the global observation at that tick, for instance as a global state or as a set of events. Related synchronous process-algebra variants also exist, most notably Milner's synchronous CCS (SCCS), which adopts the same global-clock view and interprets behavior as lockstep rounds of actions \cite{milner1983calculi}.

\begin{definition}[Synchronous-time word, notation \(\taust\)]
  Fix an alphabet \(\Sigma\) and a stutter symbol ``\(-\)'' with \( -\notin\Sigma \).
  A (finite) \emph{synchronous-time word} is a finite sequence of events over $(\Sigma\cup\{-\})$
  \[
  \taust \;=\; \trace{(s_1),\,(s_2),\,\dots,\,(s_T)} \ \in\ (\Sigma\cup\{-\})^{*},
  \]
  where \(s_t\in\Sigma\cup\{-\}\) represents the observation at round \(t\) and \(T\) is called the \defn{horizon}.
\end{definition}

Synchronous-time words timing model is between logical-time words and metric-time words. Like logical time, they are discrete sequences, but they come with an explicit global round index that plays the role of a coarse clock. Like metric time, one can talk about \emph{when} something happens, but only in terms of round numbers rather than absolute timestamps. The crucial difference to both earlier models is that the \emph{absence} of an action is itself observable, represented by the stutter symbol ``$-$''.


  

\noindent\textbf{Basic operators and short hands.}
For \(A\subseteq\Sigma\):
\begin{itemize}
  \item \defn{Stutter-preserving projection} \( \taust{\upharpoonright}A \in (A\cup\{-\})^{*} \) keeps letters in \(A\) and all ``\(-\)''.
  \item \defn{Logical (stutter-erasing) projection} \( \erase_{-}(\taust{\upharpoonright}A)\in A^{*} \) drops all ``\(-\)''.
\end{itemize}
For $a\in\Sigma$, the \defn{count} of $a$ in $\taust$ is $\#(a,\taust):=\big|\{\, t\in\mathsf{pos}(\taust)\mid \taust[t]=a \,\}\big|$, and the set of \defn{active rounds} is $\mathsf{act}(\taust):=\{\, t\in\mathsf{pos}(\taust)\mid \taust[t]\neq - \,\}$.


\begin{example}[controller at 1\,Hz, illustrating all operators]
    Consider HVAC (Heating, Ventilation, and Air Conditioning) actuator (1) and a security Sensor (2), both controlled by a synchronous controller:
    \[
    \Sigma_1=\{\textsf{heat\_on}\},\qquad 
    \Sigma_2=\{\textsf{door\_lock}\}.
    \]
    In one episode, we record
    \[
    \taust_1=\trace{(-),(-),(\textsf{heat\_on})},\qquad
    \taust_2=\trace{(-),(\textsf{door\_lock}),(-)}.
    \]
    
    \noindent\emph{Size, positions, indexing:}\\
    \(|\taust_1|=|\taust_2|=3\) with horizon \(T=3\),  
    \(\mathsf{pos}(\taust_1)=\{1,2,3\}\),  
    \(\taust_1[3]=\textsf{heat\_on}\).
    
    \noindent\emph{Counts and active rounds:}\\
    \(\#(\textsf{heat\_on},\taust_1)=1\),  
    \(\mathsf{act}(\taust_1)=\{3\}\).
    
    \noindent\emph{Stutter-preserving projection:}\\
    with \(A=\emptyset\),  
    \(\taust_1{\upharpoonright}A=\trace{(-),(-),(-)}\).
    
    \noindent\emph{Logical (stutter-erasing) projection:}\\
    \(\erase_{-}(\taust_1{\upharpoonright}A)=\emptytrace\),  
    while \(\erase_{-}(\taust_1)=\trace{(\textsf{heat\_on})}\).
    
    \noindent\emph{Round-prefix:}\\
    \(\taust_2[1,2]=\trace{(-),(\textsf{door\_lock})}\).
    
    \end{example}
  

% --- Summary diagram and explanation inserted here ---
\subsection{Connecting the Three Action Word Models}
The objective of this subsection is to connect the three action-centric word models introduced above. Given a metric-time word \(\taumt\), we introduce two canonical morphisms that deliberately discard part of the information: the \emph{logical-time projection} \(\LT\), which erases time stamps while preserving the order of events, and the \emph{synchronous padding} \(\ST\), which aligns events to a global round clock by inserting explicit stutter symbols ``\(-\)''. We set up the clock frequency of the synchronous-time word to correspond to a single unit of metric time.

\noindent\textbf{Summary diagram.}
\ref{fig:word-models-summary} summarizes the relationship between the three word models using a running toy example with two events. Starting from a metric-time word, synchronous padding $\ST$ aligns events to a global round clock by inserting explicit stutters ``$-$'', and logical projection $\LT$ forgets timing information and retains only the event order. The diagram also makes explicit that the co-domain changes across the mappings: $\ST$ moves from time event pairs to round-indexed letters, whereas $\LT$ yields a pure order-only word.

\begin{figure}[t]
\centering
\begin{tikzpicture}[
    node distance=1.5cm,
    font=\sffamily,
    event/.style={circle, draw=blue!80, fill=blue!10, thick, minimum size=8mm, inner sep=0pt},
    stutter/.style={circle, draw=gray!50, fill=gray!10, dashed, minimum size=6mm, inner sep=0pt},
    label text/.style={font=\bfseries\small, align=left},
    axis/.style={->, >=Latex, thick, gray},
    map line/.style={->, dashed, color=gray!80, shorten >=2pt, shorten <=2pt}
]

    % --- 1. Metric-Timed Word (Top Layer) ---
    \node[label text] (mt_label) at (-2, 0) {Metric-Timed\\ $\tau_{mt}$};

    \draw[axis] (0,0) -- (8,0) node[right] {time ($t$)};

    \node[event, label=above:{$t=1$}] (m1) at (2, 0) {$a$};
    \node[event, label=above:{$t=3$}] (m2) at (6, 0) {$b$};

    \foreach \x in {0,1,2,3,4} \draw[gray] (\x*2, 0.1) -- (\x*2, -0.1);
    %\node[below, gray, font=\tiny] at (0,0) {0};
    \node[below, gray, font=\tiny] at (4,0) {2};
    \node[below, gray, font=\tiny] at (8,0) {4};

    % --- 2. Synchronous-Time Word (Middle Layer) ---
    \node[label text] (st_label) at (-2, -2.5) {Synchronous\\ $\tau_{st} = \ST(\tau_{mt})$};

    \draw[axis] (0,-2.5) -- (8,-2.5) node[right] {rounds};

    %\node[stutter, label=below:{\scriptsize 0}] (s0) at (0, -2.5) {$-$};
    \node[event, label=below:{\scriptsize 1}]  (s1) at (2, -2.5) {$a$};
    \node[stutter, label=below:{\scriptsize 2}] (s2) at (4, -2.5) {$-$};
    \node[event, label=below:{\scriptsize 3}]  (s3) at (6, -2.5) {$b$};

    \draw[map line] (m1) -- (s1);
    \draw[map line] (m2) -- (s3);

    % --- 3. Logical-Time Word (Bottom Layer) ---
    \node[label text] (lt_label) at (-2, -5) {Logical-Time\\ $\tau_{lt} = \LT(\tau_{mt})$};

    \node[event] (l1) at (3, -5) {$a$};
    \node[event] (l2) at (5, -5) {$b$};

    \draw[->, thick, shorten >=1pt] (l1) -- (l2);

    \draw[map line] (s1) -- (l1);
    \draw[map line] (s3) -- (l2);

    \node[right, gray, font=\footnotesize, align=left] at (8.5, -1.25)
        {\textbf{Synchronous Padding} $\ST$\\
         Aligns events to clock ticks\\
         Inserts `$-$' where needed};

    \node[right, gray, font=\footnotesize, align=left] at (8.5, -3.75)
        {\textbf{Logical Projection} $\LT$\\
         Forgets time and stutters\\
         Preserves order only};

\end{tikzpicture}
\caption{Relationship between metric-time, synchronous-time, and logical-time word models, and the forgetful morphisms $\ST$ and $\LT$ on a running example.}
\label{fig:word-models-summary}
\end{figure}

% The following paragraphs now refer to "word models" and "words"
\paragraph{From metric time to logical time.}
The map \(\LT\) drops time stamps but preserves labels and their order. It is the coarsest view that still distinguishes different event sequences.

\begin{lemma}[Logical-time projection \(\LT\): order-only view]
Let \(\taumt=\trace{(a_1,t_1),\dots,(a_{n},t_{n})} \) be a time word. There exists a unique logical word \(\tault=\LT(\taumt)\in\Sigma^{*}\) satisfying:
\begin{itemize}
  \item \textbf{Number of event preservation}: \( |\tault| = |\taumt| = n \).
  \item \textbf{Action occurrence preservation}: \( \forall a\in\Sigma, \#(a,\tault) = \#(a,\taumt) \).
  \item \textbf{Event order preservation}: If \(\taumt[k]\) precedes \(\taumt[\ell]\), then \(\tault[k]\) precedes \(\tault[\ell]\) in \(\tault\).
  \item \textbf{Projection compatibility}: \( \forall A\subseteq\Sigma, (\LT(\taumt)){\upharpoonright}A = \LT(\taumt{\upharpoonright}A) \).
  \item \textbf{Timing is forgotten}: \(\LT\) is invariant under strictly increasing retiming of timestamps.
\end{itemize}
\end{lemma}

\begin{proof}
\defn{Construction.}\;
Define \(\LT(\taumt):=\trace{(a_1),\,(a_2),\,\dots,\,(a_{n})}\). All properties follow from erasing time stamps while preserving labels and their order.
\end{proof}


\paragraph{From metric time to synchronous time.}
The map \(\ST\) aligns events to a global round clock by inserting ``\(-\)'' at rounds with no event; erasing ``\(-\)'' brings us back to logical time.

\begin{lemma}[Synchronous padding \(\ST\): round-indexed view]
Let \(\taumt\) be a metric-time word. There exists a unique synchronous word \(\taust=\ST(\taumt)\in(\Sigma\cup\{-\})^{*}\) such that, writing \(T:=\mathsf{last}(\taumt)\) (with \(T=0\) if \(\taumt=\emptytrace\)):
\begin{itemize}
  \item \textbf{Size / horizon relation}: If \(|\taumt|>0\), then \(|\ST(\taumt)| = T+1\) and \(\mathsf{pos}(\ST(\taumt))=\{1,\dots,T+1\}\).
  \item \textbf{Exact time-of-occurrence}: For any timestamp \(t \in \{0, \dots, T\}\), the synchronous event at index \(t+1\) is determined by:
  \[
  \ST(\taumt)[t+1] = 
  \begin{cases}
    \mathsf{lab}(\taumt,k) & \text{if } \exists k: \mathsf{ts}(\taumt,k) = t, \\
    - & \text{otherwise.}
  \end{cases}
  \]
  \item \textbf{Active rounds}: \(\mathsf{act}(\ST(\taumt)) = \{\, t+1 \mid t\in\mathsf{time}(\taumt)\,\}\).
 \item \textbf{Preservation of occurrences}: \(\forall a\in\Sigma, \#(a,\ST(\taumt)) = \#(a,\taumt)\).
  \item \textbf{Equivalence to logical time}: \(\erase_{-}(\ST(\taumt)) = \LT(\taumt)\).
\end{itemize}
\end{lemma}

\begin{proof}
\defn{Construction.}\;
If \(|\taumt|=0\), set \(\ST(\taumt):=\emptytrace\). Otherwise, let \(T:=\mathsf{last}(\taumt)\). 
We construct the word of length \(T+1\).
For every integer \(t \in \{0, \dots, T\}\) (representing the metric time), we define the event at index \(t+1\) as:
\[
\ST(\taumt)[t+1] :=
\begin{cases}
    a_k & \text{if } \exists k \text{ s.t. } t_k = t, \\
    - & \text{otherwise.}
\end{cases}
\]
Since metric timestamps are strictly increasing, there is at most one \(k\) for any \(t\), making this well-defined. All properties follow from this construction.
\end{proof}

\paragraph{On non-invertibility.}
Both \(\LT\) and \(\ST\) are \emph{many-to-one}. In particular, \(\LT\) is \emph{not} invertible. One cannot reconstruct a unique metric or synchronous word from logical time alone. Conversely, given \(\ST(\taumt)\) under the one-tick-per-unit assumption, the timestamps are recoverable from the indices of non-stutter symbols, up to the chosen time unit and the choice of time origin.

\paragraph{Takeaway.}
\(\LT\) and \(\ST\) are the canonical forgetful maps from metric time to, respectively, order-only and round-synchronous views. They preserve exactly the event properties listed above and discard the rest.

\subsection{Synchronization of Words}\label{operators}
In this subsection, we illustrate the complexity of synchronizing traces across different timing settings. We define three operators, adapted from standard formulations to fit our specific two-agent models denoted by indices 1 and 2, with alphabets $\Sigma_1$ and $\Sigma_2$. We cover:
(i) \emph{asynchrony} on logical-time words (\(\tault\)),
(ii) \emph{lockstep synchrony} on synchronous words (\(\taust\)),
and (iii) \emph{synchronous handshake} on synchronous words with an explicit set \(A\) of shared actions.

\subsubsection{Asynchrony Operator on Logical Time}
The asynchronous operator models purely interleaved joint behavior, generating \emph{all shuffles} that preserve each agentâ€™s local order. No global clock or rendezvous is assumed. To avoid accidental identification of simultaneous events, the global alphabet is taken as the \emph{disjoint union} $\Sigma=\Sigma_1\uplus\Sigma_2$, tagging each action with its agent of origin. This is the standard interleaving semantics of CCS and CSP.

\begin{definition}[Asynchronous interleaving on $\tault$]
  Let $\tault_1\in\Sigma_1^{*}$ and $\tault_2\in\Sigma_2^{*}$ be logical-time words. The \emph{asynchronous interleaving operator} 
  $
  \shuffle \;:\; \Sigma_1^{*}\times \Sigma_2^{*}\;\longrightarrow\; 2^{(\Sigma_1\uplus\Sigma_2)^{*}}
  $
  is defined recursively by:
  \[
  \tault_1 \shuffle \tault_2 \;=\;
  \begin{cases}
  \{\,\tault_2\,\}, & \tault_1=\emptytrace,\\[4pt]
  \{\,\tault_1\,\}, & \tault_2=\emptytrace,\\[4pt]
  \{\,a\cdot w \mid w\in (u\shuffle b\cdot v)\,\}
  \;\cup\;
  \{\,b\cdot w \mid w\in (a\cdot u \shuffle v)\,\},
  & \tault_1=a\cdot u,\ \tault_2=b\cdot v.
  \end{cases}
  \]
  Where $a\in\Sigma_1$, $b\in\Sigma_2$, $u \in \Sigma_1^*$ and $v \in \Sigma_2^*$.
\end{definition}

As a result, we have that every $w\in \tault_1 \shuffle \tault_2$ satisfies the projection property:
\( w{\upharpoonright}\Sigma_1=\tault_1 \) and \( w{\upharpoonright}\Sigma_2=\tault_2 \).

\begin{example}[Warehouse pick/scan, pure interleaving]
  Let \(\Sigma_1=\{\textsf{pick}\}\), \(\Sigma_2=\{\textsf{scan}\}\).
  System 1: \(\tault_1=\trace{(\textsf{pick}),(\textsf{pick})}\).
  System 2: \(\tault_2=\trace{(\textsf{scan})}\).
  Then \(\tault_1 \shuffle \tault_2\) contains three words:
  \( \trace{(\textsf{scan}),(\textsf{pick}),(\textsf{pick})} \),
  \( \trace{(\textsf{pick}),(\textsf{scan}),(\textsf{pick})} \), and
  \( \trace{(\textsf{pick}),(\textsf{pick}),(\textsf{scan})} \).
\end{example}

\subsubsection{Synchronous (Lockstep) Operator on Synchronous Time}

The \emph{lockstep} operator combines two synchronous words by aligning them round by round under a shared global clock. If the two words have different horizons, the shorter one is right-padded with the stutter symbol ``$-$'' so that both align on the common index set $\{1,\dots,T\}$, where $T=\max(T_1,T_2)$.

\begin{definition}[Lockstep zip on $\taust$]
  Let $\taust_1=\trace{(s_1),\dots,(s_{T_1})}$ and $\taust_2=\trace{(r_1),\dots,(r_{T_2})}$ be two synchronous words. Extend the shorter word with stutters ``$-$'' up to $T:=\max(T_1,T_2)$. The \emph{lockstep zip} operator is defined by:
  \[
  \taust_1 \parallel_{\mathrm{lock}} \taust_2
  \ :=\
  \trace{\, (s_1,r_1),\ (s_2,r_2),\ \dots,\ (s_T,r_T)\, }.
  \]
  Each position $t\in\{1,\dots,T\}$ of the result records the simultaneous round of both agents.
\end{definition}
The result is a synchronous word over the product alphabet $(\Sigma_1\cup\{-\})\times(\Sigma_2\cup\{-\})$.

\subsubsection{Synchronous Operator With Handshake Actions}

In many systems, certain actions can only be executed \emph{jointly} and must occur in \emph{the same round} for both agents. Let $A\subseteq \Sigma_1\cap\Sigma_2$ denote the set of \defn{handshake actions}. The idea is that if one agent performs a handshake action $a\in A$ at some round, then the other agent must also perform $a$ at that exact round. This principle, specified in synchronous CCS \cite{milner1983calculi}, requires handshake actions to be treated as simultaneous, mutually synchronized events.

\begin{definition}[Lockstep with handshakes on synchronous words]\label{def:lockstep-hs}
Let $A\subseteq \Sigma_1\cap\Sigma_2$ be a nonempty set of handshake actions. The lockstep with handshakes operator, written \( \taust_1 \parallel_{\mathrm{hs}}^{A} \taust_2 \), takes two synchronous words \(\taust_1\) and \(\taust_2\), extends them to the same length $T$, and applies the handshake constraint.
  
For the operator to be defined, the following condition must be true for every round \( t \in \{1, \dots, T\} \) and every \( a \in A \):
  \[
  (s_t=a\ \lor\ r_t=a)\;\Rightarrow\; (s_t=r_t=a).
  \]
If this condition is met, the result is a sequence of pairs from the product alphabet:
  \[
  \taust_1 \parallel_{\mathrm{hs}}^{A} \taust_2 \;=\; \trace{(s_1,r_1),\,(s_2,r_2),\,\dots,\,(s_T,r_T)}.
  \]
If the condition is not met, the operator is undefined, which means a deadlock or an invalid execution.
\end{definition}

The definition above gives a word over the raw product alphabet \( (\Sigma_1\cup\{-\})\times(\Sigma_2\cup\{-\}) \). However, it is often helpful to combine joint actions into single events to get a standard word structure. To do this, we need a richer alphabet that can show shared actions, private actions, and private actions happening at the same time.

\begin{definition}[Collapsed lockstep with handshakes]\label{def:collapsed-hs}
Let \( P_1 = \Sigma_1 \setminus A \) and \( P_2 = \Sigma_2 \setminus A \) be the sets of private actions. The collapsed alphabet \( \Sigma_{\parallel} \) is defined as:
  \[
      \Sigma_{\parallel} \;:=\; A \;\cup\; P_1^{(1)} \;\cup\; P_2^{(2)} \;\cup\; (P_1^{(1)} \times P_2^{(2)}),
  \]
Here, \( P_i^{(i)} \) means the private actions are labeled with the agent's ID.
  
The collapsed lockstep with handshakes is found by applying the function \(\mathsf{coll}_A\) to each pair \((s_t, r_t)\) in the raw lockstep word:
  \[
  \mathsf{coll}_A(s_t,r_t)=
  \begin{cases}
  a, & \text{if } s_t=r_t=a\in A,\\
  s_t^{(1)}, & \text{if } s_t\in P_1,\ r_t=-,\\
  r_t^{(2)}, & \text{if } r_t\in P_2,\ s_t=-,\\
  (s_t^{(1)},r_t^{(2)}), & \text{if } s_t\in P_1,\ r_t\in P_2,\\
  -, & \text{if } s_t=r_t=-.
  \end{cases}
  \]
\end{definition}

\begin{example}[Handover as handshake, failures and successes]
  Let \(\Sigma_1=\{\textsf{pick},\textsf{handover}\}\), \(\Sigma_2=\{\textsf{scan},\textsf{handover}\}\), and \(A=\{\textsf{handover}\}\).
  The private sets are \( P_1=\{\textsf{pick}\} \) and \( P_2=\{\textsf{scan}\} \).
  \begin{itemize}
      \item \emph{Success (aligned handshake).}
      \(\taust_1=\trace{(\textsf{pick}),-,\textsf{handover}}\), \(\taust_2=\trace{-,\textsf{scan},\textsf{handover}}\).
      The collapse gives \(\trace{(\textsf{pick}^{(1)}),\ (\textsf{scan}^{(2)}),\ (\textsf{handover})}\).
  
      \item \emph{Failure (mismatched handshake).}
      \(\taust_1=\trace{-,\textsf{handover},-}\), \(\taust_2=\trace{\textsf{handover},-,-}\).
      The constraint fails at \( t=1 \) when Agent 2 is ready but Agent 1 is not, and at \( t=2 \) when the situation is reversed.
      In this case, the operator is undefined.
      
      \item \emph{Private simultaneous actions (non-handshake).}
      \(\taust_1=\trace{-,\textsf{pick},-}\), \(\taust_2=\trace{-,\textsf{scan},-}\).
      At round \( t=2 \) (metric time 1), \( s_2=\textsf{pick} \) is in $P_1$ and \( r_2=\textsf{scan} \) is in $P_2$.\\
      The collapsed result is \(\trace{-,\ (\textsf{pick}^{(1)}, \textsf{scan}^{(2)}),\ -}\).
  \end{itemize}
  \end{example}

  To sum up, this section presented three models for discrete-action words and explained how they relate to each other, as summarized in \ref{tab:word-models-summary}. We started by setting up an abstract algebraic framework for both finite and infinite words. Then, we described three specific word types: (i) logical-time words, which only keep the order of actions, (ii) metric-time words, which capture better timing order using strictly increasing timestamps, and (iii) synchronous-time words, which organize observations by rounds and show inactivity through stuttering. We linked these models using the forgetful morphisms $\LT$ and $\ST$, which let us view a metric-time execution in (i) terms of order only, or (ii) as round-synchronous. Next, we introduced three ways for two agents to synchronize: asynchronous interleaving $\shuffle$ for logical time, lockstep zip $\parallel_{\mathrm{lock}}$ for synchronous time, and lockstep with handshakes $\parallel_{\mathrm{hs}}^{A}$, plus a version that combines everything into a single word. These tools form the basis for interpreting multi-agent contracts and for defining how monitoring and verdicts work under different synchrony settings.
\begin{table}[h!]
  \centering
  \caption{Summary of discrete-action word models, morphisms, and synchronization operators.}
  \label{tab:word-models-summary}
  \renewcommand{\arraystretch}{1.3}
  \begin{tabular}{@{}l c l l@{}}
  \toprule
  \textbf{Model / Concept} & \textbf{Symbol} & \textbf{Domain} & \textbf{Key Characteristics} \\
  \midrule
  \multicolumn{4}{l}{\textit{Word Models}} \\
  Logical-Time & $\tault$ & $\Sigma^*$ & Order only; no timing info. \\
  Metric-Timed & $\taumt$ & $(\Sigma \times \mathbb{N})^*$ & Precise timestamps; quantitative timing. \\
  Synchronous-Time & $\taust$ & $(\Sigma \cup \{-\})^*$ & Round-based; explicit stutters ($-$). \\
  \midrule
  \multicolumn{4}{l}{\textit{Canonical Morphisms}} \\
  Logical Projection & $\LT$ & $\taumt \to \tault$ & Forgets timestamps, preserves order. \\
  Synchronous Padding & $\ST$ & $\taumt \to \taust$ & Aligns events to rounds, inserts $-$. \\
  \midrule
  \multicolumn{4}{l}{\textit{Synchronization Operators}} \\
  Async. Interleaving & $\shuffle$ & $\tault \times \tault$ & All order-preserving shuffles (interleaving). \\
  Lockstep Zip & $\parallel_{\mathrm{lock}}$ & $\taust \times \taust$ & Aligns rounds strictly. \\
  Handshake & $\parallel_{\mathrm{hs}}^{A}$ & $\taust \times \taust$ & Synchronizes shared $A$, interleaves private. \\
  \bottomrule
  \end{tabular}
  \end{table}