\section{Discrete Actions Trace Models}
In this dissertation, we distinguish between a \emph{trace} and a \emph{word} based on their temporal perspective. We use the term \emph{trace} to denote a data structure representing recorded past behavior, whereas a \emph{word} refers to the hypothetical behavior of a system or agent. Structurally, however, both data structures are identical within this dissertation. 

While many control-theoretic and physical models rely on continuous signals or state-based evolutions that record variable values over time, we focus here on \emph{discrete action} models. This choice is motivated by our interest in ought-to-do normative specifications, which naturally pertain to actions performed rather than states held. In this context, a trace is a sequence of discrete events representing observations of ``what happened'', rather than a continuous flow of ``what holds true''. These traces serve as the fundamental data structures for the logics defined in subsequent chapters. 

We begin by establishing the definitions for three action models of behavior and the canonical morphisms between them. Subsequently, we study how to synchronize two traces of the same type.

\subsection{Abstract Notions and Properties of Action Traces}
For the remainder of this dissertation, let \(\Sigma\) denote a non-empty set of discrete \emph{actions}. We define three distinct types of discrete action traces which are distinguished by their \emph{timing models}.

Traces are sequences of events. An \emph{event} in our discrete setting, denoted by $\event$, is a data structure derived from $\Sigma$. We denote the set of \emph{finite traces} by $\event^\star$, the set of \emph{infinite traces} by $\event^\omega$, and the set of all traces (finite or infinite) by $\event^\infty := \event^\star \cup \event^\omega$.

Despite the differences regarding timing models, all trace types share the fundamental algebraic structure of a sequence. To avoid redundancy in subsequent definitions, we establish here the properties common to any finite trace \( w \) over a concrete event data structure \( E \) (where \( E \) could simply be \(\Sigma\)).

The notation \( w = \trace{(e_0),\,(e_1),\,\dots,\,(e_{n-1})} \in E^* \) symbolizes a finite trace $w$ defined by a sequence of events $e_i$ from \( E \). We define the following canonical notions:

\begin{itemize}
    \item \defn{Size}: The length of the trace corresponds to the number of events forming it and is denoted by \( |w| := n \).
    \item \defn{Positions}: The set of valid indices is defined as \( \mathsf{pos}(w) := \{0, 1, \dots, n-1\} \).
    \item \defn{Indexing}: For any \( k \in \mathsf{pos}(w) \), we denote the event at index \(k\) by \( w[k] := e_k \).
    \item \defn{Prefix}: The prefix of length \( k+1 \) is denoted by $ w[0,k]$ or $ w_k $ and is defined as $\trace{(e_0), \dots, (e_k)} $ for $ 0 \le k < n $.
    \item \defn{Suffix}: The suffix starting from index \( k \) is denoted by \( w^k := \trace{(e_{k}),\dots (e_{n-1})} \) for \( 0 \le k < n \).
    \item \defn{Empty trace}: We write \( \emptytrace \) for the empty sequence, where \( |\emptytrace| = 0 \).
\end{itemize}

\noindent\textbf{Generic Projection.}
For a subset of events \( S \subseteq E \), the projection \( w{\upharpoonright}S \) is the subsequence obtained by deleting all events \( e_k \) such that \( e_k \notin S \).


\subsection{Logical-Time Words}

Logical-time traces capture \emph{order only}, abstracting away any notion of specific timing. They are the staple semantic objects in interleaving models of process calculi (such as CCS\cite{Milner89} and CSP\cite{hoare1978communicating}) and  Mazurkiewicz refers to them as strings in \cite{diekert1995book}.

\begin{definition}[Logical-time word, notation \(\tault\)]
  A (finite) logical-time word over an alphabet \(\Sigma\) is a sequence:
  \[
  \tault\;=\; \trace{(a_0),\,(a_1),\,\dots,\,(a_{n-1})}\ \in\ \Sigma^{*},
  \]
  where \(a_k\in\Sigma\) for all \(k\).
\end{definition}

We now introduce basic operators on logical-time words. We start with concatenation, then define a counting function for action occurrences. Both notions will be reused when relating logical-time words to the richer time models introduced next.


%
\begin{definition}[Concatenation of logical-time words]
  Let $\tault_1=\trace{(a_0),\dots,(a_{n-1})}\in\Sigma^{*}$ and
  $\tault_2=\trace{(b_0),\dots,(b_{m-1})}\in\Sigma^{*}$.
  Their \defn{concatenation}, written $\tault_1\concat\tault_2$, is the logical-time word in $\Sigma^{*}$ defined by
  \[
    \tault_1 \concat \tault_2
    \;:=\;
    \trace{(a_0),\dots,(a_{n-1}),(b_0),\dots,(b_{m-1})}.
  \]
  \[
    \tault_1 \concat \emptytrace
    \;:=\;
    \tault_1.
  \]
  \[
    \emptytrace \concat \tault_2
    \;:=\;
    \tault_2.
  \]
\end{definition}


Additionally, the following holds for concatenation of any two traces:
\begin{itemize}
  \item \defn{Length}: $\lvert\tault_1\cdot\tault_2\rvert = \lvert\tault_1\rvert + \lvert\tault_2\rvert$.
  \item \defn{Indexing}: for $k\in\mathsf{pos}(\tault_1\cdot\tault_2)$,
  \[
    (\tault_1\concat\tault_2)[k] :=
    \begin{cases}
      \tault_1[k], & \text{if } 0\le k < \lvert\tault_1\rvert,\\
      \tault_2[k-\lvert\tault_1\rvert], & \text{if } \lvert\tault_1\rvert \le k < \lvert\tault_1\rvert+\lvert\tault_2\rvert.
    \end{cases}
  \]
\end{itemize}

The next operator abstracts from positions and records how often a given action occurs in a word.

\begin{definition}[Counting function on logical-time words]
  Let $a\in\Sigma$ and let $\tault=\trace{(a_0),\dots,(a_{n-1})}\in\Sigma^{*}$ be a logical-time word.
  The \defn{count} of $a$ in $\tault$, written $\#(a,\tault)$, is defined by
  \[
    \#(a,\tault)
    \;:=\;
    \big|\{\, k\in\mathsf{pos}(\tault) \mid \tault[k]=a \,\}\big|.
  \]
\end{definition}



\begin{example}[Logical-time operators]
  Let \( \Sigma=\{\textsf{pick},\textsf{handover}\} \).
  Consider the trace:
  \[
  \tault=\trace{(\textsf{pick}),(\textsf{handover})}.
  \]
  \emph{Size and Indexing:} \(|\tault|=2\), \(\tault[0]=\textsf{pick}\).\\
  \emph{Counts:} \(\#({\textsf{handover}},\tault)=1\).\\
  \emph{Projection:} with \(A=\{\textsf{handover}\}\), \(\tault{\upharpoonright}A=\trace{(\textsf{handover})}\).\\
  \emph{Concatenation:} \(\tault\concat\trace{(\textsf{pick})} = \trace{(\textsf{pick}),(\textsf{handover}),(\textsf{pick})}\).
\end{example}


\subsection{Metric-Timed Traces}
\noindent\textbf{Context.}
Metric-timed traces extend the previous model by recording \emph{which} action occurs and \emph{when} it occurs. They are defined in research works on timed automata \cite{DBLP:journals/tcs/AlurD94}.

\begin{definition}[Finite \timedwords of actions] \label{timedwords} 
    A \emph{finite \timedword} $\tau$ is defined as a finite sequence of timed events, $\tau \in ({\timedevents})^*$.
     \[\tau := \trace{(a_0,t_0), (a_1,t_1), \ \dots, \ (a_{n-1},t_{n-1}) }\]
     with \(a_k\in\Sigma\), \(t_k\in\mathbb{N}\), and strictly increasing timestamps \(0\le t_0<\cdots<t_{n-1}\).
\end{definition}

\begin{definition}[Auxiliary operators on metric-timed traces]
  Let $\taumt=\trace{(a_0,t_0),\dots,(a_{n-1},t_{n-1})}\in(\Sigma\times\mathbb{N})^{*}$.
  \begin{itemize}
    \item The \defn{label} and \defn{timestamp} projections of the $k$th event are defined by
    \[
      \mathsf{lab}(\taumt,k):=a_k,\qquad \mathsf{ts}(\taumt,k):=t_k\qquad (k\in\mathsf{pos}(\taumt)).
    \]
    \item The \defn{time set} of $\taumt$ is
    \[
      \mathsf{time}(\taumt):=\{\, t_k \mid k\in\mathsf{pos}(\taumt)\,\}.
    \]
    \item The \defn{last time point} is defined by
    \[
      \mathsf{last}(\taumt):=
      \begin{cases}
        t_{n-1}, & \text{if } n>0,\\
        0, & \text{if } n=0.
      \end{cases}
    \]
    \item The \defn{time span} is
    \[
      \mathsf{span}(\taumt):=
      \begin{cases}
        t_{n-1}-t_0, & \text{if } n>0,\\
        0, & \text{if } n=0.
      \end{cases}
    \]
    \item For $a\in\Sigma$, the \defn{count} of $a$ in $\taumt$ is
    \[
      \#(a,\taumt):=\big|\{\, k\in\mathsf{pos}(\taumt) \mid \mathsf{lab}(\taumt,k)=a \,\}\big|.
    \]
  \end{itemize}
\end{definition}

    We refer by $\domtr$ to the domain of finite \timedwords. Unlike the logical-time setting, where one can only compare events by their order, metric-timed traces support quantitative reasoning about timing. In particular, the operators on logical-time words, such as concatenation and counting, do not determine any numerical distance between events. The next two definitions exploit the additional timestamp component: $\Delta$ measures the elapsed time between two positions, while $\rho$ looks up which action, if any, occurs at a given absolute time point.


    \begin{definition}[Timed distance between two events]
        Let $\taumt=\trace{(a_0,t_0),\dots,(a_{n-1},t_{n-1})}\in(\Sigma\times\mathbb{N})^{*}$ be a metric-timed trace.
        For any two indices $i,j\in\mathsf{pos}(\taumt)$ with $i<j$, the \defn{timed distance} between event $i$ and event $j$ is
        \[
          \Delta(\taumt,(i,j))\;:=\; t_j-t_i.
        \]
      \end{definition}
    
     \begin{definition}[Action Lookup Function]\label{defrho}
     
     The \emph{action lookup function} $\rho : \domtr \times \mathbb{N} \to \Sigma \cup \{ \Undef \}$ returns the action performed at absolute time $t$ in a metric-timed trace; if no event occurs at time $t$, it returns the special symbol $\Undef$:
        \[
        \rho\big(\trace{(a_0,t_0), \dots, (a_{n-1},t_{n-1})}, t\big) := 
        \begin{cases} 		
            a_i & \text{if  } t_i=t \text{ for some } i \in \{0,\dots,n-1\},\\
            \Undef & \text{otherwise.}
        \end{cases}
        \]
    \end{definition}


\noindent\textbf{Basic operators and short hands.}
For \(A\subseteq\Sigma\), projection \( \taumt{\upharpoonright}A\in(A\times\mathbb{N})^{*} \) keeps exactly the pairs \((a,t)\) where \(a\in A\).\\
Prefixes can be defined by \emph{length} \( \taumt[0,k] \), or by \emph{time} \( \taumt{\upharpoonright}\{t\le T\} \) (shorthand: \( \taumt\{t\le T\}\)).\\


\begin{example}[Metric-timed operators]
  Consider an alphabet $\Sigma=\{\textsf{badge\_tapped},\textsf{door\_open}\}$.
  \[
  \taumt=\trace{(\textsf{badge\_tapped},1),(\textsf{door\_open},3)}.
  \]
  \emph{Size and Indexing:} \(|\taumt|=2\), \(\taumt[0]=(\textsf{badge\_tapped},1)\).\\
  \emph{Lookup action:} $\rho(\taumt,1)= badge\_tapped$ and $\rho(\taumt,2)= \text{undefined}$.\\
  \emph{Time properties:} \(\mathsf{time}(\taumt)=\{1,3\}\), \(\mathsf{span}(\taumt)=2\).\\
  \emph{Time-prefix:} \(\taumt\{t\le 2\}=\trace{(\textsf{badge\_tapped},1)}\).\\
  \emph{Timed distance}: the distance between event $0$ and event $1$ is $\Delta(\taumt,(0,1))=3-1=2$.
\end{example}

Metric-timed traces provide \emph{precise} quantitative information, in particular the exact timed distance between any two events in the same trace, captured by differences of their timestamps.
For this model, concatenation is not defined for arbitrary pairs of traces: if two traces both contain an event at the same time point, then concatenating them would violate the requirement of strictly increasing timestamps. Hence, concatenation is only defined when the timestamp sets are disjoint and the last time point of the first trace is strictly smaller than the first time point of the second trace.

\subsection{Synchronous-Time Traces}
Synchronous-time traces assume a \emph{single global logical clock} (the \emph{synchronous hypothesis}). Each tick represents an instantaneous round in which components react simultaneously; the absence of an action at a tick is explicit. This is the semantic backbone of synchronous languages such as Esterel\cite{berry1984esterel}, Lustre\cite{Halbwachs93}, and LoLa\cite{d2005lola}.

\begin{definition}[Synchronous-time trace, notation \(\taust\)]
  Fix an alphabet \(\Sigma\) and a stutter symbol ``\(-\)'' with \( -\notin\Sigma \).
  A (finite) \emph{synchronous-time trace} is a finite sequence of events over $(\Sigma\cup\{-\})$
  \[
  \taust \;=\; \trace{(s_0),\,(s_1),\,\dots,\,(s_T)} \ \in\ (\Sigma\cup\{-\})^{*},
  \]
  where \(s_t\in\Sigma\cup\{-\}\) represents the observation at round \(t\) and \(T\) is called the \defn{horizon}.
\end{definition}

Synchronous-time traces sit between logical-time words and metric-timed traces. Like logical time, they are discrete sequences, but they come with an explicit global round index that plays the role of a coarse clock. Like metric time, one can talk about \emph{when} something happens, but only in terms of round numbers rather than absolute timestamps. The crucial difference to both earlier models is that the \emph{absence} of an action is itself observable, represented by the stutter symbol ``$-$''.


  

\noindent\textbf{Basic operators and short hands.}
For \(A\subseteq\Sigma\):
\begin{itemize}
  \item \defn{Stutter-preserving projection} \( \taust{\upharpoonright}A \in (A\cup\{-\})^{*} \) keeps letters in \(A\) and all ``\(-\)''.
  \item \defn{Logical (stutter-erasing) projection} \( \erase_{-}(\taust{\upharpoonright}A)\in A^{*} \) drops all ``\(-\)''.
\end{itemize}
For $a\in\Sigma$, the \defn{count} of $a$ in $\taust$ is $\#(a,\taust):=\big|\{\, t\in\mathsf{pos}(\taust)\mid \taust[t]=a \,\}\big|$, and the set of \defn{active rounds} is $\mathsf{act}(\taust):=\{\, t\in\mathsf{pos}(\taust)\mid \taust[t]\neq - \,\}$.
The round-prefix is denoted \( \taust[0,r]:=\trace{(s_0),\dots,(s_r)} \) for \(0\le r\le T\).

\begin{example}[controller at 1\,Hz — illustrating all operators]
    Consider HVAC (Heating, Ventilation, and Air Conditioning) actuator (1) and a security Sensor (2), both controlled by a synchronous controller:
    \[
    \Sigma_1=\{\textsf{heat\_on}\},\qquad 
    \Sigma_2=\{\textsf{door\_lock}\}.
    \]
    In one episode, we record
    \[
    \taust_1=\trace{(-),(-),(\textsf{heat\_on})},\qquad
    \taust_2=\trace{(-),(\textsf{door\_lock}),(-)}.
    \]
    
    \noindent\emph{Size, positions, indexing:}\\
    \(|\taust_1|=|\taust_2|=3\) with horizon \(T=2\),  
    \(\mathsf{pos}(\taust_1)=\{0,1,2\}\),  
    \(\taust_1[2]=\textsf{heat\_on}\).
    
    \noindent\emph{Counts and active rounds:}\\
    \(\#(\textsf{heat\_on},\taust_1)=1\),  
    \(\mathsf{act}(\taust_1)=\{2\}\).
    
    \noindent\emph{Stutter-preserving projection:}\\
    with \(A=\emptyset\),  
    \(\taust_1{\upharpoonright}A=\trace{(-),(-),(-)}\).
    
    \noindent\emph{Logical (stutter-erasing) projection:}\\
    \(\erase_{-}(\taust_1{\upharpoonright}A)=\emptytrace\),  
    while \(\erase_{-}(\taust_1)=\trace{(\textsf{heat\_on})}\).
    
    \noindent\emph{Round-prefix:}\\
    \(\taust_2[0,1]=\trace{(-),(\textsf{door\_lock})}\).
    
    \end{example}
  

\subsection{Connecting the Three Action Trace Models}
The objective of this subsection is to connect the three action-centric trace models introduced above. Given a metric-timed word \(\taumt\), we introduce two canonical morphisms that deliberately discard part of the information: the \emph{logical-time projection} \(\LT\), which erases time stamps while preserving the order of events, and the \emph{synchronous padding} \(\ST\), which aligns events to a global round clock by inserting explicit stutter symbols ``\(-\)''. We set up the clock frequency of the synchronous-time trace to correspond to a single unit of metric time.

\paragraph{From metric time to logical time.}
The map \(\LT\) drops time stamps but preserves labels and their order. It is the coarsest view that still distinguishes different event sequences.

\begin{lemma}[Logical-time projection \(\LT\): order-only view]
Let \(\taumt=\trace{(a_0,t_0),\dots,(a_{n-1},t_{n-1})} \) be a timed word. There exists a unique logical word \(\tault=\LT(\taumt)\in\Sigma^{*}\) satisfying:
\begin{itemize}
  \item \textbf{Number of event preservation}: \( |\tault| = |\taumt| = n \).
  \item \textbf{Action occurrence preservation}: \( \forall a\in\Sigma, \#(a,\tault) = \#(a,\taumt) \).
  \item \textbf{Event order preservation}: If \(\taumt[k]\) precedes \(\taumt[\ell]\), then \(\tault[k]\) precedes \(\tault[\ell]\) in \(\tault\).
  \item \textbf{Projection compatibility}: \( \forall A\subseteq\Sigma, (\LT(\taumt)){\upharpoonright}A = \LT(\taumt{\upharpoonright}A) \).
  \item \textbf{Timing is forgotten}: \(\LT\) is invariant under strictly increasing retiming of timestamps.
\end{itemize}
\end{lemma}

\begin{proof}
\defn{Construction.}\;
Define \(\LT(\taumt):=\trace{(a_0),\,(a_1),\,\dots,\,(a_{n-1})}\). All properties follow from erasing time stamps while preserving labels and their order.
\end{proof}

\paragraph{From metric time to synchronous time.}
The map \(\ST\) aligns events to a global round clock by inserting ``\(-\)'' at rounds with no event; erasing ``\(-\)'' brings us back to logical time.

\begin{lemma}[Synchronous padding \(\ST\): round-indexed view]
Let \(\taumt\) be a metric-timed word, and assume one synchronous tick per metric unit. There exists a unique synchronous word \(\taust=\ST(\taumt)\in(\Sigma\cup\{-\})^{*}\) such that, writing \(T:=\mathsf{last}(\taumt)\) when \(|\taumt|>0\):
\begin{itemize}
  \item \textbf{Size / horizon relation}: If \(|\taumt|>0\), \(|\ST(\taumt)| = T+1\) and \(\mathsf{pos}(\ST(\taumt))=\{0,\dots,T\}\).
  \item \textbf{Exact time-of-occurrence}: For any \(t\), \(\ST(\taumt)[t] = \mathsf{lab}(\taumt,k)\) if \(t=\mathsf{ts}(\taumt,k)\), otherwise it is \(-\).
  \item \textbf{Active rounds}: \(\mathsf{act}(\ST(\taumt)) = \mathsf{time}(\taumt)\).
  \item \textbf{Preservation of occurrences}: \(\forall a\in\Sigma, \#(a,\ST(\taumt)) = \#(a,\taumt)\).
  \item \textbf{Equivalence to logical time}: \(\erase_{-}(\ST(\taumt)) = \LT(\taumt)\).
\end{itemize}
\end{lemma}

\begin{proof}
\defn{Construction.}\;
If \(|\taumt|=0\), set \(\ST(\taumt):=\emptytrace\). Otherwise let \(T:=\mathsf{last}(\taumt)\). For every \(t\in\{0,\dots,T\}\), define \(\ST(\taumt)[t]\) to be \(a_k\) if \(t=t_k\) for some \(k\), and \(-\) otherwise. Each property follows directly from this definition and the strict monotonicity of timestamps.
\end{proof}

\paragraph{On non-invertibility.}
Both \(\LT\) and \(\ST\) are \emph{many-to-one}. In particular, \(\LT\) is \emph{not} invertible. One cannot reconstruct a unique metric or synchronous trace from logical time alone. Conversely, given \(\ST(\taumt)\) under the one-tick-per-unit assumption, the metric timestamps are readable as the indices of non-stutter symbols.

\paragraph{Takeaway.}
\(\LT\) and \(\ST\) are the canonical forgetful maps from metric time to, respectively, order-only and round-synchronous views. They preserve exactly the event properties listed above and discard the rest.

\subsection{Synchronization of Traces}\label{operators}

\noindent\textbf{Design rationale.}
Having defined traces for generic systems, we now turn to the interaction between systems. Different communities fix different \emph{time assumptions}, which determine how local traces are aligned. Process calculi (CCS/CSP) adopt \emph{no global clock} and reason over order only, yielding \emph{pure interleaving} and optionally \emph{shared action handshakes}. Synchronous languages assume a \emph{single global round clock} (lockstep). Timed automata use \emph{absolute timestamps} and synchronize at equal times on shared actions.

In this section, we instantiate three operators consistent with our models for two specific agents, denoted by indices 1 and 2, with alphabets $\Sigma_1$ and $\Sigma_2$. We cover:
(i) \emph{asynchrony} on logical-time words (\(\tault\)),
(ii) \emph{lockstep synchrony} on synchronous words (\(\taust\)),
and (iii) \emph{synchronous handshake} on synchronous words with an explicit set \(A\) of shared actions.

\subsubsection{Asynchrony Operator on Logical Time}
The asynchronous operator models purely interleaved joint behavior, generating \emph{all shuffles} that preserve each agent’s local order. No global clock or rendezvous is assumed. To avoid accidental identification of simultaneous events, the global alphabet is taken as the \emph{disjoint union} $\Sigma=\Sigma_1\uplus\Sigma_2$, tagging each action with its agent of origin. This is the standard interleaving semantics of CCS and CSP.

\begin{definition}[Asynchronous interleaving on $\tault$]
  Let $\tault_1\in\Sigma_1^{*}$ and $\tault_2\in\Sigma_2^{*}$ be logical-time words. The \emph{asynchronous interleaving operator} 
  $
  \shuffle \;:\; \Sigma_1^{*}\times \Sigma_2^{*}\;\longrightarrow\; 2^{(\Sigma_1\uplus\Sigma_2)^{*}}
  $
  is defined recursively by:
  \[
  \tault_1 \shuffle \tault_2 \;=\;
  \begin{cases}
  \{\,\tault_2\,\}, & \tault_1=\emptytrace,\\[4pt]
  \{\,\tault_1\,\}, & \tault_2=\emptytrace,\\[4pt]
  \{\,a\cdot w \mid w\in (u\shuffle b\cdot v)\,\}
  \;\cup\;
  \{\,b\cdot w \mid w\in (a\cdot u \shuffle v)\,\},
  & \tault_1=a\cdot u,\ \tault_2=b\cdot v.
  \end{cases}
  \]
  where $a\in\Sigma_1$, $b\in\Sigma_2$, $u \in \Sigma_1^*$ and $v \in \Sigma_2^*$.
\end{definition}

As a result, we have that every $w\in \tault_1 \shuffle \tault_2$ satisfies the projection property:
\( w{\upharpoonright}\Sigma_1=\tault_1 \) and \( w{\upharpoonright}\Sigma_2=\tault_2 \).

\begin{example}[Warehouse pick/scan, pure interleaving]
  Let \(\Sigma_1=\{\textsf{pick}\}\), \(\Sigma_2=\{\textsf{scan}\}\).
  System 1: \(\tault_1=\trace{(\textsf{pick}),(\textsf{pick})}\).
  System 2: \(\tault_2=\trace{(\textsf{scan})}\).
  Then \(\tault_1 \shuffle \tault_2\) contains three traces:
  \( \trace{(\textsf{scan}),(\textsf{pick}),(\textsf{pick})} \),
  \( \trace{(\textsf{pick}),(\textsf{scan}),(\textsf{pick})} \), and
  \( \trace{(\textsf{pick}),(\textsf{pick}),(\textsf{scan})} \).
\end{example}

\subsubsection{Synchronous (Lockstep) Operator on Synchronous Time}

The \emph{lockstep} operator combines two synchronous traces by aligning them round by round under a shared global clock. If the two words have different horizons, the shorter one is right-padded with the stutter symbol ``$-$'' so that both align on the common index set $[0,T]$, where $T=\max(T_1,T_2)$.

\begin{definition}[Lockstep zip on $\taust$]
  Let $\taust_1=\trace{(s_0),\dots,(s_{T_1})}$ and $\taust_2=\trace{(r_0),\dots,(r_{T_2})}$ be two synchronous words. Extend the shorter word with stutters ``$-$'' up to $T:=\max(T_1,T_2)$. The \emph{lockstep zip} operator is defined by:
  \[
  \taust_1 \parallel_{\mathrm{lock}} \taust_2
  \ :=\
  \trace{\, (s_0,r_0),\ (s_1,r_1),\ \dots,\ (s_T,r_T)\, }.
  \]
  Each position $t$ of the result records the simultaneous round of both agents.
\end{definition}

\subsubsection{Synchronous Operator With Handshake Actions}

In many systems, certain actions can only be executed \emph{jointly} and must occur in \emph{the same round} for both agents. Let $A\subseteq \Sigma_1\cap\Sigma_2$ denote the set of \defn{handshake actions}. The idea is that if one agent performs a handshake action $a\in A$ at some round, then the other agent must also perform $a$ at that exact round. This principle, known from the semantics of Communicating Sequential Processes (CSP), requires handshake actions to be treated as simultaneous, mutually synchronized events.

\begin{definition}[Lockstep with handshakes on synchronous words]
  Let $A\subseteq \Sigma_1\cap\Sigma_2$ be a nonempty set of \emph{handshake actions}.
  The operator \emph{lockstep with handshakes}, written
  \(
  \taust_1 \parallel_{\mathrm{hs}}^{A} \taust_2,
  \)
  takes two synchronous words \(\taust_1\) and \(\taust_2\), pads them to the common horizon \(T\), and returns
  \[
  \taust_1 \parallel_{\mathrm{hs}}^{A} \taust_2
  \;=\;
  \trace{(s_0,r_0),\,(s_1,r_1),\,\dots,\,(s_T,r_T)}
  \]
  if and only if the following handshake constraint holds:
  \[
  \forall t\in\{0,\dots,T\},\ \forall a\in A:\quad
  \big(s_t=a\ \lor\ r_t=a\big)\;\Rightarrow\; (s_t=r_t=a).
  \]
  Otherwise, the operator is \emph{undefined}. Every handshake action must be executed simultaneously by both agents, whereas private actions and stuttering symbols ``\(-\)'' may occur independently.
\end{definition}

\begin{definition}[Collapsed lockstep with handshakes]
  For the same setting as above, define \(\Sigma:=\Sigma_1^{(1)}\uplus\Sigma_2^{(2)}\uplus A\). The \emph{collapsed lockstep with handshakes} is obtained by applying the morphism \(\mathsf{coll}_A\) defined round-by-round as:
  \[
  \mathsf{coll}_A(s_t,r_t)=
  \begin{cases}
  a, & \text{if } s_t=r_t=a\in A,\\
  s_t^{(1)}, & \text{if } s_t\in\Sigma_1\setminus A,\ r_t=-,\\
  r_t^{(2)}, & \text{if } r_t\in\Sigma_2\setminus A,\ s_t=-,\\
  (s_t^{(1)},r_t^{(2)}), & \text{if } s_t\in\Sigma_1\setminus A,\ r_t\in\Sigma_2\setminus A,\\
  -, & \text{if } s_t=r_t=-.
  \end{cases}
  \]
  Thus, joint actions from $A$ collapse to a single shared letter, while private actions remain tagged by their originating agent.
\end{definition}

\begin{example}[Handover as handshake, failures and successes]
  Let \(\Sigma_1=\{\textsf{pick},\textsf{handover}\}\), \(\Sigma_2=\{\textsf{scan},\textsf{handover}\}\), and \(A=\{\textsf{handover}\}\).
  \begin{itemize}
    \item \emph{Success (aligned handshake).}
    \(\taust_1=\trace{(\textsf{pick}),- ,\textsf{handover}}\), \(\taust_2=\trace{- ,\textsf{scan},\textsf{handover}}\).
    The collapse yields \(\trace{(\textsf{pick}^{(1)}),\ (\textsf{scan}^{(2)}),\ (\textsf{handover})}\).
    \item \emph{Failure (mismatched handshake).}
    \(\taust_1=\trace{- ,\textsf{handover},-}\), \(\taust_2=\trace{\textsf{handover},- ,-}\).
    The constraint is violated, so the operator is \emph{undefined}.
    \item \emph{Private simultaneous actions (non-handshake).}
    \(\taust_1=\trace{- ,\textsf{pick},-}\), \(\taust_2=\trace{- ,\textsf{scan},-}\).
    Since neither label is in \(A\), the pair occurs at the same round.
  \end{itemize}
\end{example}

In summary, we analyzed three synchronization operators, each situated in the semantic model where it is most naturally defined. The asynchronous operator $\shuffle$ captures all globally feasible interleavings that respect local order. By contrast, the lockstep operator~$\parallel_{\mathrm{lock}}$ assumes a shared global clock. Finally, $\parallel_{\mathrm{hs}}^{A}$ strengthens the lockstep view by enforcing handshake constraints on the designated set~$A$ of joint actions. These operators represent the state of the art in computer science for defining the semantics of modal, temporal, and strategic operators over multi-agent executions under different synchrony assumptions.