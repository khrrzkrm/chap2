\subsection{Forward-Looking Blame Semantics}
The tight semantics of \cDL identify when a contract is satisfied or violated, but do not explain \emph{who} caused a violation.  
To attribute responsibility, we refine the violation verdicts based on which party failed to meet the relevant normative requirement.  
We break down tight and post violations into those caused by agent 1, those caused by agent 2, those caused jointly by both, and those where neither party is responsible (blameless cases).  
Formally, we introduce tight violation verdicts
\[
\bottp{\{1\}},\quad \bottp{\{2\}},\quad \bottp{\{1,2\}},\quad \bottp{\emptyset},
\]
and their post-violation counterparts
\[
\botpp{\{1\}},\quad \botpp{\{2\}},\quad \botpp{\{1,2\}},\quad \botpp{\emptyset}.
\]
By replacing the undifferentiated violation verdicts of the five-valued semantics with these responsibility-aware variants, and keeping the three non-violating verdicts \(\mathsf{?},\topt,\topp\), we obtain the forward-looking blame eleven-valued semantics
\[
  \mathbb{V}_{11} = \{\mathsf{?},\topt,\topp\} \cup \{\bot^{t}_{S},\bot^{p}_{S} \mid S\subseteq \{1,2\}\}.
  \]
This refined judgement structure allows the monitors constructed in the next section to pinpoint the agents responsible for each contractual breach.


\subsubsection*{Blame Rules for Literals}
\begin{definition}[Blame assignment for literals]
Let $p\in\{1,2\}$ be the main subject of the norm and let $\barp$ denote the other party.
Let $\trace{A}$ be a single-step word with $A\in\Gamma$. We write $a^{(i)}\in A$ when party $i$ attempts $a$ in this step.

\paragraph{Obligation \(\obl[p]{a}\).}
Violation occurs if and only if the joint execution does not happen. Blame principle:
if the subject does not attempt, blame the subject; otherwise, blame the other party for not cooperating:
\[
\begin{aligned}
\trace{A}\ \vDash_{\bottp{\{p\}}}\ \obl[p]{a} \;&\mydef\; a^{(p)}\notin A,\\
\trace{A}\ \vDash_{\bottp{\{\barp\}}}\ \obl[p]{a} \;&\mydef\; a^{(p)}\in A\ \land\ a^{(\barp)}\notin A.
\end{aligned}
\]
These two cases partition a tight violation of $\obl[p]{a}$.

\paragraph{Prohibition \(\frb[p]{a}\).}
Violation requires the joint act to occur. Since the subject should refrain, blame the subject:
\[
\trace{A}\ \vDash_{\bottp{\{p\}}}\ \frb[p]{a}\ \;\mydef\;\ \{a^{(1)}, a^{(2)}\}\subseteq A.
\]
If only one agent attempts the action, it does not violate a prohibition, so no other possible blame arises. An agent cannot be blamed for a prohibition that was not assigned to it.

\paragraph{Power \(\perm[p]{a}\).}
Blame occurs only when the subject of the power attempts and the other party withholds cooperation, and the blame goes to the other party:
\[
\trace{A}\ \vDash_{\bottp{\{\barp\}}}\ \perm[p]{a}\ \;\mydef\;\ a^{(p)}\in A\ \land\ a^{(\barp)}\notin A.
\]

\paragraph{Invalid ($\bot$) is blameless.}
\(\lnot(\trace{A}\vDash_{\bottp{S}}\top)\) for all $S$. 
\(\trace{A}\vDash_{\bottp{\emptyset}}\bot\) by convention (unsatisfiable literal with no party subject).

\paragraph{Post violation (prefix closure of blame).}
Tight blame persists to extensions, and post blame is exactly “some earlier tight blame”:
\[
\trace{A}\ \vDash_{\bottp{S}}\ \ell\ \Longrightarrow\ 
\forall\,\pi\ne\emptytrace:\ \trace{A}\concat\pi\ \vDash_{\botpp{S}}\ \ell
\]
\end{definition}

\begin{remark}[No joint blame at the literal level]
    Each literal is decided on a single step, and the only responsibility split is between the subject and the other party:
    either the subject fails to attempt, or the other party fails to cooperate, or no violation occurs. Hence, for literals, the blame set is always a singleton \(S\in\{\{1\},\{2\}\}\) (or empty for \(\bot\)), never \(\{12\}\).
\end{remark}


\begin{example}[Obligation, prohibition, and power blame]
By fixing $p=1$, $\barp=2$. Consider the following letters $A\in\Gamma$:

\smallskip
\noindent\emph{Obligation \(\obl[1]{a}\).}
\[
\begin{array}{lcl}
A=\emptyset: & \trace{A}\ \vDash_{\bottp{\{1\}}}\ \obl[1]{a} & \text{(subject of the obligation did not attempt)}\\
A=\{a^{(2)}\}: & \trace{A}\ \vDash_{\bottp{\{1\}}}\ \obl[1]{a} & \text{(subject did not attempt)}\\
A=\{a^{(1)}\}: & \trace{A}\ \vDash_{\bottp{\{2\}}}\ \obl[1]{a} & \text{(other party did not cooperate)}\\
A=\{a^{(1)},a^{(2)}\}: & \text{no violation} & \text{(joint execution present).}
\end{array}
\]

\noindent\emph{Prohibition \(\frb[1]{a}\).}
\[
\begin{array}{lcl}
A=\{a^{(1)},a^{(2)}\}: & \trace{A}\ \vDash_{\bottp{\{1\}}}\ \frb[1]{a} & \text{(subject should have refrained)}\\
A=\{a^{(1)}\} \quad: & \text{no violation} & \text{The prohibited action was not successful}
\end{array}
\]

\noindent\emph{Power \(\perm[1]{a}\).}
\[
\begin{array}{lcl}
A=\{a^{(1)}\}: & \trace{A}\ \vDash_{\bottp{\{2\}}}\ \perm[1]{a} & \text{(subject asked, other party withheld)}\\
A=\{a^{(1)},a^{(2)}\}: & \text{no violation} & \text{(properly supported)}\\
A=\{a^{(2)}\}: & \text{no violation} & \text{(no unsupported subject attempt).}
\end{array}
\]
\end{example}

\subsubsection*{Blame Propagation in Contracts}
\paragraph{Conjunction.}
For $S \subseteq\{1, 2\}$ of agent(s), and  two contract $C$ and $C'$ from \cDL and a synchronous trace $\pi$, blame is defined for the conjunction $C \wedge C'$ is defined as:
\[
\pi\ \vDash_{\bottp{S}}\ (C\wedge C') \;\iff\;
\begin{cases}
\pi\ \vDash_{\bottp{S}}\ C \ \nd\ \pi \vDash_{\dbot} C',\\[2pt]
\pi\ \vDash_{\bottp{S}}\ C' \ \nd\ \pi \vDash_{\dbot} C,\\[2pt]
\pi\ \vDash_{\bottp{S_1}}\ C\ \nd\ \pi\ \vDash_{\bottp{S_2}}\ C' \text{ with } S=S_1\cup S_2.
\end{cases}
\]
Where $\dbot$ stand for a non violation verdict, i.e, $\dbot \in \{\,?,\ \topp,\ \topt\,\}$\\
\emph{Intuition.}
The three cases summarize the possible outcomes of forward-looking blame.
The blame goes to the agent responsible for the first violation of the contract: so either C or C', but both contracts could be violated at the same time point, in this case, the agent or agents responsible for \emph{both simultaneous} violation get the blame.

For the rest of the operators,  blame  follows a similar definition as the tight violation, with $k \in [0, \size{\pi}]$:

\paragraph{Sequence.}
For \(S\subseteq\{1,2\}\), contracts \(C,C'\) in \cDL, and a synchronous trace \(\pi\):
\[
\pi\ \vDash_{\bottp{S}}\ (C;C') \;\iff\;
\begin{cases}
\pi\ \vDash_{\bottp{S}}\ C,\\[2pt]
\exists \pi_k\ \vDash_{\topt} \ C \ \nd\ \pi^{k}\ \vDash_{\bottp{S}}\ C'.
\end{cases}
\]
\emph{Intuition.} The first decisive failure before \(C\) has tightly succeeded belongs to \(C\), so its blame propagates. Once \(C\) has tightly succeeded (\(\topt\)) or is in post-success (\(\topp\)), only \(C'\) can still fail, so the blame comes from \(C'\). There is no tie, since \(C'\) becomes active only after \(C\) has tightly succeeded.

\paragraph{Reparation.}
For \(S\subseteq\{1,2\}\), the blame for a reparation contract \(C\repair C'\) is defined as:
\[
\pi\ \vDash_{\bottp{S}}\ (C\repair C')
\;\iff\;
\exists\,k\ \text{such that}\ 
\pi_k\ \vDash_{\bott}\ C
\ \nd\
\pi^k\ \vDash_{\bottp{S}}\ C'.
\]
\emph{Intuition.}  A reparation clause becomes active only after a violation of \(C\). The global blame set \(S\), therefore, corresponds to the agents responsible for violating the reparation \(C'\) once it is triggered. The blame for $C$ is not considered, as one cares only for the overall violation of the combined contracts.


\begin{example}[Witness traces for all blame verdicts]
We use $\Sigma_C=\{\PAY,\PAYF,\OCC\}$ and letters $A_t\subseteq\Gamma$ with agent tags $\cdot^{(1)},\cdot^{(2)}$.
Recall
\[
C_2' := \perm[1]{\OCC}\ ;\ \perm[1]{\OCC},\qquad
C_3 := \obl[1]{\PAY}\ \repair\ \obl[1]{\PAYF}.
\]


\medskip
\noindent\textbf{Tight blame for agent 1 }
\[
\pi_1=\langle A_0\rangle,\quad A_0=\{\OCC^{(1)}\}
\]
Here, $\perm[1]{\OCC}$ and $ \obl[1]{\PAY}$ are violated, the blame verdicts are:
\begin{itemize}
\item The tenant (1) gets blamed for violating the obligation to pay rent:\\ $\pi_1 \vDash_{\bottp{\{1\}}} \obl[1]{\PAY}$. 
\item The landlord (2) gets blamed for violating the power of the tenant to occupy the flat:\\
$\pi_1 \vDash_{\bottp{\{2\}}} \perm[1]{\OCC}$.
\end{itemize}
But the specification allows for the reparation $\obl[1]{\PAY}\ \repair\ \obl[1]{\PAYF}$. So consequently, no tight violation can be diagnosed at $T=1$:\\
$\pi_1 \presat \obl[1]{\PAY}\ \repair\ \obl[1]{\PAYF}.$
Consequently, only the landlord gets the blame for the overall specification:
\[\pi_1 \vDash_{\bottp{\{2\}}} C_2' \wedge C_3.\]

Moreover, consider the trace of  $\pi_2:= \trace{\{\OCC^{(1)}\}, \{\OCC^{(1)}\}}$, the extension of $\pi_1$ with the same event, as the blame is forward and tight looking, the blame is still assigned only to agent $2$ (landlord) as they is responsible for the first violation.

Let us consider instead the following trace $\pi_3:=\trace{A_0',A_1}$ with $A_0':= \{\OCC^{(1)}, \OCC^{(2)}\}$ and $A_1:= \{\OCC^{(1)}\}$.

Here:
\begin{itemize}
\item The landlord gets the blame at $T=2$ for violating the power of the tenant to occupy the flat in the second month:\\
$\pi_3 \vDash_{\bottp{\{2\}}} \perm[1]{\OCC}\ ;\ \perm[1]{\OCC} $.
\item For the reparation clause $\obl[1]{\PAY}\ \repair\ \obl[1]{\PAYF}$ we must distinguish two different situations in which the fine is not honored:
  \begin{itemize}
    \item if the tenant never attempts to pay the fine, that is, no letter of the trace contains $\PAYF^{(1)}$, then the blame goes to agent 1:\\
    $\pi \vDash_{\bottp{\{1\}}} \obl[1]{\PAY}\ \repair\ \obl[1]{\PAYF}$,
    \item if instead the tenant attempts to pay the fine and the landlord does not cooperate, for example, in a letter $A$ with $\PAYF^{(1)}\in A$ and $\PAYF^{(2)}\notin A$, then the fine obligation is violated, and the blame goes to agent 2:\\
    $\pi \vDash_{\bottp{\{2\}}} \obl[1]{\PAY}\ \repair\ \obl[1]{\PAYF}$.
  \end{itemize}
\end{itemize}
\end{example}

\begin{lemma}[Tight forward blame is deterministic]
\label{lem:blame-deterministic}
For every trace $\pi\in\Gamma^*$ and every contract $C$ in \cDL, there exists a unique verdict
$v\in\mathbb{V}_{11}$ such that $\pi\ \vDash_{v}\ C$.
Equivalently, for all $v,v'\in\mathbb{V}_{11}$,
\[
\pi\ \vDash_{v}\ C\ \land\ \pi\ \vDash_{v'}\ C\ \Longrightarrow\ v=v'.
\]
\end{lemma}

\begin{proof}
By structural induction on $C$.

\paragraph{Literals.}
For $C=\ell$, the blame rules in Definition~\ref{def:lockstep-hs} distinguish violations by a finite case split on the current letter $A\in\Gamma$.
In each case, at most one blame set is applicable.
For instance, for $\obl[p]{a}$, either $a^{(p)}\notin A$ (yielding $\bottp{\{p\}}$), or $a^{(p)}\in A\land a^{(\bar p)}\notin A$ (yielding $\bottp{\{\bar p\}}$), or the joint act occurs (no violation).
The clauses for $\frb[p]{a}$ and $\perm[p]{a}$ are analogous.
Post blame is uniquely determined because $\botpp{S}$ holds exactly when some earlier prefix had the corresponding tight blame $\bottp{S}$.

\paragraph{Boolean and temporal constructors.}
Assume determinism holds for strict subcontracts.
For conjunction $C_1\wedge C_2$, the inductive hypothesis yields unique verdicts $v_1$ and $v_2$ for $C_1$ and $C_2$ on $\pi$.
The conjunction clause then produces a unique combined verdict: if exactly one side is a tight (or post) blame verdict, it is selected; if both are blame verdicts, the blame set is uniquely $S_1\cup S_2$; otherwise the result is the unique non-violating combination.

For sequence $C_1;C_2$, the semantics activates $C_2$ only after $C_1$ reaches tight success ($\topt$) and otherwise propagates the unique verdict of $C_1$.
Thus there is no ambiguity between blaming $C_1$ and blaming $C_2$.

For reparation $C_1\repair C_2$, the repair is triggered by the first decisive violation of $C_1$.
The triggering point is unique because the underlying tight regions are prefix-monotone, and the inductive hypothesis yields a unique verdict for the suffix evaluated against $C_2$.
Hence the overall blame verdict is unique.

All remaining constructors follow the same pattern: control flow is determined by the underlying tight verdicts, and blame information is carried along deterministically by the inductive hypothesis.
Therefore, for every $\pi$ and $C$, exactly one verdict in $\mathbb{V}_{11}$ applies.
\end{proof}

\begin{theorem}[Tight Forward Blame semantics is a refinement of tight forward satisfaction]
The tight forward semantics is a refinement of forward tight semantics, that is for any contract $C$ from \cDL and $\pi$ over $\Gamma^*$, we have:
\[
\semfive{\pi,C}=
\begin{cases}
? & \text{ iff } \semelf{\pi,C}=?,\\
\topt & \text{ iff }   \semelf{\pi,C}=\topt,\\
\topp & \text{ iff }  \semelf{\pi,C}=\topp,\\
\bott & \text{ iff }  \exists!\,S\subseteq \{1,2\}:\ \semelf{\pi,C}= \bottp{S},\\
\botp & \text{ iff }  \exists!\,S\subseteq \{1,2\}:\ \semelf{\pi,C}= \botpp{S}.\\
\end{cases}
\]
\end{theorem}

\begin{proof}
    We prove the statement by structural induction on the contract $C$.
    
    \paragraph{Base case: literals.}
    Let $C=\ell$ be a literal, and let $\pi\in\Gamma^*$ be a finite trace.
    
    \smallskip
    \noindent\emph{Case $|\pi|=0$.}
    By Definition~\ref{def:lattsat}, we have $\emptytrace\ \presat\ \ell$ for every literal $\ell$.
    Hence the corresponding five-valued verdict is the undecided one, namely $\semfive{\emptytrace,\ell}=?$.
    On the blame side, there is no letter to trigger any tight blame clause, and post blame is defined only from an earlier tight blame.
    Therefore $\semelf{\emptytrace,\ell}=?$.
    This establishes the three non-violating cases in the displayed refinement table for $\pi=\emptytrace$.
    
    \smallskip
    \noindent\emph{Case $|\pi|\ge 1$.}
    Write $\pi=\trace{A}\concat \pi'$ with $A\in\Gamma$.
    
    First, consider the five-valued semantics. By Definition~\ref{def:lattsat}, literals are decided on the first letter:
    exactly one of $\trace{A}\ \satt\ \ell$ or $\trace{A}\ \violt\ \ell$ holds.
    
    Now consider the blame semantics for literals (your Definition “Blame assignment for literals”).
    If $\trace{A}\ \satt\ \ell$, then no blame violation verdict applies at the first step, so $\semelf{\pi,\ell}\in\{?,\topt,\topp\}$ and the collapse leaves it unchanged. Hence $\semfive{\pi,\ell}\in\{?,\topt,\topp\}$ matches the same non-violating region.
    
    If instead $\trace{A}\ \violt\ \ell$, then by your literal blame rules the violation is refined into a (unique) blame set $S\subseteq\{1,2\}$:
    for $\obl[p]{a}$ there are exactly the two exclusive cases
    $a^{(p)}\notin A$ and $a^{(p)}\in A\land a^{(\bar p)}\notin A$,
    for $\frb[p]{a}$ there is the single case $\{a^{(1)},a^{(2)}\}\subseteq A$,
    and for $\perm[p]{a}$ there is the single case $a^{(p)}\in A\land a^{(\bar p)}\notin A$.
    Thus $\semelf{\pi,\ell}=\bottp{S}$ at the decisive step and, by the post clause, $\semelf{\trace{A}\concat\pi',\ell}=\botpp{S}$ for every non-empty suffix $\pi'$.
    Collapsing erases $S$, yielding $\bott$ at the tight step and $\botp$ afterwards, which is exactly the five-valued classification of a literal (tight violation at the first letter, then post violation).
    Hence the refinement statement holds for literals.
    
    \paragraph{Inductive step.}
    Assume the statement holds for all strict subcontracts of $C$ (and for the required suffix evaluations in the operators that split the trace).
    We show it holds for $C$ by considering the outermost constructor.
    
    \paragraph{Conjunction $C=C_1\wedge C_2$.}
    By the inductive hypothesis, for each $i\in\{1,2\}$ the blame verdict on $C_i$ collapses to the five-valued verdict on $C_i$.
    In the blame semantics, the only difference from the five-valued semantics is that whenever a violation occurs, it carries a blame set, and when both sides violate at the same decisive point, the blame sets are unioned.
    Erasing the blame set therefore yields exactly the same coarse outcome as in the five-valued semantics:
    non-violating combinations stay in $\{?,\topt,\topp\}$, tight blame collapses to $\bott$, and post blame collapses to $\botp$.
    Hence the equivalence holds for $C_1\wedge C_2$.
    
    \paragraph{Sequence $C=C_1;C_2$.}
    Both semantics use the same control flow: $C_2$ is evaluated only after the unique split point where $C_1$ reaches tight success, and otherwise the verdict is inherited from $C_1$.
    The blame semantics again only refines violations by attaching a blame set.
    By the inductive hypothesis on $C_1$ and on $C_2$ evaluated on the suffix beyond the split, collapsing the blame verdict yields exactly the five-valued verdict for $C_1;C_2$.
    
    \paragraph{Reparation $C=C_1\repair C_2$.}
    Both semantics activate $C_2$ precisely at the first tight violation of $C_1$.
    The five-valued semantics records only whether the composite ends in $\bott$ or $\botp$ (or remains non-violating), while the blame semantics records the same region but decorates violation with a blame set.
    By the inductive hypothesis for $C_1$ and for $C_2$ on the triggered suffix, erasing the blame set yields the same coarse verdict as in the five-valued semantics.
    Hence the equivalence holds for $C_1\repair C_2$.
    
    \paragraph{Repetition and regex constructors.}
    For $C^n$, $\repit{C}$, $\trig[re]{C}$, and $\guard[re]{C}$, the blame clauses mirror the five-valued clauses and differ only by refining violation outcomes with blame sets (and propagating them to the post region).
    Applying the inductive hypothesis to the involved subcontracts (and to the required suffixes) and then erasing the blame sets yields the corresponding five-valued verdict in each case.
    
    Thus all constructors preserve the refinement property. Therefore the statement holds for all contracts $C$.
    \end{proof}

\subsection{From Tight Contract Satisfaction Monitor to Tight Blame Monitor}

In the previous subsection, we defined a denotational blame semantics that refines tight and post violations by assigning responsibility to one or both agents. We now show that this refinement can be realized operationally.
Unlike the tight satisfaction monitor, which groups all violations into a single generic $\bott$ verdict, the blame monitor must distinguish between different causes of violation.
Therefore, we cannot simply relabel the outputs of the existing monitor; we must construct a new monitor whose state space explicitly encodes these distinctions.

\begin{definition}[Blame monitor]
\label{def:blamemonitor}
The \emph{blame monitor}, written $\mathcal{M}_{11}$, is a Moore machine whose output alphabet is the eleven-valued blame verdict set $\mathbb{V}_{11}$. Formally,
\[
\mathcal{M}_{11} = (Q,q_0,\Gamma,\mathbb{V}_{11},\delta,\lambda_{11}),
\]
where:
\begin{enumerate}
  \item The output alphabet is
  \[
    \mathbb{V}_{11} = \{\mathsf{?},\topt,\topp\} \cup \{\bot^{t}_{S},\bot^{p}_{S} \mid S\subseteq \{1,2\}\}.
  \]
  \item $Q$ is the set of states and $q_0\in Q$ is the initial state,
  \item $\Gamma = 2^\Sigma$ is the input event alphabet,
  \item $\delta: Q \times \Gamma \to Q$ is the transition function,
  \item $\lambda_{11}: Q \to \mathbb{V}_{11}$ is the state output function.
\end{enumerate}
\end{definition}

We now define the construction function $\bmc(C)$ inductively. This follows the same structural approach as the tight satisfaction monitor construction $\tsmc(C)$ (Definition~\ref{def:tsmc}), but creates distinct states for distinct blame assignments.

\begin{definition}[Blame Monitor Construction]
\label{def:bmc}
The \emph{blame monitor construction} is a function $\bmc(C)$ defined inductively on the structure of the contract $C$.

\paragraph{Base Case: Literals ($\ell$).}
For any literal $\ell$ (including obligations, permissions, and constants $\top, \bot$), the monitor is defined as:
\[
\bmc_{\mathit{lit}}(\ell) = (Q_{\ell}, q_0, \Gamma, \mathbb{V}_{11}, \delta_{\ell}, \lambda_{11}).
\]
\begin{itemize}
    \item \textbf{State Space:} The set $Q_{\ell}$ contains a start state, success states, and specific blame states for any valid blame set $S$ associated with $\ell$ (where $S=\emptyset$ for $\bot$):
    \[
    Q_{\ell} = \{q_0, q_s, q_{ps}\} \cup \bigcup_{S} \{q_{\bott}^S, q_{\botp}^S\}.
    \]
    \item \textbf{Transitions:} The initial transition is determined directly by the denotational blame rules on the input letter $A$:
    \[
    \delta_{\ell}(q_0, A) = 
    \begin{cases}
        q_s & \text{if } \trace{A} \satt \ell \quad (\text{always true for } \top), \\
        q_{\bott}^S & \text{if } \trace{A} \vDash_{\bottp{S}} \ell.
    \end{cases}
    \]
    Subsequent transitions capture the irrevocability of the verdicts:
    \[
    \delta_{\ell}(q_s, \Gamma) = q_{ps}, \quad \delta_{\ell}(q_{ps}, \Gamma) = q_{ps}, \quad \text{and} \quad
    \delta_{\ell}(q_{\bott}^S, \Gamma) = q_{\botp}^S, \quad \delta_{\ell}(q_{\botp}^S, \Gamma) = q_{\botp}^S.
    \]
    \item \textbf{Outputs:} $\lambda_{11}$ maps states to their corresponding verdicts:\\
    $q_0 \mapsto \mathsf{?}$, ~~
    $q_s \mapsto \topt$, ~~
    $q_{ps} \mapsto \topp$, ~~
    $q_{\bott}^S \mapsto \bottp{S}$, and ~~
    $q_{\botp}^S \mapsto \botpp{S}$.
\end{itemize}

\paragraph{Inductive Step: Other Operators.}
For Sequence ($C_1 ; C_2$), Reparation ($C_1 \repair C_2$), Repetition ($\nrep(n,C), \repit{C}$), and Guarded contracts, the construction follows the exact same topological logic as the Tight Satisfaction Monitor constructions (Definitions \ref{def:moore-seq} to \ref{def:moore-repeat-unbounded}), with one key adaptation:
\begin{itemize}
    \item \textbf{Matching Blame States:} Wherever the tight monitor construction redirects a generic violation state (outputting $\bott$), the blame monitor construction redirects \emph{all} corresponding specific blame states (outputting $\bottp{S}$ for any $S$).
    \item \textbf{Example (Reparation):} In $\tsmc_{\repair}$, transitions to any state $q$ where $\lambda_5(q)=\bott$ are redirected to the initial state of $C_2$. In $\bmc_{\repair}$, transitions to \emph{any} state $q$ where $\lambda_{11}(q)=\bottp{S}$ (regardless of $S$) are redirected to the initial state of $C_2$.
\end{itemize}
This preserves the control-flow semantics of the operators: for example, in reparation, \emph{any} fault by \emph{any} party in the primary contract triggers the secondary contract, effectively masking the initial blame in favor of the reparation's outcome.
\end{definition}

\begin{theorem}[Correctness of the Blame Monitor]
\label{thm:bm-correct}
Let $C$ be a contract in \cDL. For every finite trace $\pi$, the output of the blame monitor $\bmc(C)$ equals the denotational blame verdict:
\[
\lambda_{11}\bigl(\delta(q_0,\pi)\bigr) = \mathsf{Blame}(C,\pi).
\]
\end{theorem}

\begin{proof}
The proof proceeds by structural induction on $C$.
\begin{itemize}
    \item \textbf{Literals:} The state splitting in $\bmc_{\mathit{lit}}$ explicitly encodes the blame partition rules. For $\obl[p]{a}$, the transition $\delta_{\ell}$ ensures that a trace with $a^{(p)} \notin A$ reaches $q_{\bott}^p$, while a trace with blocked cooperation reaches $q_{\bott}^{\bar{p}}$. This matches the semantic definition.
    \item \textbf{Conjunction:} The product construction explores all pairs of states. The definition of $\lambda_{11}^{\wedge}$ explicitly calculates $S_1 \cup S_2$ when both components are in violation states, and selects the single responsible party when only one violates. This matches the semantic clause $\pi \vDash_{\bottp{S_1 \cup S_2}} C_1 \wedge C_2$.
    \item \textbf{Other Operators:} The correctness relies on the fact that operators like Sequence and Reparation are defined by switching control based on the \emph{presence} of a violation (or success), not the \emph{content} of the blame.
    For instance, in $C_1 \repair C_2$, the semantics state that if $C_1$ fails (regardless of $S$), we evaluate $C_2$. The monitor construction realizes this by redirecting all transitions targeting any $\bottp{S}$-labeled state of $C_1$ to the start of $C_2$. Thus, the initial blame $S$ is discarded (masked) exactly as prescribed by the semantics, and the final verdict is determined by $C_2$.
\end{itemize}
\end{proof}

% \begin{definition}[Blame monitor]
% \label{def:blamemonitor}
% The \emph{blame monitor}, written $\mathcal{M}_{11}$, is a Moore machine whose output alphabet is the eleven-valued blame verdict set $\mathbb{V}_{11}$. Formally,
% \[
% \mathcal{M}_{11} = (Q',q_0,\Gamma,\mathbb{V}_{11},\delta',\lambda_{11}),
% \]
% where:
% \begin{enumerate}
%   \item $\mathbb{V}_{11} = \{\mathsf{?},\topt,\topp\} \cup \{\bot^{t}_{S},\bot^{p}_{S} \mid S\in\{\{0\},\{1\},\{2\},\{12\}\}\}$,
%   \item $Q'$ is the refined set of states,
%   \item $\delta': Q' \times \Gamma \to Q'$ is the refined transition function,
%   \item $\lambda_{11}: Q' \to \mathbb{V}_{11}$ is the state output function.
% \end{enumerate}
% \end{definition}

% \begin{definition}[Blame monitor construction]
%     \label{def:bmc}
%     Let $C$ be a contract in \cDL. The \emph{blame monitor construction}, denoted $\bmc(C)$, refines the tight satisfaction monitor
%     \[\tsmc(C) = (Q,q_0,\Gamma,\tightverdicts,\delta,\lambda_5)\]
%    into the blame monitor defined as:
%    \[
%    \bmc(C) := (Q',q_0,\Gamma,\mathbb{V}_{11},\delta',\lambda_{11}).
%    \]
%    The state space $Q$ is partitioned into $Q'$ via a refinement map $\mathcal{R}: Q \to \mathcal{P}(Q')$ such that generic violation states in $Q$ are split into distinct blame states in $Q'$.
%    The transition function $\delta'$ and output function $\lambda_{11}$ are defined inductively on the structure of $C$
%     \end{definition}
    
%     \begin{theorem}[Correctness and Consistency of the Blame Monitor]
%     \label{thm:bm-correct}
%     Let $C$ be a contract in \cDL. Let $\tmon(C)$ be its tight satisfaction monitor and $\mathcal{BM}(C)$ be its blame monitor constructed as per Definition~\ref{def:bmc}.
%     For every finite trace $\pi$:
%     \[
%     \lambda^{\mathcal{BM}}\bigl(\delta^{\mathcal{BM}}(q_0,\pi)\bigr) 
%       \;=\; 
%     \mathsf{Blame}(C,\pi).
%     \]
%     \end{theorem}
        
%     \begin{proof}
%     The proof follows directly from the inductive construction in Definition~\ref{def:bmc}.
%     \begin{itemize}
%         \item \textbf{Literals:} The splitting of the transition function $\delta'$ ensures that traces where the subject is passive lead to $q_p$ (output $\bottp{\{p\}}$), and traces where the counterparty blocks lead to $q_{\bar{p}}$ (output $\bottp{\bar{p}}$). This matches the denotational rule for literals.
%         \item \textbf{Conjunction:} The definition of $\lambda_{11}^{\wedge}$ explicitly implements the union of blame sets ($S_1 \cup S_2$) required by the denotational semantics when multiple violations occur.
%         \item \textbf{Sequence/Reparation:} Since these operators partition the trace into independent segments, the correctness of the sub-monitors (Inductive Hypothesis) guarantees the correctness of the composite monitor.
%     \end{itemize}
%     Thus, $\mathcal{BM}(C)$ correctly implements $\mathsf{Blame}(C, \pi)$ for all $\pi$.
%     \end{proof}

% In all cases, $\lambda_{11}$ correctly maps the state to the specific blame verdict defined by the forward-looking semantics. We now move to illustrate this refinement with two interesting examples.

\begin{example}[Blame Monitor for $C_2 \wedge C_3$]
  Let us recall that $C_2 = \perm[1]{\OCC}$ represents the tenant's power to occupy the property, and $C_3 = \obl[1]{\PAY} \repair \obl[1]{\PAYF}$ represents the obligation to pay rent, repaired by paying a fine.
  The following figure shows the blame refinement of the monitor in Figure~\ref{fig:c2andc3}. The generic violation state is partitioned into specific blame verdicts based on the cause of the failure.
  
  \begin{figure}[h!]
  \centering
  \begin{tikzpicture}[
    ->,shorten >=1pt, node distance=20mm and 18mm,
    every state/.style={
      rectangle,rounded corners,draw,
      minimum width=12mm,minimum height=7mm,
      inner sep=5pt,font=\footnotesize,align=center
    },
    initial text={}
  ]
  
  % --- Non-Violating States (Preserved) ---
  \node[initial,state,fill=gray!10] (q0) {$s_0$\\$\mathsf{?}$};
  \node[state, fill=gray!10, below right=15mm and 20mm of q0] (q1) {$s_1$\\$\mathsf{?}$};
  \node[state,fill=green!18,right=35mm of q0] (qs) {$s_{\topt}$\\$\topt$};
  \node[state,fill=green!10,right=22mm of qs] (qps) {$s_{\topp}$\\$\topp$};
  
  % --- Blame States (Split) ---
  % Blame 2 (Landlord) - e.g., blocking permission or fine
  \node[state,fill=red!18,below=25mm of q0] (qv2) {$s_{\bott}^2$\\[2pt]$\bottp{\{2\}}$};
  \node[state,fill=red!10,left=10mm of qv2] (qpv2) {$s_{\botp}^2$\\ [2pt]$\botpp{\{2\}}$};
  
  % Blame 1 (Tenant) - e.g., failing to pay fine
  \node[state,fill=red!18,right=50mm of qv2] (qv1) {$s_{\bott}^1$\\[2pt]$\bottp{\{2\}}$};
  \node[state,fill=red!10,right=10mm of qv1] (qpv1) {$s_{\botp}^1$\\[2pt]$\botpp{\{1\}}$};
  
  % --- Transitions ---
  
  % 1. Success paths (Unchanged)
  \path
    (q0) edge[bend left=10] node[above,pos=0.6] {\footnotesize$\OCC^\surd \land \PAY^{\surd}$} (qs)
    (q0) edge[bend left=12] node[pos=0.6,sloped,above] {\footnotesize$\OCC^\surd \land \PAY^{\times}$} (q1)
    (q1) edge[bend left=8] node[right,pos=0.4] {\footnotesize$\PAYF^\surd$} (qs)
    (qs) edge node[above] {\footnotesize$\Gamma$} (qps)
    (qps) edge[loop right] node {\footnotesize$\Gamma$} ();
  
  % 2. Violation: Landlord Fault (Blame 2)
  % From s0: Landlord blocks occupation (Violation of P_1(OCC))
  \path
    (q0) edge[bend right=20] node[left,pos=0.5] {\footnotesize$\OCC^{\times}$} (qv2);
  
  % From s1: Landlord blocks fine payment (Violation of O_1(PAY_F))
  % Define specific label for blocked fine: Tenant tries, Landlord blocks
  \path
    (q1) edge[bend left=15] node[above,sloped] {\footnotesize$\PAYF^{\text{blk}}$} (qv2);
  
  % 3. Violation: Tenant Fault (Blame 1)
  % From s1: Tenant fails to pay fine (Violation of O_1(PAY_F))
  % Define specific label for passive failure: Tenant doesn't try
  \path
    (q1) edge[bend right=15] node[above,sloped] {\footnotesize$\PAYF^{\text{fail}}$} (qv1);
  
  % 4. Post-Violation Loops
  \path
    (qv2) edge node[auto] {\footnotesize$\Gamma$} (qpv2)
    (qv1) edge node[auto] {\footnotesize$\Gamma$} (qpv1)
    (qpv2) edge[loop left] node {\footnotesize$\Gamma$} ()
    (qpv1) edge[loop right] node {\footnotesize$\Gamma$} ();
  
  \end{tikzpicture}
  \caption{Blame Monitor $\mathcal{BM}(C_2 \wedge C_3)$.
  \textbf{Changes from Tight Monitor:}
  The state $s_{\bott}$ is split into $s_{\bott}^2$ (Landlord blame) and $s_{\bott}^1$ (Tenant blame).
  \textbf{Edge Definitions:}
  $\OCC^\times$: Tenant attempts $\OCC$, Landlord blocks.
 $\PAYF^{\text{fail}}$: Tenant does not attempt $\PAYF$ ($\PAYF^{(1)} \notin A$).
  $\PAYF^{\text{blk}}$: Tenant attempts $\PAYF$, Landlord blocks.
  }
  \label{fig:blame-monitor}
  \end{figure}
  \end{example}

  Although the previous example is constructed using a conjunction, the reparation operator within $C_3$ delays the assignment of blame for the payment obligation.
Specifically, if the tenant fails to pay rent, the monitor transitions to a waiting state for the repair (outputting $\mathsf{?}$) rather than immediately emitting a violation verdict.
Consequently, it is impossible for both conjuncts to return a tight violation $\bott$ at the same initial step.
To illustrate a scenario where the monitor can output the joint blame verdict $\bottp{12}$, we consider the reparation-free reduction of the specification: $\perm[1]{\OCC} \wedge \obl[1]{\PAY}$.

  \begin{example}[Blame Monitor with double blame]\label{example:joint-blame}
    The following monitor in \ref{fig:joint-blame} shows the emergence of joint blame. From the initial state $s_0$, three distinct violation paths are possible depending on who fails. The path to $s_{\bott}^{12}$ represents the simultaneous failure of both parties.
    
    \begin{figure}[h!]
    \centering
    \begin{tikzpicture}[
      ->, node distance=20mm and 25mm,
      every state/.style={
        rectangle,rounded corners,draw,
        minimum width=12mm,minimum height=7mm,
        inner sep=5pt,font=\footnotesize,align=center
      },
      initial text={}
    ]
    
    % --- Initial State ---
    \node[initial,state,fill=gray!10] (q0) {$s_0$\\[2pt]$\mathsf{?}$};
    
    % --- Success State ---
    \node[state,fill=green!18,right=35mm of q0] (qs) {$s_{\topt}$\\[2pt]$\topt$};
    \node[state,fill=green!10,right=20mm of qs] (qps) {$s_{\topp}$\\[2pt]$\topp$};
    
    % --- Violation States ---
    
    % 1. Joint Blame (Top Path)
    \node[state,fill=purple!18,above right=7mm and 35mm of q0] (q12) {$s_{\bott}^{12}$\\[2pt]$\bottp{12}$};
    \node[state,fill=purple!10,right=20mm of q12] (qp12) {$s_{\botp}^{12}$\\[2pt]$\botpp{12}$};
    
    % 2. Tenant Blame (Middle/Right Path)
    \node[state,fill=red!18,below=7mm of qs] (q1) {$s_{\bott}^{1}$\\[2pt]$\bottp{\{2\}}$};
    \node[state,fill=red!10,right=20mm of q1] (qp1) {$s_{\botp}^{1}$\\[2pt]$\botpp{1}$};
    
    % 3. Landlord Blame (Bottom Path)
    \node[state,fill=red!18,below=7mm of q1] (q2) {$s_{\bott}^{2}$\\[2pt]$\bottp{\{2\}}$};
    \node[state,fill=red!10,right=20mm of q2] (qp2) {$s_{\botp}^{2}$\\[2pt]$\botpp{2}$};
    
    % --- Transitions ---
    
    % Success: Tenant pays AND Landlord allows occupation
    \path
      (q0) edge node[above] {\footnotesize$\OCC^\surd \land \PAY^\surd$} (qs)
      (qs) edge node[above] {\footnotesize$\Gamma$} (qps)
      (qps) edge[loop right] node {\footnotesize$\Gamma$} ();
    
    % Joint Violation: Tenant doesn't pay AND Landlord blocks occupation
    \path
      (q0) edge[bend left=20] node[sloped,above] {\footnotesize$\OCC^\times \land \PAY^{\text{fail}}$} (q12)
      (q12) edge node[above] {\footnotesize$\Gamma$} (qp12)
      (qp12) edge[loop right] node {\footnotesize$\Gamma$} ();
    
    % Tenant Violation: Landlord allows occupation, BUT Tenant doesn't pay
    \path
      (q0) edge[bend right=5] node[sloped,above,pos=0.6] {\footnotesize$\OCC^\surd \land \PAY^{\text{fail}}$} (q1)
      (q1) edge node[above] {\footnotesize$\Gamma$} (qp1)
      (qp1) edge[loop right] node {\footnotesize$\Gamma$} ();
    
    % Landlord Violation: Tenant pays, BUT Landlord blocks occupation
    \path
      (q0) edge[bend right=30] node[sloped,below] {\footnotesize$\OCC^\times \vee \PAY^{\text{blk}}$} (q2)
      (q2) edge node[above] {\footnotesize$\Gamma$} (qp2)
      (qp2) edge[loop right] node {\footnotesize$\Gamma$} ();
    
    \end{tikzpicture}
    \caption{Blame Monitor for $\perm[1]{\OCC} \wedge \obl[1]{\PAY}$.\\
    \textbf{Edge Definitions:}\\
    $\PAY^{\text{fail}}$: Tenant does not attempt payment ($\PAY^{(1)} \notin A$).\\
    $\OCC^\times$: Tenant attempts occupation, Landlord blocks.\\ $\PAY^{\text{blk}}$: Tenant attempts to pay and Landlord blocks.\\
    The state $s_{\bott}^{12}$ is reached only when both violations occur in the same step.}
    \label{fig:joint-blame}
    \end{figure}
    \end{example}


    \begin{example}[Blame Monitor for $\repit{C_3}$]
      The figure below shows the blame monitor for the unbounded repetition of the rent-and-reparation contract. The generic violation state $q_{\bott}$ from the standard monitor is split into $s_{\bott}^1$ and $s_{\bott}^2$. Crucially, once the monitor transitions to a post-violation sink (e.g., $s_{\botp}^1$), it loops on any input $\Gamma$. This demonstrates the "first blame" limitation: if the tenant is blamed for missing a fine, the monitor will never blame the landlord for any future misconduct.
      
      \begin{figure}[h!]
      \centering
      \begin{tikzpicture}[
        ->, shorten >=1pt,node distance=20mm and 20mm,
        every state/.style={
          rectangle,rounded corners,draw,
          minimum width=12mm,minimum height=7mm,
          inner sep=5pt,font=\footnotesize,align=center
        },
        initial text={}
      ]
      
      % --- Active States ---
      \node[initial,state,fill=gray!10]          (q0)  {$s_0$\\[2pt]$\mathsf{?}$};
      \node[state,fill=gray!10,below=of q0]      (qw)  {$s_w$\\[2pt]$\mathsf{?}$};
      
      % --- Split Violation States ---
      
      % Path 1: Tenant Blame (Most common case)
      \node[state,fill=red!18,above right= 4 mm and 20mm of qw]       (qv1)  {$s_{\bott}^1$\\[2pt]$\bottp{\{2\}}$};
      \node[state,fill=red!10,right=20mm of qv1]       (qpv1) {$s_{\botp}^1$\\[2pt]$\botpp{\{1\}}$};
      
      % Path 2: Landlord Blame (Blocking the fine)
      \node[state,fill=red!18,below right= 4 mm and 20mm of qw]       (qv2)  {$s_{\bott}^2$\\[2pt]$\bottp{\{2\}}$};
      \node[state,fill=red!10,right=20mm of qv2]       (qpv2) {$s_{\botp}^2$\\[2pt]$\botpp{\{2\}}$};
      
      % --- Transitions ---
      
      % 1. In-cycle behavior
      \path
          (q0) edge[loop above] node[above,pos=0.5] {\footnotesize $\PAY^\surd$} ()
          (q0) edge[bend right=15] node[left,pos=0.45] {\footnotesize $\PAY^\times$} (qw)
          (qw) edge[bend right=15] node[right,pos=0.7] {\footnotesize $\PAYF^\surd$} (q0); % Restart on repair
      
      % 2. Violation: Tenant Fault
      % Tenant fails to pay the fine (no blocking)
      \path
          (qw) edge[bend left=15] node[below,sloped] {\footnotesize $\PAYF^{\text{fail}}$} (qv1);
      
      % 3. Violation: Landlord Fault
      % Tenant attempts fine, Landlord blocks
      \path
          (qw) edge[bend right=15] node[below,sloped] {\footnotesize $\PAYF^{\text{blk}}$} (qv2);
      
      % 4. Sinks (The Limitation)
      % Once in a sink, the monitor loops forever, ignoring future events
      \path
          (qv1)  edge node[above] {\footnotesize$\Gamma$} (qpv1)
          (qpv1) edge[loop right] node {\footnotesize$\Gamma$} ()
          (qv2)  edge node[above] {\footnotesize$\Gamma$} (qpv2)
          (qpv2) edge[loop right] node {\footnotesize$\Gamma$} ();
      
      \end{tikzpicture}
      \caption{Blame Monitor for $\repit{C_3}$.
      \textbf{Limitation:} If the trace reaches $s_{\botp}^1$ (Tenant blame), the monitor remains there forever. Even if the landlord subsequently blocks a valid payment attempt ($\PAYF^{\text{blk}}$) in a future step, the verdict remains $\botpp{1}$.}
      \label{fig:rep-c3_blame}
      \end{figure}
      \end{example}     
      
\subsection{Conclusion and Limitation}      
      We have presented forward-looking semantics and a corresponding monitor construction that refine the standard satisfaction verdicts by assigning responsibility. 
      This approach is computationally efficient and provides immediate feedback on the \emph{status} of the contract, allowing for runtime enforcement and dispute resolution at the moment a breach occurs.
      
      However, this prefix-based view naturally implies a limitation regarding the completeness of the violation history. 
      The semantics is designed to detect the \emph{first} decisive violation that renders the contract permanently unsatisfiable. 
      Once the monitor transitions to a post-violation sink state ($\botpp{S}$), the verdict becomes immutable. 
      A practical consequence of this property is that, even when processing infinite words or streams, the monitor can be programmed to halt execution immediately after the first tight violation is detected, as no future event can alter the blame assignment.
      Consequently, any subsequent violations committed by other agents at later time steps are effectively masked by the first failure.
      
      This limitation is particularly evident in open-ended contracts involving the repetition operator. 
      As illustrated by the monitor for $\repit{C_3}$ (\ref{fig:rep-c3_blame}), if the tenant is blamed for failing to pay the reparation in one cycle, the monitor enters the sink state $s_{\botp}^1$. 
      Even if the interaction continues and the landlord subsequently violates their permission or obligation in a future cycle (e.g., by blocking a valid payment attempt), the monitor remains fixed on the initial verdict $\botpp{1}$. 
      Therefore, while this framework is sufficient for determining \emph{why} a contract failed, it does not support a cumulative accounting of \emph{all} violations that occur throughout the lifespan of a long-running interaction. 
      This is a notable constraint, as in law and normative systems, one typically has to account for all violations to determine the full extent of liability or penalties.
      Capturing such multi-point violations would require a mechanism to reset or parallelize monitoring threads after a failure, rather than absorbing them into a permanent sink.
      
      Finally, extending this framework to support a cumulative blame semantics suggests interesting theoretical challenges. 
      In particular, the interaction between timed operators and conjunctions complicates fault aggregation. 
      For instance, determining whether overlapping failures in concurrent branches or repeated violations within sliding time windows should be counted as distinct or continuous breaches requires a more complex, possibly non-monotonic, judgement structure than the one presented here.     

% \begin{theorem}[Correctness of the blame monitor]
% \label{thm:bm-correct}
% Let $C$ be a contract in \cDL, and let $\bmc(C)$ be its blame monitor. For
% every finite trace $\pi$ and every prefix index $k<|\pi|$, if the run of
% $\bmc(C)$ on $\pi$ is
% \[
% q_0,q_1,\dots,q_k,
% \]
% then
% \[
% \lambda_{11}(q_k) = \mathsf{Blame}_C\big(\pi[1,k]\big).
% \]
% In particular:
% \begin{itemize}
%   \item $\lambda_{11}(q_k)\in\{\mathsf{?},\topt,\topp\}$
%         iff $\pi[1,k]\in\{\presat,\satt,\postsat\}$ for $C$,
%   \item $\lambda_{11}(q_k)=\bot^t_S$
%         iff $\pi[1,k]\ \vDash_{\bottp{S}} C$,
%   \item $\lambda_{11}(q_k)=\bot^p_S$
%         iff $\pi[1,k]\ \vDash_{\botpp{S}} C$.
% \end{itemize}
% \end{theorem}

% \begin{proof}[Proof sketch]
% Correctness of the tight monitor construction $\tsmc(C)$ with respect to the
% five-valued semantics has already been established for all constructors.
% The blame rules for literals and contract operators are defined by structural
% recursion on $C$ and share the same tight frontiers as the underlying
% violation semantics. By Lemma~\ref{lem:mutual prefix}, each prefix carries at
% most one tight frontier, and the five regions are disjoint. The inductive
% clauses for blame propagation mirror the violation clauses, so for every
% reachable state $q_k$ on the run over $\pi$, the contract semantics assigns a
% unique verdict in $\mathbb{V}_{11}$ to the prefix $\pi[1,k]$.
% By Definition~\ref{def:bm-refinement}, $\lambda_{11}(q_k)$ is exactly that
% verdict. The statement follows by induction on the structure of $C$ and on the
% length of $\pi$.
% \end{proof}

% The blame monitor thus provides a concrete, prefix-based implementation of the
% forward-looking blame semantics. It reads the same synchronous trace as the
% tight satisfaction monitor, but instead of only declaring whether $C$ is
% satisfied or violated, it refines every violation region with a precise
% allocation of responsibility to the involved agents.

% \begin{example}[Blame monitors for $C_3$ and $C_2\wedge C_3$]
% We illustrate the reuse of the tight monitor construction on the rent contract
% $C_3 = \obl[1]{\PAY}\repair\obl[1]{\PAYF}$ and its conjunction with the
% permission $C_2=\perm[1]{\OCC}$.
% The five-valued monitors for $\repit{C_3}$ and for $C_2\wedge C_3$ were given
% in Example~\ref{ex:moore-c3-literals}.
% The corresponding blame monitors are obtained by keeping the same states and
% transitions and only refining the outputs.

% \begin{figure}[h!]
% \centering
% \tikzset{
%   ->, >=Stealth, semithick,
%   node distance=17mm,
%   every state/.style={
%     rectangle,rounded corners,draw,
%     minimum width=12mm,minimum height=7mm,
%     inner sep=2pt,font=\scriptsize,align=center}
% }

% % Blame monitor for rep(C3)
% \begin{subfigure}[t]{0.46\textwidth}
% \centering
% \begin{tikzpicture}
%   \node[initial,state,fill=gray!10]          (q0)  {$q_0$\\$\mathsf{?}$};
%   \node[state,fill=gray!10,below=of q0]      (qw)  {$q_w$\\$\mathsf{?}$};
%   \node[state,fill=red!18,right=of qw]       (qv)  {$q_{\bot^t}$\\$\bot^t_{\{1\}}$};
%   \node[state,fill=red!10,above=of qv]       (qpv) {$q_{\bot^p}$\\$\bot^p_{\{1\}}$};

%   \path
%     (q0) edge[loop above] node[above,pos=0.5] {\scriptsize $\PAY^\surd$} ()
%     (q0) edge[bend right=13] node[left,pos=0.45] {\scriptsize $\PAY^\times$} (qw)
%     (qw)  edge[bend right=13] node[right,pos=0.45] {\scriptsize $\PAYF^\surd$} (q0)
%     (qw)  edge[bend right=10] node[below,pos=0.45] {\scriptsize $\PAYF^\times$} (qv)
%     (qv)  edge node[left] {\footnotesize$\Gamma$} (qpv)
%     (qpv) edge[loop right] node {\footnotesize$\Gamma$} ();
% \end{tikzpicture}
% \caption{Blame monitor for $\repit{C_3}$. All unrepaired violations of $C_3$ are blamed on agent 1.}
% \label{fig:rep-c3-blame}
% \end{subfigure}
% \hfill

% % Blame monitor for C2 ^ C3
% \begin{subfigure}[t]{0.46\textwidth}
% \centering
% \scalebox{0.9}{
% \begin{tikzpicture}[
%   ->, >=Stealth, node distance=20mm and 18mm,
%   every state/.style={
%     rectangle,rounded corners,draw,
%     minimum width=12mm,minimum height=7mm,
%     inner sep=2pt,font=\scriptsize,align=center
%   }
% ]
% \node[initial,state,fill=gray!10] (q0) {$s_0$\\$\mathsf{?}$};
% \node[state, fill=gray!10, below right=16mm and 17mm of q0] (q1) {$s_1$\\$\mathsf{?}$};
% \node[state,fill=green!18,right=22mm of q0] (qs) {$s_{\topt}$\\$\topt$};
% \node[state,fill=red!18,below=28mm of q0] (qv) {$s_{\bot^t}$\\$\bot^t_{S}$};
% \node[state,fill=green!10,right=22mm of qs] (qps) {$s_{\topp}$\\$\topp$};
% \node[state,fill=red!10,below=28mm of qps] (qpv) {$s_{\bot^p}$\\$\bot^p_{S}$};

% \path[->]
%   (q0) edge[bend left=10] node[above,pos=0.5] {\scriptsize$\OCC^\surd \land \PAY^{\surd}$} (qs)
%   (q0) edge[bend right=14] node[left,pos=0.5] {\scriptsize$\OCC^{\times}$} (qv)
%   (q0) edge[bend left=12] node[pos=0.45,sloped,above] {\scriptsize$\OCC^\surd \land \PAY^{\times}$} (q1)
%   (q1) edge[bend left=8] node[right] {\scriptsize$\PAYF^\surd$} (qs)
%   (q1) edge[bend left=10] node[above,pos=0.7] {\scriptsize$\PAYF^{\times}$} (qv)
%   (qs) edge node[above] {\footnotesize$\Gamma$} (qps)
%   (qv) edge node[below] {\footnotesize$\Gamma$} (qpv)
%   (qps) edge[loop right] node {\footnotesize$\Gamma$} ()
%   (qpv) edge[loop right] node {\footnotesize$\Gamma$} ();
% \end{tikzpicture}}
% \caption{Blame monitor for $C_2\wedge C_3$. $S$ denotes the blame set prescribed by the conjunction blame rules.}
% \label{fig:c2andc3-blame}
% \end{subfigure}

% \caption{Blame monitor construction by reuse of the tight monitors for $\repit{C_3}$ and $C_2\wedge C_3$. States and transitions are inherited from the five-valued monitors; only the outputs are refined from $\bott,\botp$ to the responsibility-aware verdicts $\bot^t_S,\bot^p_S$.}
% \label{fig:blame-monitors-c2-c3}
% \end{figure}
% \end{example