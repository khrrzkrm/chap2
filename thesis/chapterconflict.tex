\chapter{Reasoning about Metric-Timed Normative Conflicts}\label{chap:conflict}

\section{Overview}
\label{sec:overview}

As discussed in the introduction chapter, normative systems provide the formal backbone for how organizations, individuals, software, and autonomous agents are expected to behave. A \emph{normative specification} describes these expectations as a set of rules determining what an agent ought to do or what state of affairs ought to be. However, dealing with such specifications is inherently difficult. They combine different types of rules, such as obligations, prohibitions, and permissions, whose interplay can yield overlapping prescriptions. In many situations, complying with one norm causes the violation of another. This situation is referred to as a \emph{normative conflict}.
This chapter studies those conflicts in \emph{ought-to-do} specifications with explicit temporal conditions. 

\subsection{Motivation}
Norms are rarely timeless: they are activated, suspended, or expire under explicit temporal conditions.  
This temporal structure has motivated a long line of research in \emph{temporal deontic logics} and \emph{contract specification languages}.  
Early works such as~\cite{DBLP:conf/hicss/DignumK98,broersen2004designing} formalized temporal deontic constraints by linking obligations to deadlines.  
A second wave of studies~\cite{BroersenBrunel2007} examined how unmet obligations propagate over time, capturing the principle that “what I fail to do today, I must do tomorrow,” which formalizes the continuation of obligations after a missed deadline.  
In parallel, \cite{governatori2007characterising,governatori2011justice} introduced a temporal defeasible logic that characterizes different types of deadlines, offering a flexible framework for representing and reasoning about time-sensitive norms.  
This line of research enabled the modeling of norms that become active or expire at specific points in time, the idea that a rule is \emph{in force} at a given instant due to a reparation clause following a violation or a triggering event.  
More recent frameworks, such as~\cite{HvitvedKZ12}, C--O Diagrams~\cite{camilleri2014cnl}, and FCL~\cite{farmer2016fcl}, offer greater expressive power and aim to capture real-world normative dynamics.

 
Unlike in untimed settings, conflicts in timed specifications depend on \emph{when} norms are active and \emph{how many} are active at once. When several obligations share the same activation period, the agent may lack the capacity to plan and execute them all within that window. Conflicts also occur at \emph{moments} when the agent is obliged to perform an action and at the same time prohibited from doing it. In short, time turns contradiction into a scheduling and capacity problem: we must reason about activation periods and point-wise clashes, not only about truth values.

Early approaches, such as Fenech et al.~\cite{fenech2009automatic}, formalized conflict detection through reachability analysis over automata whose states were annotated with deontic labels: whenever a reachable state contained incompatible obligations or prohibitions, the contract was considered conflicting. While effective for identifying logical contradictions, this view abstracts away from when and how conflicts arise. As argued by Colombo Tosatto, Governatori, and Kelsen~\cite{colombo2014detecting}, such inconsistencies often result not from $O\alpha \land O\lnot\alpha$ alone but from \emph{temporal infeasibility}, where no timed trace can satisfy the conjunction of active norms. More recent work, such as N-Check~\cite{10.1145/3597503.3639093}, reduces the analysis of normative requirements to first-order satisfiability checking, diagnosing conflicts as unsatisfiable rule combinations. 

\paragraph{Research gap and questions}
Although existing approaches successfully expose when a formula contains a conflict, they typically treat time symbolically and leave the precise definition of what \emph{constitutes} a normative conflict open. This lack of formal precision raises three fundamental research questions:

\begin{enumerate}[RQ1]
  \item \textbf{Relation between Unsatisfiability and Conflict:} The relationship between general logical unsatisfiability and specific normative conflicts is currently not well formalized. Is every unsatisfiable formula a conflict? Conversely, does the presence of a conflict necessarily imply that the formula is unsatisfiable?
    
    \item \textbf{Conflict Quantification:} While satisfiability is intrinsically a binary property (true or false), can we define a quantitative measure for the \emph{degree} of conflict within a specification?
    
    \item \textbf{Properties-Preserving Resolution:} Is it always possible to resolve conflicts in a formula without altering its inherent semantics or compromising its structural compactness?
\end{enumerate}

\subsection{Methodology}

To address these challenges, we first formalize the potential behavior of agents as finite timed words by structuraly encoding it as a sequence of timed events formed by \emph{a unique action} per event. The  We introduce a light logic, $\TDDLfm$, allowing us to formalize normative specifications where time conditions are represented as finite interval sets. This trace-based semantics serves as the ground truth for our analysis.

We then narrow down the abstract notion of conflict into two fundamental types. The first is \emph{deontic}, where rules contradict each other. The second is \emph{ontic}, where rules demand more than the agent can physically perform. We show that these clashes often hide within complex time intervals. To expose them, we develop a rigorous transformation process that unfolds specifications into their atomic components. Crucially, we prove that this process is structure-preserving. It reveals strictly those conflicts present in the original design without creating spurious ones or erasing existing ones.

With these atomic conflicts exposed, we introduce a quantitative metric to measure the density of inconsistency in a system. We demonstrate that this measure is directly linked to whether a specification is logically solvable. A fully conflicting system is impossible to satisfy. Conversely, a partially conflicting one can always be automatically repaired. We provide an algorithm for this repair that effectively prunes the contradictory parts while preserving the valid compliant behaviors.

We then bridge the gap between this operational detection and theoretical logic. We prove that our defined conflict patterns are \emph{enough to explain all causes} of the unsatisfiability of any formula. This ensures that our detection method is both sound and complete.

Finally, we address the practical trade-off between automation and conciseness. Eliminating conflicts automatically can sometimes result in verbose specifications. To mitigate this, we complement our algorithms with a \emph{conflict calculus}. This set of inference rules allows for high-level symbolic reasoning. It enables designers to resolve conflicts manually and simplify specifications without needing to decompose the entire formula.
\subsection{Contribution}

In this chapter, we provide a logical framework for \emph{metric-time normative conflicts} that deals with these issues in a mathematically precise manner. Our specific contributions are as follows:

\begin{itemize}[C1]
    \item \textbf{Formal Machinery:} We define a compact, action-based logic over finite interval sets. We provide algorithms for punctual and disjunctive normalization (\dpnf) and a proof-theoretic calculus for conflict detection.
    
    \item \textbf{Conflict Characterization:} We offer precise definitions for conflicts and conditions for their correct detection. We prove that deontic and ontic conflicts correspond precisely to Minimal Unsatisfiable Subsets (MUS) in our logic. Conversely, we show that any MUS is necessarily an instance of one of these conflict types.
    
    \item \textbf{Quantitative Metrics:} We introduce the concept of \emph{conflict density}, which measures the ratio of conflicting to total punctual obligations. We show that a conflict density of 1 implies unsatisfiability, while a density below 1 allows for a conflict-free, semantics-preserving pruning.
    
    \item \textbf{Elimination and Guarantees:} We provide sound and complete methods for equivalence-preserving conflict elimination. We analyze the verbosity induced by this process, demonstrating that while eliminating conflicts can increase the syntactic size of the specification, the blow-up remains bounded under well-defined structural conditions.
\end{itemize}

Altogether, this framework allows us to identify conflicts in a specification, explain their causes via interval arithmetic, measure their density, and eliminate them without altering the intended compliant behaviors.
\section{Use Case: Goods Delivery Contract}\label{sec:usecase}


Our use case examines a contract between a trucking company and a harbor, focusing on the daily delivery of potentially hazardous goods to the harbor.  
%
\ref{tab:contract} presents a portion of the contract signed between the trucking company and the harbor. For clarity, we do not provide the full contractual agreement, but instead highlight select sections to illustrate our language and the occurrence of \textit{potential conflicts}.


\newcolumntype{C}{>{\columncolor{lightgray}}p{0.8\textwidth}}

\begin{table}[h]

  \begin{tabular}{|C|r|}
  \hline 
  \dots     &  \\
  The deliveries \textit{shall} be made everyday to \textit{either the gate terminal or the designated parking area of the harbor}. The delivery must be done  \textit{between 09:00 to 16:00 }.
     & (\DC) \\
\dots & \\
    Delivery of dangerous goods to the harbor's parking lot is prohibited between 10:00 and 14:00.
& (\SR)\\   
\dots & \\
   When delivering goods, special restrictions may apply due to maintenance activity in the harbor. &  (\MC)\\
  \dots & \\
  \hline    
\end{tabular}
    \caption{Contract between trucking company and a harbor company}
    \label{tab:contract}
\end{table}


Let us elaborate on the contract. There are individuals and legal entities involved, like the truck driver, the transportation company and the harbor. 

The contract involves several clauses; first, a \emph{Delivery Clause} (\DC) for all goods. Moreover, there is a clause adding additional \emph{Safety Regulations} (\SR) when dangerous goods are involved. The third and final clause requires respecting any \emph{Maintenance Clause} (\MC) of the harbor when delivering goods. 


The Delivery Clause (\DC) specifies the designated delivery location and time frame (between 09:00 and 16:00)  to be performed on a daily basis; the harbor carries on by loading the goods onto the ferry on fixed and reserved slots as specified in the contract, making the driver's delivery act mandatory in the delivery chain. The Safety Regulation clause \SR prohibits the delivery of \emph{dangerous} goods in the harbor's parking area between 10:00 and 14:00. The Maintenance Clause \MC mandates compliance with announcements when delivering goods. These maintenance announcements are issued by the harbor's infrastructure management unit by providing a \emph{Maintenance Announcement} document (\MA) requiring consultation (cf.~the document shown in \ref{tab:ma}). This document may be empty in case no announcement is in place or adds specific clauses. 


\begin{table}
    \centering
    \begin{tabular}{|C|c|}
    \hline
    Due to infrastructure damage at the harbor, the delivery of dangerous goods to the gate terminal is temporarily prohibited during the following hours: (1) Between 02:00 and 04:00, and (2) between 08:00 and 24:00. & (\MA)\\
    \hline
    \end{tabular}
    \caption{Maintenance Announcement}
    \label{tab:ma}
\end{table}


Let us now reconsider the contract and perform a more conceptual analysis: 
Individuals and legal entities affected by the normative system are called \emph{agents}. These agents are required to follow the prescriptions and rules of the contract or agreement, which are collectively termed \emph{norms}. In this paper, we focus on formalizing norms concerning a \emph{single} agent, leaving multi-agent scenarios for future work. 
Norms stipulate what the different agents are permitted, obliged or forbidden to do, as well as the penalties to be applied in case of non-compliance. As explained in the introduction, we focus here not on \emph{full} normative systems but on a subset of normative statements.

An agent is typically not bound by just one norm but must comply with several norms simultaneously (all the norms in the given normative system(s) under consideration). The norms may be distributed over several documents.
The norms are enacted (and enforced) at specific \emph{time points}. In general, such time points are explicitly or implicitly written in the contract and they can be expressed in relative or absolute time. For instance, they can be relative to a certain date (e.g., when the contract was signed) or to the occurrence of certain events, or then expressed as dates, hours of a day, etc. Without loss of generality, we represent such time points as natural numbers.\footnote{It is always possible to convert from relative to absolute time (and vice-versa) as well as to map hours and dates into natural numbers.} More precisely, norms are associated with time \emph{intervals}, and the agent must adhere to constraints across multiple such intervals. In the next section, we will make these notions more formal (e.g., we will define intervals and establish operations for \emph{interval arithmetic}).
Back to our use case, the driver's task is to deliver goods within specific time constraints defined as intervals as stipulated in the contract. Whenever the driver performs \emph{actions} which are within the scope of the contract, we may consider that the contract is being \emph{executed}. Such actions happen at a given time point. We thus represent the sequence of actions (the behavior of the agent) as \emph{timed action sequences}, which are modeled as \emph{\timedwords}. We simplify our framework by assuming that each action is instantaneous and happens at a single point in time. Actions with longer durations may be considered in future work.

With this framework in place, we now proceed to a more detailed analysis of the normative specifications of our use case. First, we can identify the following two actions to be performed by the driver:

\begin{enumerate}
    \item Delivery at the gate, denoted by \delAtGate, cf.~\DC and \MA;
    \item Delivery at the parking, denoted by \delAtPark, cf.~\DC and \SR.
\end{enumerate}

The identified driver's actions are subject to \textit{obligation: has to perform the action} and \emph{prohibition: has to abstain from performing the action}: 
\begin{enumerate}
    \item Obligation: \delAtGate and \delAtPark, cf.~\DC;
    \item Prohibition: \delAtGate, cf.~\MA, and \delAtPark, cf.~\SR.
\end{enumerate}
The obligations and prohibitions are to be enacted on specific intervals of time:
%
\begin{enumerate}
\item \textit{Between 09:00 and 16:00}: concerning the obligation on \delAtPark, cf.~\DC
\item \textit{Between 10:00 and 14:00}: concerning the prohibition on \delAtPark, cf.~\SR
\item \textit{Between 02:00 and 04:00 and between 08:00 and 24:00} concerning the prohibition on \delAtGate, cf.~\MA
\end{enumerate}



 \begin{figure}
\begin{center}
\begin{tikzpicture}[scale=0.8,transform shape]
  % Hour mapping: 1h = 0.5cm, shifted +1cm
  \begin{scope}[x=0.5cm, shift={(1cm,0)}]

    % Layout parameters
    \def\laneH{0.45}      % thinner rectangles
    \def\offset{0.25}     % vertical offset for obligation band
    \def\yshiftText{0.6}  % downward shift for prohibition text
    \def\rectShift{0.3}   % upward shift of rectangles
    \def\ygate{1.6}
    \def\ypark{-1.6}

    % Styles
    \tikzset{
      obl/.style ={
        draw=blue!80!black, line width=0.8pt, rounded corners=2pt,
        pattern={Lines[angle=45,distance=2pt,line width=0.3pt]},
        pattern color=blue!70!black, fill opacity=1
      },
      proh/.style={
        draw=red!80!black, line width=0.8pt, rounded corners=2pt,
        pattern={Lines[angle=90,distance=2pt,line width=0.3pt]},
        pattern color=red!80!black, fill opacity=1
      },
      tick/.style={gray!60, line width=0.4pt}
    }

    % ==== Timelines ====
    % Gate
    \draw[thick,->] (0,\ygate) -- (24.8,\ygate);
    % Dashes every 2 hours
    \foreach \t in {0,2,...,24} {
      \draw[tick] (\t,\ygate-0.12) -- (\t,\ygate+0.12);
    }
    % Hour labels
    \foreach \t in {0,2,4,6,8,10,12,14,16,18,20,22,24} {
      \node[below=3pt, font=\scriptsize] at (\t,\ygate) {\t:00};
    }

    % Park
    \draw[thick,->] (0,\ypark) -- (24.8,\ypark);
    % Dashes every 2 hours
    \foreach \t in {0,2,...,24} {
      \draw[tick] (\t,\ypark-0.12) -- (\t,\ypark+0.12);
    }
    % Hour labels
    \foreach \t in {0,2,4,6,8,10,12,14,16,18,20,22,24} {
      \node[below=3pt, font=\scriptsize] at (\t,\ypark) {\t:00};
    }

    % Labels for each action
    \node[anchor=east, font=\large] at (-0.8,\ygate+1) {Timeline for $\delAtGate$};
    \node[anchor=east, font=\large] at (-0.8,\ypark+1) {Timeline for $\delAtPark$};

    % ==== Intervals ====
    % Gate: prohibitions [2,4], [8,24]; obligation [9,16]
    \def\GateProhSmallA{2} \def\GateProhSmallB{4}
    \def\GateProhA{8}      \def\GateProhB{24}
    \def\GateOblA{9}       \def\GateOblB{16}
    % Park: obligation [9,16]; prohibition [10,14]
    \def\ParkOblA{9}   \def\ParkOblB{16}
    \def\ParkProhA{10} \def\ParkProhB{14}

    % ===== Gate rectangles =====
    % Prohibitions (red vertical lines)
    \path[proh] (\GateProhSmallA,\ygate+\rectShift-\laneH/2)
      rectangle (\GateProhSmallB,\ygate+\rectShift+\laneH/2);
    \path[proh] (\GateProhA,\ygate+\rectShift-\laneH/2)
      rectangle (\GateProhB,\ygate+\rectShift+\laneH/2);
    % Obligation (blue diagonal lines)
    \path[obl]  (\GateOblA,\ygate+\rectShift+\offset-\laneH/2)
      rectangle (\GateOblB,\ygate+\rectShift+\offset+\laneH/2);

    % Labels
    \node[blue!80!black, font=\small,yshift=+0.2cm]
      at ({(\GateOblA+\GateOblB)/2},\ygate+\rectShift+\offset+\laneH/1.3) {Obligation (DC)};
    \node[red!80!black, font=\small,yshift=1.5cm,xshift=1.5cm]
      at ({(\GateProhA+\GateProhB)/2},\ygate+\rectShift-\laneH/1.3-\yshiftText) {Prohibition (MA)};
    \node[red!80!black, font=\small,yshift=+1.5cm]
      at ({(\GateProhSmallA+\GateProhSmallB)/2},\ygate+\rectShift-\laneH/1.3-\yshiftText) {Prohibition (MA)};

    % ===== Park rectangles =====
    % Prohibition (red vertical lines)
    \path[proh] (\ParkProhA,\ypark+\rectShift-\laneH/2)
      rectangle (\ParkProhB,\ypark+\rectShift+\laneH/2);
    % Obligation (blue diagonal lines)
    \path[obl]  (\ParkOblA,\ypark+\rectShift+\offset-\laneH/2)
      rectangle (\ParkOblB,\ypark+\rectShift+\offset+\laneH/2);

    % Labels
    \node[blue!80!black, font=\small,yshift=+0.2cm]
      at ({(\ParkOblA+\ParkOblB)/2},\ypark+\rectShift+\offset+\laneH/1.5) {Obligation (DC)};
    \node[red!80!black, font=\small,yshift=-0.3cm]
      at ({(\ParkProhA+\ParkProhB)/2},\ypark+\rectShift-\laneH/1.5-\yshiftText) {Prohibition (SR)};

    % ==== Legend ====
    \begin{scope}[shift={(0,-3.2)}]
      \node[draw, rounded corners=2pt,
            pattern={Lines[angle=45,distance=2pt,line width=0.4pt]},
            pattern color=blue!70!black,
            minimum height=6mm, minimum width=8mm] (legO) {};
      \node[right=1.5mm of legO] {Obligation};

      \node[draw, rounded corners=2pt,
            pattern={Lines[angle=90,distance=2pt,line width=0.4pt]},
            pattern color=red!80!black,
            minimum height=6mm, minimum width=8mm, right=40mm of legO] (legF) {};
      \node[right=1.5mm of legF] {Prohibition};
    \end{scope}

  \end{scope}
\end{tikzpicture}
\end{center}
\caption{Temporal view of the use case norms, depicting when for each action obligations and prohibitions are in force: delivery at parking ($\delAtPark$) and delivery at gate ($\delAtGate$). }
\label{conflictpict}
\end{figure}









Additionally, the agent's obligation on $\delAtGate$ and $\delAtPark$ (under $\DC$) is in fact a choice, so she must comply with at most one of them (we will represent this in our logic as a \emph{disjunction}). 

Lastly, note that the agent is subject to all three stipulated norms (\DC, \SR, \MA) and must comply with all of them. We will represent this in our logic as a \emph{conjunction}.

Let us now turn our attention to our notion of conflicts. In this paper, we analyze conflicts over time. A temporal conflict arises when two or more norms apply to the same entity within overlapping time intervals but impose \emph{contradictory or unrealistic requirements}. Unlike static conflicts, which exist regardless of time, temporal conflicts are dynamic and depend on how rules interact over time. We display in \ref{conflictpict} the graphical projection of the norms in the use case across a 24-hour timeline, emphasizing conflicts from an intuitive visual standpoint. 
To distinguish the types of normative constraints, we use a \textbf{color- and pattern-based scheme} combined with discrete hour markers:

\begin{itemize}
    \item \textbf{(Obligations)} — \textcolor{blue!80!black}{\textbf{Blue hatched rectangles}} represent intervals during which an action is \textbf{mandated} by a normative clause.  
    \begin{itemize}
        \item Example: the \textcolor{blue!80!black}{hatched blue band} above the timeline denotes an obligation to deliver at the parking location ($\delAtPark$) between \textbf{09{:}00–16{:}00}, as imposed by \DC.
    \end{itemize}

    \item \textbf{(Prohibitions)} — \textcolor{red!80!black}{\textbf{Red striped rectangles}} indicate intervals during which an action is \textbf{forbidden} by a normative clause.  
    \begin{itemize}
        \item Example: the \textcolor{red!80!black}{striped red band} below the timeline shows that deliveries at the parking location ($\delAtPark$) are prohibited between \textbf{10{:}00–14{:}00} under \SR.
    \end{itemize}

    \item \textbf{Conflicting time points} occur when \textbf{blue} and \textbf{red} rectangles overlap, meaning that an action is simultaneously \textbf{obligated} and \textbf{forbidden} at the same time points.  
    \begin{itemize}
        \item Example conflict (\DC vs.~\SR): the overlap between the blue and red bands on the timeline of $\delAtPark$ highlights the interval \textbf{10{:}00–14{:}00}, where the delivery is both required and prohibited.
    \end{itemize}
\end{itemize}
 
A second conflict (\DC vs.~\MA) appears on the timeline for action $\delAtGate$, where the obligation from \DC\ (09{:}00–16{:}00) coincides with the prohibitions from \MA\ (08{:}00–24{:}00). 
The conflict time points thus match precisely the obligation time points for on $\delAtGate$ under \DC, i.e: 09:00, 10:00, 11:00, 12:00, 13:00, and 14:00.

In our use case, %courts and regulators will apply 
the following principles may be applied to resolve conflicts:
\begin{itemize}
    \item \textbf{Priority of specific rules}: 
    The defined \textit{Maintenance Announcement} (\MA) for specific re-infrastructure repairs and the \textit{Safety Regulations} (\SR) for handling dangerous goods are likely to override broader \textit{Delivery Clause} (\DC) obligations. Consequently, the driver is not allowed to use the gate but has to comply with restricted parking times from the \textit{Safety Regulations}. 

    \item \textbf{Harmonization of norms}: 
    The obligation in the \textit{Delivery Clause} to deliver from 09:00 to 16:00 may be reinterpreted not to include the hours during which the \textit{Safety Regulations} prohibit activities. This way, the \textit{Delivery Clause} and the \textit{Safety Regulations} are complied with, and unreasonable outcomes are avoided.
    
    \item \textbf{Impossibility defense}: For the delivery at the gate, the prohibition from \textit{Maintenance Announcement} implies an objective impossibility, allowing the driver to argue discharge of obligation under doctrines such as \textit{force majeure} or \textit{frustration of purpose}. Compliance is still feasible for delivery at parking, so no such defense is applicable.
    \item \textbf{Hierarchy of norms}: If the \textit{Safety Regulations} and \textit{Maintenance Announcement} are regulatory mandates (public law), they override the private \textit{Delivery Clause} from the goods delivery contract under the principle \textit{publicum ius privatorum pactis mutari non potest} (“private agreements cannot alter public law”).
\end{itemize}

In practice, the driver has the option to adopt the following \textbf{practical strategy}:


\begin{enumerate}
     \item Avoid delivery at gate entirely: The prohibition from the \textit{Maintenance Announcement} between 08:00 to 24:00 makes gate deliveries impossible. 
    \item Schedule delivery at parking only during permitted times: The driver must choose to deliver to the parking area either between 09:00 and 10:00 or between 14:00 and 16:00 to comply with both the \textit{Delivery Clause} and the \textit{Safety Regulations}.
\end{enumerate}

In the following sections, we introduce the formal definitions and notations necessary to construct a logical language for analyzing potential normative conflicts. Building on this foundation, we develop a reasoning framework grounded in the syntax and semantics of the logic. This framework serves three key purposes:  to determine whether a viable strategy exists for complying with the normative specification; (ii) to formally identify conflicting time points where some norms from the normative system are incompatible; and (iii) to derive a refined version of the specification that eliminates such conflicts while preserving the normative intent, thereby providing the agent with a clear and streamlined formula to support its planning and reasoning. Throughout the paper, we illustrate these components using a running use case.

\section{The Micro Metric-Time  Normative Logic (\TDDLfm)}

Following the use case, our intuition suggests that a conflict manifests when an action is both required and prohibited at the same point in time. We refer to such a situation as a \emph{deontic conflict}.
%
Additionally, a second notion of conflict, called an \emph{ontic conflict}, arises when two distinct actions are required to occur at the same time, which is infeasible under the assumption that at most one action can occur at any time point.

The above explanation of conflict is based on intuition rather than formal grounds. To establish a formal definition, we first introduce a normative logic, reduced to the essential operators necessary for both modeling the key aspects of our use case and formalizing our notion of conflict.

We start by defining the micro metric-time normative logic (\TDDLfm), which can capture clauses of normative specifications and their combinations in terms of logical formulas. We first define the syntax and semantics of the logic. The logic is designed so that a formula defines a language containing those \timedwords satisfying it. As pointed out in the introduction, we establish how conflicts and the satisfiability of (sub) formulas correspond. To this end, we also study the satisfiability problem of \TDDLfm.

% \todo{ML: The following sentence is fine a PhD thesis but may be to much for paper. @Karam: Read and delete sentence and Todo..\\kk:I remove it and will put it in the disseration}
% Throughout this section, we motivate the choice of the semantic models and highlight our assumptions about those models.
% We first present its syntax and \timedword semantics. The \timedword semantics capture conditions to conclude that a \timedword satisfies formulas from the logic. Then, we proceed to a preliminary definition of conflicts we call \textit{potential conflicts}. Finally, we study the satisfiability problem of the logic, which concerns the existence of a \timedword that can satisfy a given formula. 
% To study the notion of normative conflicts, we introduce in this section the \emph{Micro Metric Time Normative logic}, written \TDDLfm,  where we present its syntax and semantics, and then study its satisfiability problem. 
% The main feature of this logic is to attach metric time constraints, expressed as sets of intervals, to deontic operators and actions.  
% \todo[inline]{What is a ``satisfiability problem''?\\
% KK: rewrote the whole introducing paragraph to incorporate a textual definition. }
%to be explained in the introduction.}
%\todo[inline]{There has to be ALWAYS at least one sentence between 3 and 3.1 etc.\\ KK: fixed.}}

\subsection{Syntax of \TDDLfm}
The \emph{micro metric-time normative logic} focuses on \emph{metric time}, where norms are equipped with canonical interval sets from $\domIS$ (Definition~\ref{def:canonis}) as timed constraints. A  formula $\phi$  within the logic is constructed by combining literals:
A literal (or atomic norm) is formed by three components, \begin{inparaenum}[(i)]
    \item a deontic operator that could be an obligation (O) or a prohibition (F),
    \item an action from $\Sigma$, and
    \item a set of intervals $\is$.
\end{inparaenum} 

The literal $\ob{\is}{a}$ intuitively indicates that  ``the agent has an obligation to perform action $\acta$ at least once within the interval set \is''. To avoid the well known procrastination effect, studied in \cite{DBLP:conf/deon/BroersenDDM04} and  \cite{DBLP:conf/prima/BoellaBT08},  we enforce that the specified set of intervals for obligations is not formed by an infinite interval, which enforces a clear deadline on the performance of the obliged action and avoids procrastination.
The literal $\forb{\is}{a}$ indicates ``the agent is prohibited from performing action $\acta$ at any time point from the interval set \is''. We do not impose the same constraint of a \emph{finite} deadline for prohibitions as a prohibition does not lead to any procrastination and additionally, some prohibitions, in practice, may be specified to start at some time point $k$ and last \emph{forever}, which could be specified by the interval set $\{[k,\infty]\}$.
The composition of literals is obtained by the \emph{Boolean operators}: conjunction (\(\sqcap\)) and disjunction (\(\sqcup\)).

% \todo[inline]{ML:Nice to know why it is called flat, but why it is called metric time normative??? \\
% KK: Fixed\\\\
% ML:Obligations and and prohibitions come as a surprise. This sutffe has to be rewritten!\\
% KK: dont know how to rewrite it \\
% GS: I rewrote it to let it more explicitely}

% An obligation is written $O$ and prohibition is written $F$. Unlike other metric time formalisms, we use sets of intervals to specify norms to increase the conciseness of formulas.

% \todo[inline]{we never ever define recursively but inductively!!! What is the difference? Induction start with induction basis and then one has induction steps. Always works. Recursion starts from the "top" and makes use of previous cases - and hopefully reaches a basis - recursion may not be well-defined. \\KK: right, fixed.}

% \todo[inline]{Reduced to non empty interval sets}
% \begin{definition}[Syntax of \TDDLfm] The syntax of \TDDLfm is defined inductively  as:
% \[
% \begin{array}{l@{\qquad}l@{\qquad}l@{\qquad}l}
% 	\phi  &::=& \ob{\is}{a} \mid \forb{\is}{a} \mid \phi \sqcup \phi\mid \phi \sqcap \phi \\
% 	%\phid &::=&  \ob{\is}{a} \mid \forb{\is}{a} \mid \phid \sqcup \phid\\
%     %\phir &::=& \monadop{P}{\is}{a}\\
% 	%a &~\in & \Sigma \\
% 	\is & \in& \domIS  \\
%  a & \in & \Sigma


 
% 	 %\tmin &~\in & \mathbb{N} \\
%  %\tmax &~\in & \mathbb{N}\cup{+\infty} \\
% \end{array}
% \]
% \end{definition}
% \todo{ML@Karam: Compare, understand - and use my definition ;) \\kk: we have to fix the set of action.}



\begin{definition}[Syntax of \TDDLfm] Given a set of actions $\Sigma$, the syntax of \TDDLfm formulas over $\Sigma$ is defined inductively via the following grammar: 
\[
	\phi  \quad ::= \quad  \ob{\is^*}{a} \mid \forb{\is}{a} \mid \phi \sqcup \phi\mid \phi \sqcap \phi 
\]
where $\is^*$ is an interval set formed by finite intervals ranging over elements of $\domIS$, $\is$ ranges over elements of $\domIS$, and $\acta$ ranges over $\Sigma$. When $\Sigma$ is clear from the context, we may omit it.
\end{definition}




\begin{example}\label{fexample}
%\todo{The use case is not motivating. An example is motivating. A use case is there and we consider it. We have been through this many times. Check and kill.\\KK:kill, I will check on the rest of the paper.}
To illustrate our logic, let us transform the textual representation of norms from our  
use case to formulas from \TDDLfm.
First, the Delivery Clause in Table~\ref{tab:contract}, where an agent can choose between delivering at the gate and delivering at the parking between 9:00 and 16:00,  and could be represented in \TDDLfm as:
$$\DC := \ob{\{[9,16]\}}{\delAtGate} \sqcup \ob{\{[9,16]\}}{\delAtPark}.$$
% 
The Safety Regulation norm from Table~\ref{tab:contract} prohibits the delivery of dangerous goods at the parking between 10:00 and 14:00, and could be expressed in \TDDLfm as follows:
$$\SR:= \forb{\{[10,14]\}}{\delAtPark}.$$
%
Lastly, the Maintenance Announcement in  Table~\ref{tab:ma}, prohibits the delivery at the gate between  2:00 and 04:00 and between 8:00 and 24:00, and could be written in our logic as follows:
$$\MA:=\forb{\{[2,4]\},\{[8,24]\}}{\delAtGate}.$$
%
%\todo[inline]{GS: Shouldn't the last one be $\MA:=\forb{\{[2,4]\},\{[8,24]\}}{\delAtGate}.$ (Why infinity?)\\ KK:Updated to 24 instead of infinity: kill}
%
Thus, our use case normative system would be represented as: $\UC := \DC \sqcap \SR \sqcap \MA$, resulting in:
$$\UC = \big(\ob{\{[9,16]\}}{\delAtGate} \sqcup \ob{\{[9,16]\}}{\delAtPark} \big) \sqcap \forb{\{[10,14]\}}{\delAtPark} \sqcap \forb{\{[2,4],[8,24]\}}{\delAtGate}.$$

\end{example}


We now introduce two syntactic metrics for formulas, starting with the size of a formula, which reflects the number of symbolic elements that must be stored in memory to reason about it.
\begin{definition}[Size of a \TDDLfm Formula]\label{def:size}
Let $\phi$ be a formula from \TDDLfm. The \emph{size} of the formula $\phi$ written as $\size{\phi}$ is defined inductively as:
\[
\size{\phi} = 
\begin{cases}
2 + 2 \times \card(\is) & \text{if } \phi = \ob{\is}{a} \text{ or } \phi = \forb{\is}{a}, \\
\size{\phi_1} + \size{\phi_2} + 1 & \text{if } \phi = \phi_1 \sqcap \phi_2 \text{ or } \phi = \phi_1 \sqcup \phi_2.
\end{cases}
\]
where $\card(\is)$ denotes the number of intervals in the set $\is$.
\end{definition}

The size of a literal obligation or prohibition is determined by: the obligation or prohibition symbol and the action name, which is a fixed length of two symbols; additionally, one has to keep two numeric bounds per interval from the interval set. Hence, the total size of a literal is given by $2 + 2 \times \size{\is}$. For the case $\phi_1\bowtie\phi_2$, where the boolean operator $\bowtie\in \{\sqcap, \sqcup\}$, the total size is given as the size of the boolean operator plus the size of both $\phi_1$ and $\phi_2$.


The next syntactic metric we define is called the \emph{duty measure}. It estimates the degree of duty a formula imposes on the agent. The measure is counting the number of obligation literals forming the formula.
\begin{definition}[Duty Measure for a \TDDLfm Formula]\label{def:obligation-count}
\label{def:obligation-count}
Let $\phi$ be a formula in \TDDLfm. The \emph{duty measure} $\phi$, denoted by $\eta(\phi)$, corresponds to the number of obligation literals forming the formula and is defined inductively as follows:
\[
\eta(\phi) = 
\begin{cases}
1 & \text{if } \phi = \ob{\is}{a}, \\
0 & \text{if } \phi = \forb{\is}{a}, \\
\eta(\phi_1) + \eta(\phi_2) & \text{if } \phi = \phi_1 \sqcap \phi_2 \text{ or } \phi = \phi_1 \sqcup \phi_2.
\end{cases}
\]
\end{definition}




\begin{example}[Size and Duty Measure for Example~\ref{fexample}]\label{sizeandeta}

We have $\UC := \DC \sqcap \SR \sqcap \MA$.
Applying the definitions for the size and duty measure we obtain:
\begin{itemize}
\item For $\DC:=\ob{\{[9,16]\}}{\delAtPark} \sqcup \ob{\{[9,16]\}}{\delAtPark}$, we have \\ $\size{\DC}= (2+2)+1+(2+2) = 9$ and $\eta(\DC)=2$.
\item For $\SR:= \forb{\{[10,14]\}}{\delAtPark}$, we have: $\size{\SR}= 4$ and $\eta(\SR):= 0$.
\item For $\MA:=  \forb{\{[2,4],[8,24]\}}{\delAtGate}$ we have $\size{\MA}=6 \nd \eta(\MA)=0$.
\end{itemize}
Thus, $\size{\UC}= \size{\DC}+1 +\size{\SR}+1+ \size{\MA}= 9+1+4+1+6=21$ and,\\
$\eta(\UC)= \eta(\DC)+\eta(\SR)+\eta(\MA)=2+0+0=2.$
\end{example}

\TDDLfm is labeled as micro because it is a simple logic that focuses solely on the deontic operators \emph{obligations} and \emph{prohibitions} and their combination using conjunction and disjunction. The logic lacks temporal operators, conditionals, and permission deontic operators, but it is enough to highlight our ideas on the notion of conflict.


\subsection{Semantics of \TDDLfm}
We adopt a trace-based semantics over finite timed words (Definition~\ref{timedwords}). This choice aligns directly with punctual, action-centric constraints: formulas are evaluated on sequences of timestamped actions, not on state valuations.

\paragraph{Why timed words rather than Kripke frames?}
We use timed words rather than Kripke frames to \emph{impose atomicity constraints}: \begin{inparaenum}[(i)]
    \item each event is instantaneous, \item timestamps are strictly increasing, and \item at most one action occurs at any time point act as \emph{built-in frame conditions} for our conflict definitions.
\end{inparaenum} This is in the same spirit in which Kripke justifies modal axioms (T, S4, S5) by imposing properties on the accessibility relation. Timed words can also be viewed as a highly restricted Kripke semantics: worlds are event indices $0,\dots,n$, the relation $R$ links each index to its immediate successor, and the labeling function is $L(i)=(a_i,t_i)$. Linearity, irreflexivity, and functional succession then hold by construction, which is why we work directly with timed words in what follows.



\paragraph{Timed word semantics \TDDLfm}\label{sec:semantics}

We adopt a trace-based interpretation over finite timed words. A formula constrains which action–time pairs may occur in a trace and how often. The satisfaction relation below is defined by structural induction.




\subsubsection{Timed words semantics}\label{semantics}
% \subsubsection{Timed Words Semantics}
\begin{definition}[Satisfaction relation]\label{semantics}
Given a finite \timedword $\tau \in \domtr$ and a formula $\phi$ from \TDDLfm, the satisfaction relation $\tau \dutysat \phi$ (read as``the \timedword $\tau$ satisfies the formula $\phi$'') is defined inductively on the structure of the formula $\phi$ as follows:
    \begin{align}
    \tau&\dutysat \ob{\is}{a}&&\text{ iff } \quad \quad  \exists t \subin \is: \rho(\tau,t) = \acta. \label{obis}\\
	\tau&\dutysat \forb{\is}{a}&&\text{ iff } \quad \quad  \forall t \subin \is: \rho(\tau,t) \neq \acta. \label{fis}\\
%	\tau&\dutysat \monadop{P}{\is}{a}&& \text{ undefined } \label{pis}\\
	\tau&\dutysat \phi \sqcup \phi'&&  \text{ iff }\quad \quad \tau \dutysat \phi \sor \tau \dutysat \phi'.\\
	\tau&\dutysat  \phi \sqcap \phi'&& \text{ iff }  \quad \quad\tau \dutysat \phi \nd \tau \dutysat \phi'.
\end{align}
\end{definition}

The semantics defines how to satisfy an obligation literal using the action lookup function $\rho$ (cf.\ Definition~\ref{defrho}), which requires that the obliged action has been performed at least once with the specified timed conditions.  Prohibition forbids any occurrence of the given action within the specified interval set. 
Conjunction ($\sqcap$) adds more duties, and disjunction ($\sqcup$) offers the agent the choice of one duty instead of another.



\begin{example}\label{example10}
 Consider the \timedword  $\tau:= \trace{ (\delAtGate,1) \ (\pickU,3) \ (\delAtPark,11)  }$. 
 %we study if it satisfies the composed norms of our motivating example defined in Example \ref{fexample}, $\DC \sqcap \SR \sqcap \MA$ :
 We show below that this \timedword does not satisfy the $\DC \sqcap \SR \sqcap \MA$ as specified in Example \ref{fexample}:
 \begin{itemize}
				\item $\trace{(\delAtGate,1) \ (\pickU,3) \ (\delAtPark,11) } \dutysat \ob{\{[9,16]\}}{\delAtPark} $ as the event $(\delAtPark,11)$ corresponds to timed condition of the obligation $11 \subin \{[9,16]\}$.
				\item $\trace{(\delAtGate,1) \ (\pickU,3) \ (\delAtPark,11) } \nvDash \forb{\{[10,14]\}}{\delAtPark} $ as the event $(\delAtPark,11)$ is a violation of the timed condition of the prohibition as $11 \subin \{[10,14]\}$.
				\item $\trace{(\delAtGate,1) \ (\pickU,3) \ (\delAtPark,11) } \dutysat \ob{[9,16]}{\delAtPark} \sqcup \ob{\{[9,16]\}}{\delAtGate}$.
 				\item $\trace{(\delAtGate,1) \ (\pickU,3) \ (\delAtPark,11) } \nvDash \forb{\{[10,14]\}}{\delAtPark} \sqcap \forb{\{[2,4],[8,24]\}}{\delAtGate} $.
                \item $\trace{(\delAtGate,1) \ (\pickU,3) \ (\delAtPark,11) } \nvDash \DC \sqcap \SR \sqcap \MA$.
\end{itemize}
\end{example}
\begin{remark}[Kinds of obligations and probihitions]
 Note that there are many different ways to capture the idea of obligation and prohibition in ways such as achievement and maintenance related to the timed interpretation as defined in \cite{broersen2004designing}, \cite{governatori2011justice}: Achievement refers to successfully achieving a task at least once before a specific deadline, like submitting a report on time. Once this task is accomplished, the achievement constraint is relieved. In contrast, maintenance involves consistently upholding a property over a specific \emph{period} of time. It is not enough to do it just once; it must be sustained over time.
 Our definition of obligation fits the definition of \emph{achievement obligations} from \cite{DBLP:conf/hicss/DignumK98}. 
Likewise, we understand our definition of prohibition as \emph{negative achievement} over a set of time points, despite its similarity with maintenance prohibition, as both require full coverage on the prohibited specified timed points. The key difference resides in the fact that the prohibited event must \emph{never} occur rather than maintaining a continuous state.
\end{remark}
\begin{remark}[On the absence of negation]
\TDDLfm is a \textit{positive logic}. We do not define negation for this logic. A \emph{straightforward}\footnote{This definition is used in other logics such as Linear Temporal Logic, Dyadic Deontic Logic,\dots } way to define the semantics of negation, where the syntax of a negated formula $\phi$ is written as $\lnot \phi$ and would be defined as follows:
$$\tau \dutysat \lnot \phi \text{ iff }  \tau \nvDash \phi. \label{niga}$$
By substituting $\phi$ by an obligation say $\ob \is a$, we obtain: 
\[\tau \dutysat \lnot \ob{\is}{a} \text{ iff }  \tau \nvDash \ob{\is}{a}.\]
When substituted by the semantics of an obligation, this reduces to :
\[\tau \dutysat \lnot \ob{\is}{a} \text{ iff }  \tau \nvDash \exists t \subin \is:  \rho(\tau,t)=\mathsf{a}.\]
We know that by negating the first order formula, the definition becomes:
\[\tau \dutysat \lnot \ob{\is}{a} \text{ iff }  \tau \vDash \forall t \subin \is:  \rho(\tau,t)\neq \mathsf{a}, \text{ iff } \tau \dutysat \forb{\is}{a}.\]
We obtain that the semantics of $\lnot \ob{\is}{a} $ matches the semantics of $\forb{\is}{a} $.
This is counter-intuitive to our understanding of obligation and prohibition:  not being obliged to perform an action \acta does not necessarily mean that performing \acta is forbidden. 

Another way of introducing negation could be at the level of actions. Although it could be tried to read the notation $\lnot a$ as a syntactic construction denoting the ``negation of action $\acta$'', doing so imposes a semantic flaw: actions differ from propositions by their very nature; as they denote occurrences, events, or behaviors; and therefore negating them means more than taking the logical complement. We refrain from specifying negation on the action as in other logics and other formal languages where actions are first-class citizens such as \cite{hoare1978communicating,harel2001dynamic,horty2001agency,de2013linear}. Therefore, we represent negative constraints by using explicit prohibition modalities (e.g., $\forb{\is}{a}$), which precisely express the intended normative requirements and temporal constraints. This distinguishes between ontological absence (an action not occurring) and deontic force (an action being forbidden), maintaining a clear distinction between event structure and norm interpretation.
\end{remark}



\subsubsection{Extensional semantics}
 Another perspective of word semantics is known as extensional semantics, in which a formula is interpreted to be a set of acceptable behaviors. In such semantics, also known as model enumeration, the semantics of a formula are given in terms of the finite timed words that are models of its specifications. Specifically, the semantics of a formula are given by the set of words that adhere to its normative requirements. Formally, the language of a formula $\phi$, denoted by $\dutyclass{\phi}$, is the set of all \timedwords that satisfy $\phi$. In planning or normative settings, this set contains all compliant execution plans, which concretely delineate the possible successful agent behaviors under the given normative specification.

\begin{definition}[Language of a Formula]\label{language}
The \defn{language} of a formula \(\phi\) from \TDDLfm written by
\(\dutyclass{\phi}\) is a set (which may be infinite) of finite \timedwords that satisfy the formula.  $$\dutyclass{\phi} := \{\tau \mid \tau \dutysat \phi\}.$$ 
\end{definition}
\begin{lemma} [Characterization of the Language of a Formula] \label{lemma:characdl}
Let \(\phi\) be a formula in \TDDLfm. The language of the formula, denoted \(\dutyclass{\phi}\), can be characterized as follows:
\begin{align*} \dutyclass{\ob{\is}{a}} &= \{\tau \mid \exists t : t \subin \is \text{ and } \rho(\tau,t)=\acta \} .\\ 
\dutyclass{\forb{\is}{a}} &= \{\tau \mid \forall t \subin \is: \rho(\tau,t)\neq \acta \}. \\ 
\dutyclass{\phi \sqcup \phi'} &= \dutyclass{\phi} \cup \dutyclass{\phi'} .\\ 
\dutyclass{\phi \sqcap \phi'} &= \dutyclass{\phi} \cap \dutyclass{\phi'}.
\end{align*} 
\end{lemma}

The language of a literal obligation is the set of \timedwords where the obligated action occurs at least once within the specified time interval. In contrast, the language of a literal prohibition includes the set of \timedwords where the prohibited action does not take place within the given time constraints specified in the interval set. The language of a disjunction $\phi \sqcup \phi'$ is the union of the languages of the individual formulas, and the language of a conjunction $\phi \sqcap \phi'$ is the intersection of their respective languages.

\subsection{Semantic Properties of \TDDLfm}

 In this subsection, we explain and analyze some specific semantic properties of \TDDLfm. Most of our discussion is concentrated on the influence of logical operators on formula satisfiability in the sense of how unsatisfiable ``parts'' of formulae influence compound expressions. We also examine how unsatisfiable components of a formula can be eliminated without altering its overall meaning. To achieve this, we define a representation of literals as combinations of more elementary ones.


We begin by stating the fundamental algebraic equivalence properties of the logical operators, namely: commutativity, associativity, and distributivity, presented in Lemma~\ref{lemma:operequiv}. Equivalence between two formulas $\phi \nd \phi'$ is written by $\phi \equiv \phi'$, when their duty classes are equal, i.e $\dutyclass{\phi}= \dutyclass{\phi'}$. They are identical to those in classical logic and other standard logical systems. These properties play a crucial role in reducing representations to normal forms, which in effect facilitates the detection of unsatisfiable sub-formulas and enables systematic reasoning regarding the inconsistencies of a specification.

\begin{lemma}[Algebraic Equivalences of \TDDLfm Operators] \label{lemma:operequiv}
Let $\phi_1, \phi_2, \phi_3$ be formulas in \TDDLfm. Then the following equivalences hold:
\begin{align*}
    \phi_1 \sqcup \phi_2 &\dutyequiv \phi_2 \sqcup \phi_1 && \text{(\textbf{Comm1})} \\
    \phi_1 \sqcap \phi_2 &\dutyequiv \phi_2 \sqcap \phi_1 && \text{(\textbf{Comm2})} \\
    \phi_1 \sqcup (\phi_2 \sqcup \phi_3) &\dutyequiv (\phi_1 \sqcup \phi_2) \sqcup \phi_3 && \text{(\textbf{Assoc1})} \\
    \phi_1 \sqcap (\phi_2 \sqcap \phi_3) &\dutyequiv (\phi_1 \sqcap \phi_2) \sqcap \phi_3 && \text{(\textbf{Assoc2})} \\
    \phi_1 \sqcap (\phi_2 \sqcup \phi_3) &\dutyequiv (\phi_1 \sqcap \phi_2) \sqcup (\phi_1 \sqcap \phi_3) && \text{(\textbf{Distr1})} \\
    \phi_1 \sqcup (\phi_2 \sqcap \phi_3) &\dutyequiv (\phi_1 \sqcup \phi_2) \sqcap (\phi_1 \sqcup \phi_3) && \text{(\textbf{Distr2})}
\end{align*}
\end{lemma}

\begin{proof}
The proof follows from the Lemma~\ref{lemma:characdl}, recall that $\phi \dutyequiv \phi'$ if and only if $\dutyclass{\phi} = \dutyclass{\phi'}$. We proceed case by case:

\begin{itemize}
    \item \textbf{(Comm1)} and \textbf{(Comm2)}: Follows from the fact that set union and intersection are commutative operations:
    \[
    \dutyclass{\phi_1 \sqcup \phi_2} = \dutyclass{\phi_1} \cup \dutyclass{\phi_2} = \dutyclass{\phi_2} \cup \dutyclass{\phi_1} = \dutyclass{\phi_2 \sqcup \phi_1}.
    \]

      \item \textbf{(Assoc1)} and \textbf{(Assoc2)}: These follow from associativity of union and intersection over sets:
    \[
    \dutyclass{\phi_1 \sqcup (\phi_2 \sqcup \phi_3)} = \dutyclass{\phi_1} \cup (\dutyclass{\phi_2} \cup \dutyclass{\phi_3}) = (\dutyclass{\phi_1} \cup \dutyclass{\phi_2}) \cup \dutyclass{\phi_3} = \dutyclass{(\phi_1 \sqcup \phi_2) \sqcup \phi_3}.
    \]

    \item \textbf{(Distr1)}: Distributivity of intersection over union:
    \[
\begin{aligned}
\dutyclass{\phi_1 \sqcap (\phi_2 \sqcup \phi_3)}
&= \dutyclass{\phi_1} \cap (\dutyclass{\phi_2} \cup \dutyclass{\phi_3}) \\
&= (\dutyclass{\phi_1} \cap \dutyclass{\phi_2}) \cup (\dutyclass{\phi_1} \cap \dutyclass{\phi_3}) \\
&= \dutyclass{(\phi_1 \sqcap \phi_2) \sqcup (\phi_1 \sqcap \phi_3)} .
\end{aligned}
\]

    \item \textbf{(Distr2)}: Distributivity of union over intersection:
    \[
\begin{aligned}
\dutyclass{\phi_1 \sqcup (\phi_2 \sqcap \phi_3)}
&= \dutyclass{\phi_1} \cup (\dutyclass{\phi_2} \cap \dutyclass{\phi_3}) \\
&= (\dutyclass{\phi_1} \cup \dutyclass{\phi_2}) \cap (\dutyclass{\phi_1} \cup \dutyclass{\phi_3}) \\
&= \dutyclass{(\phi_1 \sqcup \phi_2) \sqcap (\phi_1 \sqcup \phi_3)} .
\end{aligned}
\]
\end{itemize}
Hence, in all cases and by operations on duty language, the left-hand side and the right-hand side formulas denote the same set of acceptable timed words. Thus, the formulas are semantically equivalent.
\end{proof}

We study now some normal forms. The term \emph{normal form}, in the context of formulas of logic, is commonly used to
indicate that a formula has certain syntactic properties. We recall the two known normal forms on the alternation between conjunctions and disjunctions. 
%as in \cite{kroening2008decision}.[ to do before]
%[dijunction vs disjunctive]
\begin{definition}[Conjunction Normal Form (\cnf)]
A \emph{clause} is a disjunction of literals.
  A formula $\phi$ is in \emph{conjunctive normal form}, short $\cnf$, if it is a conjunction of clauses:
  
  $$\phi \text{ is } \cnf \text{ if and only if}~\phi:= \bigsqcap_{i}\Big( \bigsqcup_{j} \ell_{i,j} \Big).  $$

%Where $\ell_{i,j}$ is the j-th literal in the i-th clause.
\end{definition}

Note that a formula in $\cnf$ can contain zero conjunctions and/or zero disjunctions per clause, but the order of alternation must be a disjunction of conjunctions of literals.

\begin{definition}[Disjunctive Normal Form (\dnf)]\label{def:dnf}
A \emph{product term} is a conjunction of literals.
    A formula $\phi$ is in \emph{disjunctive normal form}, short $\dnf$, if it is a disjunction of product terms:
$$\phi \text{ is } \dnf \text{ if and only if }\phi:= \bigsqcup_{i} \Big(\bigsqcap_{j} \ell_{i,j}\Big).  $$

%Where $\ell_{i,j}$ is the j-th literal in the i-th product term (a product term is a conjunction of literals).
\end{definition}

 Note that a formula in $\dnf$ can contain zero conjunctions and/or zero disjunctions per product term, but the order of alternation must be a disjunction of conjunctions of literals.
 
\begin{example}\label{example nnf}
Let us recall parts of our use case and check if they are in  \cnf and/or \dnf.
\begin{enumerate}
\item As $\SR= \forb{\{[10,14]\}}{\delAtPark}$, and according to our definition $\SR$ is both in \cnf and \dnf as the formula contains zero conjunctions and zero disjunctions. The same applies for $\MA=\forb{\{[2,4]\},\{[8,24]\}}{\delAtGate}.$

\item As $\DC = \ob{\{[9,16]\}}{\delAtGate} \sqcup \ob{\{[9,16]\}}{\delAtPark}$ and according to our definitions, $\DC$ is in \dnf as two terms formed by one literal and is also is in \cnf formed by one clause of two literals.

\item For the overall use case, we have $\UC= \DC \sqcap \SR \sqcap \MA$.$\UC$ is in \cnf as a 3-clause conjunction where the first is formed by two literal obligations and the two remaining clauses are formed by single literals. The formula is not in \dnf as the order of alternation of conjunction and disjunction does not match the pattern description of the format.
\end{enumerate}
\end{example}

We saw that the overall use case is not in \dnf. We proceed now to show that any formula from \TDDLfm could be normalized to \dnf. Additionally, we prove some properties of the formula resulting from normalization.
\begin{lemma}[Normalization to \dnf]
\label{lem:dnf}
For every formula \(\phi \in \TDDLfm\), there exists a \(\phi'\in \TDDLfm\) such that:
\begin{enumerate}[(i)]
\item   $\phi' \dutyequiv \phi$,
\item $ \phi' \text{ is in } \dnf$,
    \item \(\eta(\phi) \leq \eta(\phi')\), and
    \item for \(\phi' := \bigsqcup \phi_i'\), each $\phi'_i$ satisfies \(\eta(\phi_i') \leq \eta(\phi)\).
\end{enumerate}
\end{lemma}

\begin{proof}
The construction proceeds by systematically applying the distributivity equivalence from Lemma~\ref{lemma:operequiv}, specifically:
\[
\phi_1 \sqcap (\phi_2 \sqcup \phi_3) \dutyequiv (\phi_1 \sqcap \phi_2) \sqcup (\phi_1 \sqcap \phi_3) \quad \text{(\textbf{Distr1})},
\]
which we orient into the rewriting rule:
\[
\phi_1 \sqcap (\phi_2 \sqcup \phi_3) \to (\phi_1 \sqcap \phi_2) \sqcup (\phi_1 \sqcap \phi_3)\quad \text{(\textbf{Distr1L})}.
\]

Starting from \(\phi\), we repeatedly apply this rule to push disjunctions outward and distribute conjunctions inward. This process terminates with a formula \(\phi'\) that is disjunctive normal form (\dnf), thus establishing $(ii)$. Equivalence is preserved at each rewriting step, which establishes $(i)$.

For $(iii)$, consider the effect of applying the distributivity rule:
\[
\phi_1 \sqcap (\phi_2 \sqcup \phi_3) \to (\phi_1 \sqcap \phi_2) \sqcup (\phi_1 \sqcap \phi_3).
\]
Let us compare the number of obligations measured by the $\eta$ function. We have, by the definition of the function: 
\[
 \eta((\phi_1 \sqcap \phi_2) \sqcup (\phi_1 \sqcap \phi_3))= 2\times \eta(\phi_1) + \eta(\phi_2) + \eta(\phi_3),
\]
and  \[\eta(\phi_1 \sqcap (\phi_2 \sqcup \phi_3))= \eta(\phi_1) + \eta (\phi_2)  + \eta (\phi_3).\]
This shows that distributing a conjunction over a disjunction results in a duplication of $\phi_1$, effectively doubling the number of obligation literals it contributes. As such, each application of the distributivity rule can increase the total number of obligation literals in the formula. 

When applied recursively,  over nested conjunctions or disjunctions, this process propagates duplication and can cause an exponential growth in the number of obligation literals. Therefore, this justifies the inequality:
$\eta(\phi) \leq \eta(\phi'),$
which captures the potential syntactic blow-up caused by structural rewriting.


For $(iv)$, we refine the reasoning to show that each disjunct in the resulting formula contains no more obligation literals than the original formula.

Suppose the normalized formula $\phi' = \bigsqcup \phi_i'$ is obtained from $\phi$ by repeated application of the distributivity rule:
\[
\phi_1 \sqcap (\phi_2 \sqcup \phi_3) \to (\phi_1 \sqcap \phi_2) \sqcup (\phi_1 \sqcap \phi_3).
\]
Each $\phi_i'$ is thus a conjunction of subformulas that results from one of the paths taken during the distributive unfolding. For instance, from the rule above, we know:
\[
\eta((\phi_1 \sqcap \phi_2)) = \eta(\phi_1) + \eta(\phi_2),
\]
and similarly for $\phi_1 \sqcap \phi_3$. Therefore, in the resulting disjunction:
\[
\phi' = (\phi_1 \sqcap \phi_2) \sqcup (\phi_1 \sqcap \phi_3),
\]
we have two disjuncts, each of which contains at most $\eta(\phi_1) + \eta(\phi_2)$ or $\eta(\phi_1) + \eta(\phi_3)$ obligation literals, respectively. Which are both less or equal than $\eta(\phi_1) +\eta(\phi_2)+ \eta(\phi_3)$ from the original formula.

Critically, although the total size $\eta(\phi')$ may increase (due to duplication), each individual disjunct $\phi_i'$ comes from a single branch of the distributive rewriting and does not aggregate all duplicated parts. Thus, for every $i$:
\[
\eta(\phi_i') \leq \eta(\phi),
\]
Because the rewriting step does not introduce new literals, it only pushes existing ones. This ensures that no disjunct grows beyond the syntactic size of the original formula, even if the whole disjunction becomes longer after a certain number of iterations. This observation supports point $(iv)$.

\end{proof}

\begin{example}[\dnf normalization of $\UC$]
We continue with Example~\ref{example nnf}, and demonstrate the normalization of $\UC$. Using the first distributivity law once, we obtain:
$\UC' \dutyequiv \UC$,
where $\UC'$ is in \dnf.
$\text{Consider: } 
\UC_1' := \ob{\{[9,16]\}}{\delAtGate} \sqcap \SR \sqcap \MA, 
\UC_2' := \ob{\{[9,16]\}}{\delAtPark} \sqcap \SR \sqcap \MA.$
Then:
$\UC' := \UC_1' \sqcup \UC_2'.$
$\UC'$ is in \dnf and equivalent to $\DC \sqcap \SR \sqcap \MA$, with:
$\eta(\UC) \leq \eta(\UC')$ and $\eta(\UC_i') \leq \eta(\UC)$ for each $i = 1, 2$.
\end{example}


We now turn to a second normal form aimed at refining the temporal granularity of formulas. Lemma~\ref{lemma:literal-compression} introduces two equivalences for \emph{literal compression}: the first, $\textbf{ObDis}$, shows that obligation literals referring to the same action are disjunction-composable; the second, $\textbf{FConj}$, captures the analogous property for prohibition literals under conjunction.

\begin{lemma}[Literal Compression Equivalences]  
\label{lemma:literal-compression}  
Let $\is$ and $\is'$ be interval sets, and let $\acta$ be an action. Then the following equivalences hold in \TDDLfm:
\begin{align*}
\ob{\is}{a} \sqcup \ob{\is'}{a} &\dutyequiv \ob{\is \cup \is'}{a} && \text{\textbf{(ObDis)}} \\
\forb{\is}{a} \sqcap \forb{\is'}{a} &\dutyequiv \forb{\is \cup \is'}{a} && \text{\textbf{(FConj)}}
\end{align*}
\end{lemma}

\begin{proof}
Both equivalences follow from the extensional semantics of \TDDLfm, where disjunction corresponds to set union, conjunction to set intersection, and the obligation and prohibition literals are interpreted respectively via existential and universal quantification over time points in their interval sets.

\textbf{(ObDis)}  
\begin{align*}
\dutyclass{\ob{\is}{a} \sqcup \ob{\is'}{a}} 
&= \dutyclass{\ob{\is}{a}} \cup \dutyclass{\ob{\is'}{a}} \\
&= \{\tau \mid \exists t \subin \is : \rho(\tau,t) = a \} \cup \{\tau \mid \exists t \subin \is' : \rho(\tau,t) = a \} \\
&= \{\tau \mid \exists t \subin (\is \cup \is') : \rho(\tau,t) = a \} 
\quad \text{(by distributivity of $\exists$)} \\
&= \dutyclass{\ob{\is \cup \is'}{a}}
\end{align*}

\textbf{(FConj)}  
\begin{align*}
\dutyclass{\forb{\is}{a} \sqcap \forb{\is'}{a}} 
&= \dutyclass{\forb{\is}{a}} \cap \dutyclass{\forb{\is'}{a}} \\
&= \{\tau \mid \forall t \subin \is : \rho(\tau,t) \neq a \} \cap \{\tau \mid \forall t \subin \is' : \rho(\tau,t) \neq a \} \\
&= \{\tau \mid \forall t \subin (\is \cup \is') : \rho(\tau,t) \neq a \} 
\quad \text{(by merging universal quantifiers)} \\
&= \dutyclass{\forb{\is \cup \is'}{a}}
\end{align*}
\end{proof}


\begin{example}
These rules can be illustrated on concrete literals drawn from our use case:
\begin{itemize}
\item \textbf{ObDis}: $\ob{\{[9,10]\}}{\delAtGate} \sqcup \ob{\{[11,16]\}}{\delAtGate} \dutyequiv \ob{\{[9,16]\}}{\delAtGate}$,
\item \textbf{FConj}: $\forb{\{[2,4]\}}{\delAtGate} \sqcap \forb{\{[8,24]\}}{\delAtGate} \dutyequiv \forb{\{[2,4],[8,24]\}}{\delAtGate}$.
\end{itemize}
\end{example}


Conjunctions of obligations over overlapping interval sets often mask implicit structural distinctions in how normative requirements are distributed over time. In particular, when two obligations refer to the same action but cover different, partially overlapping time scopes, it becomes useful to isolate the common part from the non-overlapping remainders. 
The following lemma formalizes the idea that two obligations on the same action over overlapping interval sets can be achieved by performing the action once within the overlapping time points.
\begin{lemma}[Obligation Conjunction Decomposition]\label{lemma:OBConj}
Let $\is$ and $\is'$ be two overlapping and not equal interval sets. Then the conjunction of two obligations over the same action $\acta$ can be decomposed into the disjunction of:
\begin{enumerate}
\item an obligation over the overlapping interval set $\is \cap \is'$, and
\item the conjunction of the remaining obligations over the non-overlapping parts of $\is$ and $\is'$.
\end{enumerate}
Formally:
\[
\frac{
  \is \cap \is' \neq \emptyset \quad \text{and} \quad \is' \neq \is
}{
  \ob{\is}{a} \sqcap \ob{\is'}{a} \dutyequiv \ob{\is \cap \is'}{a} \sqcup \left( \ob{\is \ominus (\is \cap \is')}{a} \sqcap \ob{\is' \ominus (\is \cap \is')}{a} \right)
}\textsc{(ObConj)}
\]
\end{lemma}


\begin{proof}[Proof sketch]
The obligation $\ob{\is}{a}$ requires action $\acta$ over all intervals in $\is$. Given that both $\ob{\is}{a}$ and $\ob{\is'}{a}$ are asserted, the effect is to require $\acta$ over the union $\is \cup \is'$. This can be decomposed into:
\begin{itemize}
    \item an obligation over the shared intervals $\is \cap \is'$, and
    \item a conjunction of obligations over the remaining, non-overlapping parts of each interval set: $\is \ominus (\is \cap \is')$ and $\is' \ominus (\is \cap \is')$.
\end{itemize}
\end{proof}
\begin{example}[Obligation Conjunction Decomposition]
Let:
$
\ob{\{[1,3],[5,7]\}}{a} \sqcap \ob{\{[2,4],[6,8]\}}{a}.
$
By Lemma~\ref{lemma:OBConj}, the formula is equivalent to:
\[
\ob{\{[2,3],[6,7]\}}{a} \sqcup \left( \ob{\{[1,1],[5,5]\}}{a} \sqcap \ob{\{[4,4],[8,8]\}}{a} \right).
\]

\noindent\textbf{Single event trace model:}

The single event trace $\tau:= \trace{(a,2)}$ satisfies both the original conjunction and the decomposition, as it performs $\acta$ at  $t \in \is \cap \is'$.
\end{example}

\begin{lemma}[Prohibition Disjunction Decomposition]\label{redunprohib}
Let $\is, \is'$ be interval sets such that $\is \subseteq \is'$. Then the disjunction of two prohibitions over the same action $\acta$ can be rewritten as:
\[
\frac{
  \is \subseteq \is'
}{
  \forb{\is}{a} \sqcup \forb{\is'}{a} \dutyequiv \forb{\is}{a}
}
\quad \textsc{(ProhibDisj)}
\]
\end{lemma}

\begin{proof}
We reason using the semantics of prohibition in \TDDLfm. A prohibition $\forb{\is}{a}$ means that the action $\acta$ is forbidden at all time points in $\is$.

\begin{itemize}
    \item The disjunction $\forb{\is}{a} \sqcup \forb{\is'}{a}$ holds whenever at least one of the two prohibitions holds.
    \item Since $\is \subseteq \is'$, if $\forb{\is'}{a}$ holds, then so does $\forb{\is}{a}$.
    \item Thus, in every model where the disjunction holds, $\forb{\is}{a}$ also holds.
    \item Conversely, if $\forb{\is}{a}$ holds, then the disjunction holds trivially.
\end{itemize}

Therefore, both formulas are semantically equivalent:
\[
\forb{\is}{a} \sqcup \forb{\is'}{a} \equiv \forb{\is}{a}.
\]
\end{proof}

\begin{example}
Let: $\is = \{[2,4]\}, \quad \is' = \{[2,4], [5,6]\}.$

Since $\is \subseteq \is'$, the prohibition disjunction simplifies as:
\[
\forb{\{[2,4]\}}{a} \sqcup \forb{\{[2,4],[5,6]\}}{a} \dutyequiv \forb{\{[2,4]\}}{a}.
\]
This reflects the fact that the disjunction does not weaken the prohibition, since the smaller set $\is$ is already sufficient to capture the intended restriction on $\acta$.
\end{example}

When specifying time-dependent norms, the choice of how to represent temporal constraints can significantly impact the syntactic size and readability of a formula. While punctual representations (i.e., using single time points) offer the finest granularity, they often lead to verbose encodings, especially when applied to longer durations or non-unifiable intervals. Conversely, more structured representations, such as intervals or sets of intervals, can convey the same semantics far more succinctly. This syntactic economy becomes especially valuable when reasoning over large normative systems or when transforming formulas into normal forms. The following remark highlights this advantage of conciseness.

\begin{remark}[Conciseness of Interval Sets in Literal Representation]
\label{obs:interval-conciseness}

The way literals represent time constraints has a significant impact on the overall size and readability of formulas. Thanks to the compression equivalences (\textbf{ObDis}) and (\textbf{FConj}) in Lemma~\ref{lemma:literal-compression}, multiple intervals involving the same action can be merged into a single literal whose interval set is a union of the original intervals. This reduces the syntactic overhead and improves overall readability, which facilitates the subjects of the normative system to get a more straightforward interpretation.

Consider, for example, the literal $\forb{{[2,4],[8,24]}}{\delAtGate}$, which expresses a prohibition over two time ranges. As shown in Table~\ref{table:ma-conciseness}, this specification can be written in multiple ways—with varying levels of granularity. We compare three syntactic alternatives: using single time points, using individual intervals, and using a set of intervals. The table highlights that the interval set representation is by far the most concise, requiring fewer symbols to express the same semantics.

\end{remark}

This observation reinforces the value of using interval sets in their compact form, without decomposing them into punctual intervals unless required (e.g., during bounded normalization). This strategy preserves expressiveness while minimizing the computational and notational footprint.

\begin{table}[h]
\centering
\begin{tabular}{|c|l|c|}
\hline
\textbf{Representation} & \textbf{Formula (expressing \MA)} & \textbf{Size} \\
\hline
\textbf{Single time points} & 
$\displaystyle \bigsqcap_{i \in \{2,3,4,8,\dots,24\}} \forb{\{[i,i]\}}{\delAtGate}$ & 99 \\
\hline
\textbf{Intervals} & 
$\forb{\{[2,4]\}}{\delAtGate} \sqcap \forb{\{[8,24]\}}{\delAtGate}$ & 9 \\
\hline
\textbf{Interval sets} & 
$\forb{\{[2,4],[8,24]\}}{\delAtGate}$ & 6 \\
\hline
\end{tabular}
\caption{Conciseness comparison for  $\MA := \forb{\{[2,4]\},\{[8,24]\}}{\delAtGate}$}
\label{table:ma-conciseness}
\end{table}

These considerations conclude our overview of the semantic behavior of logical operators and the structural properties of literals. The equivalences we have introduced provide essential tools for formula normalization and simplification, laying the foundation for constructive reasoning about satisfiability and conflict.

\subsection{The Satisfiability Problem in \TDDLfm}
The satisfiability problem plays a central role in assessing whether a timed normative specification is operationally meaningful. Before analyzing conflicts, we must first determine whether a formula admits at least one compliant execution trace. In the context of \TDDLfm, satisfiability captures the fundamental feasibility of fulfilling all obligations while respecting all prohibitions under metric time constraints.

This subsection formalizes the satisfiability problem for our logic. We establish a tight bound on the size of witnessing timed words, position the problem within classical complexity theory, demonstrate the resolution procedure as well as its implementation, and introduce rules for composition with unsatisfiable formulas. These results provide the computational foundation for the subsequent conflict analysis, ensuring that the relationship between satisfiability and conflict is well-defined.
\subsubsection{Definition and complexity}
We define the unsatisfiability problem in a classical way for model basic logics where unsatisfiability relates to the inexistance of a trace satisfying a formula. 
\begin{definition}[Satisfiability]\label{def:sat}
    A formula $\phi$ is \defn{satisfiable}, \emph{sat} for short, if and only if there exists a \timedword $\tau$ that  satisfies $\phi$:
    \[
    \phi \text{ is } \sat \text{ iff } \exists \tau : \tau \dutysat \phi.
    \]
A formula is \defn{unsatisfiable} written \unsat if and only if the formula is not satisfiable.
\end{definition}

Another possible condition for satisfiability is that the language of the formula is non-empty.
\begin{remark}[Satisfiability as language definition]
 A formula $\phi$ is satisfiable if and only if the language of $\phi$ is not empty: 
$$\phi \text{ is } \sat \text{ iff } \dutyclass{\phi}\neq \emptyset.$$
\end{remark}
Now we study the relation between the size of a  \emph{minimal satisfying trace} in terms of the structure of the formula, more precisely to its duty measure as defined in Definition~\ref{def:obligation-count}.
\begin{lemma}[Satisfiability Size Bound]\label{numberofob}
    For any formula $\phi$ from \TDDLfm, if $\phi$ is satisfiable then there exists a  \timedword $\tau$ with at most $\eta(\phi)$ events that satisfies $\phi$:
    \[
\text{if } \phi \text{ is } \sat \text{ then } \exists \tau : \size{\tau} \leq \eta(\phi) \wedge \tau \dutysat \phi.
    \]
\end{lemma}
This lemma ensures that a finite search space is sufficient for checking satisfiability, which impacts the complexity class we study later on.

 \begin{proof}
	By Lemma~\ref{lem:dnf}, we know that any formula $\phi$ can be rewritten as a disjunction of conjunctions of literals:
    \[
        \phi \equiv \bigsqcup_{i=1}^n \phi_i.
    \]
    with every disjunction clause $\phi_i:= \bigsqcap_{j=1}^{m_i} \ell_j$ where each literal $\ell_{j}$ is either an obligation $\ob{\is}{a}$ or a prohibition $\forb{\is}{a}$. If $\phi$ is satisfiable, then at least one disjunction clause (i.e., one conjunction of literals) is satisfiable. 

    Each clause $\phi_i$ can be rearranged into a conjunction of obligation literals and a conjunction of prohibition literals. We refer to $\mathcal{F}$ as the conjunction of prohibition literals.
    \[
        \phi_i \equiv \ob{\is_1}{a_1}\sqcap \dots \sqcap\ob{\is_n}{a_n}\sqcap
         \underbrace{\forb{\is'_1}{b_1}\sqcap \dots\sqcap \forb{\is'_m}{b_m}}_{\mathcal{F}}.
    \]

   

    By definition, we know that for any obligation $\ob{\is}{a}$, a single event trace $(a,t)$ with  $t \subin \is$ is enough to satisfy the formula:
    \[
        \forall a, \is: \quad \text{ if }t \subin \is \text{ then } \trace{(a,t)} \dutysat \ob{\is}{a}.
    \]

We proceed now to reason about the $\phi_i$, assuming that $\phi_i$ is satisfiable, then $\exists \tau: \tau \dutysat \phi_i$. We know that for every obligation, there exists at least one event in the \timedword satisfying each obligation without violating any prohibition from the set of prohibitions. formally:


\[
\begin{aligned}
\exists (a_1, t_1), \dots, (a_n, t_n) \ : \ 
\forall i \in [1, n] \quad
& (a_i, t_i) \dutysat \ob{\is_i}{a_i} \\
& \nd \ \exists j \leq |\tau| : \tau(j) = (a_i, t_i) \\
& \nd \ (a_i, t_i) \dutysat \mathcal{F}.
\end{aligned}
\]

The number of these \emph{necessary events} is bounded by the number of obligations in the clause, that is, by $\eta(\phi_i)$. Moreover, since these events are part of a timed word, they must occur at distinct timestamps. Therefore, one can construct a timed word $\tau' \dutysat \phi$ consisting solely of those events, with $\size{\tau'} = \eta(\phi_i)$. From Lemma~\ref{lem:dnf}, we also have that $\eta(\phi_i) \leq \eta(\phi)$, since $\phi_i$ is a clause in the \dnf normalization of $\phi$.
    
\end{proof}

\begin{theorem}\label{is NP-complete}
    The satisfiability problem of \TDDLfm is $\mathsf{NP}$-complete w.r.t the size of the formula $\phi$.\label{lem:sat}
\end{theorem}
\begin{proofsketch}
    We prove this result in two parts: (1) the satisfiability problem for \TDDLfm is in NP, and (2) it is NP-hard.

   
    \textbf{NP Membership:} Given the bound $\eta(\phi)$, one can non-deterministically guess a candidate \timedword $\tau$ of size at most $\eta(\phi)$ and verify whether it satisfies the formula in time polynomial with respect to $\size{\phi} \times \eta(\phi)$. Specifically, the verification step must, for each event in the \timedword, check whether its timestamp falls within each of the intervals comprising the interval sets of the literals. Algorithm~\ref{fig:sat-procedure} presents the procedure \checksat, which performs this verification recursively for formulas from $\TDDLfm$. For obligation and prohibition literals, the nested loops in the algorithm reflect this complexity: the formula size is determined by the number of intervals across all literals, while the size of the \timedword is bounded by the number of obligation literals.
\begin{figure}[h]
\begin{minipage}{0.9\textwidth}
\begin{algorithm}[H]
\caption{Procedure \checksat }
\label{fig:sat-procedure}
\KwIn{A \(\TDDLfm\) formula \(\phi\) and a \timedword $\tau$}
\KwOut{True if $\tau \dutysat \phi$, False otherwise}
    \Switch{\(\phi\)}{
        \Case{\(\ob{\is}{a}\)}{
            \ForEach{\([\tmini,\tmaxi] \in \is\)}{
             \ForEach{\((\acta_i,t_i)\) from $\tau$}{
                \If {\(\acta_i = \acta \text{ and } \tmini \leq t_i\leq_\infty \tmaxi\)}
                 {\Return True}
            }
            }
            \Return False
        }
         \Case{\(\forb{\is}{a}\)}{
            \ForEach{\([\tmini,\tmaxi] \in \is\)}{
             \ForEach{\((\acta_i,t_i)\) from $\tau$}{
                \If {\(\acta_i = \acta \text{ and } \leq t_i\leq \)}
                 {\Return False}
            }
            }
            \Return True
        }
        \Case{\(\phi_1\sqcap\phi_2\)}{
           
        \Return $\checksat(\phi_1, \tau) \wedge \checksat(\phi_2,\tau)$
        
           
        }
         \Case{\(\phi_1\sqcup\phi_2\)}{
           
        \Return $\checksat(\phi_1,\tau) \vee \checksat(\phi_2,\tau)$
        
           
        }  
    }
\end{algorithm}
\end{minipage}
\end{figure}

\textbf{NP-hardness:} We establish NP-hardness by reducing an arbitrary instance of the 3-SAT problem to an instance of \TDDLfm involving time-stamped obligations and prohibitions. The 3-SAT problem involves studying the satisfiability of a Boolean formula in CNF form, where each clause is formed by 3 literals. We suggest an encoding of the problem into the logic as follows: each propositional literal is encoded as a literal from \TDDLfm on a generic and unique action symbol \acta, with distinct time points used to differentiate propositional variables. A positive literal (e.g., $x_i$) is represented as an obligation requiring \acta to occur at a specific time point (e.g., time $i$) to result on $\ob{\{[i,i]\}}{a}$, while a negative literal (e.g., $\lnot x_i$) is encoded as a prohibition of \acta at the same time point used for its corresponding positive literal, say $\forb{\{[i,i]\}}{a}$. The logical structure of the original 3-SAT formula is preserved through the use of the $\sqcup$ (disjunction) and $\sqcap$ (conjunction) operators in \TDDLfm, thereby ensuring that satisfiability in the original formula corresponds to satisfiability in the constructed temporal instance.\\ For example, the 3-SAT formula \(( x_1 \vee \lnot x_2 \vee  x_3) \wedge (x_4  \vee \lnot x_1\vee x_3) \wedge (\lnot x_3 \vee x_2 \vee x_5) \) can be encoded as:
\\$
\left(
    \underbrace{\ob{\{[1,1]\}}{a}}_{\text{$x_1$}} 
    \sqcup 
    \underbrace{\forb{\{[2,2]\}}{a}}_{\text{$\lnot x_2$}} 
    \sqcup 
    \underbrace{\ob{\{[3,3]\}}{a}}_{\text{$x_3$}}
\right)
\sqcap
\left(
    \underbrace{\ob{\{[4,4]\}}{a}}_{\text{$x_4$}} 
    \sqcup 
    \underbrace{\forb{\{[1,1]\}}{a}}_{\text{$\lnot x_1$}} 
    \sqcup 
    \underbrace{\ob{\{[3,3]\}}{a}}_{\text{$x_3$}}
\right)
\sqcap\\
\left(
    \underbrace{\forb{\{[3,3]\}}{a}}_{\text{$\lnot x_3$}} 
    \sqcup 
    \underbrace{\ob{\{[2,2]\}}{a}}_{\text{$x_2$}} 
    \sqcup 
    \underbrace{\ob{\{[5,5]\}}{a}}_{\text{$x_5$}}
\right). 
$


      


This approach maintains the logical equivalence of the original formula and avoids variable name conflicts by encoding each literal at a distinct time point.

This encoding preserves the satisfiability structure of the original Boolean formula: the \TDDLfm formula is satisfiable if and only if the original 3-SAT instance is satisfiable. Moreover, the translation is computable in polynomial time and introduces no blow-up in the size of the resulting formula.

    Therefore, by proving NP Membership and Hardness, we conclude that the satisfiability problem for \TDDLfm is $\mathsf{NP}$-complete \text{w.r.t.}  the size of the formula.
\end{proofsketch}

\begin{corollary}
Given a bound $\kappa$ on the number of intervals in any formula $\phi$ from \TDDLfm, the satisfiability problem is $\mathsf{NP}$-complete w.r.t to $\eta(\phi)$, assuming $\kappa$ is polynomially bounded in $\eta(\phi)$.
\end{corollary}

\subsubsection{SMT encoding of the satisfiability problem}
We encode the satisfiability problem of a formula from \TDDLfm on an instance of SMT solving using Linear Integer Arithmetic(LIA). Specifically, for every $\phi \in \TDDLfm$, we define $\zeta(\phi)$, such that $\phi$ is satisfiable if and only if $\zeta(\phi)$ is satisfiable.
The mapping from $\phi$ to $\zeta(\phi)$ is decomposed into three parts.
\paragraph{Timed words as constrained arrays of events:}
We represent a candidate model $\mintau$ for a formula $\phi$ as an array of events of a bounded number of events written $\size{\mintau}$, where each event is a pair (action, timestamp). Actions are treated as symbols from a predefined set representing $\Sigma$, and timestamps are represented as integers. In order to make the array $\mintau$ simulate a timed word, we enforce a strictly increasing time value condition in the following formula:
\[
\Disjoint(\mintau):=\forall i <\size{\mintau}-1: \timestamp(\mintau[i]) < \timestamp(\mintau[i+1]).
\]

\paragraph{Constraint extraction}
We define the function $\cstp$ that recursively collects the constraints for a formula $\phi$. Those constraints are expressed on the events forming the model $\mintau$.



\paragraph{Obligation} An obligation is transformed into the existence of an event in the \timedword such that its action matches the obligation action and its timestamp lies within one of the specified intervals.

\begin{example}
    The obligation $\ob{\{[9,16]\}}{\delAtPark}$ is encoded as:
    \begin{align*}
    \cstp(\ob{\{[9,16]\}}{\delAtPark})=& \exists i < \size{\mintau} : \action(\mintau[i]) = \delAtPark \wedge \big(9\leq \timestamp(\mintau[i]) \leq 16\big).
    \end{align*}
\end{example}

\paragraph{Prohibition} A prohibition is transformed into an implication: for all events in the array, if an event has the prohibited action, its timestamp must not lie within the set of intervals. 

\begin{example}
 The prohibition $\forb{\{[2,4],[8,24]}{\delAtGate}$ is encoded as:
    \begin{align*}
    \cstp(\forb{\{[2,4],[8,24]}{\delAtGate})=&\forall i < \size{\mintau}: \big((2 \leq\timestamp(\mintau[i]) \leq 4 \\&\vee 8 \leq \timestamp(\mintau[i]) \leq 24 )
     \implies \action(\mintau[i]) \neq \delAtGate\big).
    \end{align*}
\end{example}



\paragraph{Conjunction and Disjunction} Conjunctions and disjunctions of formulas are encoded using the boolean operators $\wedge$ and $\vee$, respectively.

To ensure decidability and reducibility to QF-LIA, we introduce an upper bound on the size of $\mintau$ based on the formula. Let $\eta(\phi)$ denote the number of obligation literals in the syntactic closure of $\phi$. 
 We prove an upper bound on the size of the array $\size{\mintau}$:



Consequently, with the constraints on the array $\mintau$ representing the timed word model, along with the constraints collected from the formula $\phi$, the resulting SMT encoding $\zeta(\phi)$ for deciding the satisfiability of the formula $\phi$ is as follows:
\[
\zeta(\phi) := \cstp(\phi) \wedge \Disjoint(\mintau) \wedge \big(\size{\mintau} \leq \eta(\phi)\big).
\]

\begin{example}
    The whole SMT encoding of the  use case $\UC:=\DC \sqcap \SR \sqcap \MA$ is as follows:
    \begin{align*}
    \zeta(\UC)=& \cstp(\UC) \wedge \Disjoint (\mintau) \wedge \big(\size{\mintau} \leq \eta(\UC)\big)
    \\=&\Big[\big(\exists i < \size{\mintau}\ : \action(\mintau[i]) = \delAtPark \wedge \big( 9 \leq \timestamp(\mintau[i]) \leq 16\big)\\ &
    \vee \big(\exists i < 2 : \action(\mintau[i]) = \delAtGate \wedge \big(9 \leq \timestamp(\mintau[i]) \leq 16\big)\Big]
\\& \wedge \Big[\forall i < \size{\mintau}: (10 \leq\timestamp(\mintau[i]) \leq 14  \implies \action(\mintau[i]) \neq \delAtPark\Big]
    \\& \wedge \Big[\forall i \leq \size{\mintau}: (2 \leq\timestamp(\mintau[i]) \leq 4 \vee 8 \leq \timestamp(\mintau[i]) \leq 24 )\\&
     \implies \action(\mintau[i]) \neq \delAtGate\Big]
    \\& \wedge \Big[\forall i < \size{\mintau}-1: \timestamp(\mintau[i]) < \timestamp(\mintau[i+1]) \Big]\\&\wedge \Big[\size{\mintau} \leq 2\Big].
    \end{align*} 
\end{example}


We implemented a satisfiability checker for \TDDLfm formulas using the Python programming language and the Z3 SMT solver.\footnote{\href{https://github.com/khrrzkrm/FMMTNL\_Solver}{https://github.com/khrrzkrm/FMMTNL\_Solver/}} The implementation leverages the solver capabilities of the SMT tool and returns a model $\mintau$ when the formula is satisfiable; otherwise, it concludes unsatisfiability.

\begin{example}\label{satsolver}
    Below, we show the results when applying our solver to the  sub-formulas from our use case:
    \begin{tcolorbox}[colback=blue!10, colframe=gray!80, title=Solver Examples]
    \#Satisfiable example $\UC_1'$\\
        Enter a formula from \TDDLfm: O \delAtGate \{[9,16]\} \& F~\delAtGate \{[10,14]\}\\
        Satisfiable \timedword with minimum length: 1\\
        Event 0: Action = \delAtGate, Timestamp = 15\\
        \\
    \#Unsatisfiable example $\UC_2'$\\
        Enter a formula from \TDDLfm: O \delAtGate \{[9,16]\} \& F~\delAtPark \{[2,4],[8, $24$]\}\\
        Unsatisfiable formula.\\\\
    \#Use case $\UC$\\
     Enter a formula from \TDDLfm: (O \delAtGate \{[9,16]\} $\mid\mid$ O \delAtPark \{[9,16]\} ) \& F~\delAtGate \{[10,14]\} \& F~\delAtGate \{[2,4],[8,24]\}\\
        Satisfiable \timedword with minimum length: 1\\
        Event 0: Action = \delAtGate, Timestamp = 15
    \end{tcolorbox}

    
\end{example}

\subsubsection{Additional Unsatisfiability Semantic Rules}

We next formalize the propagation behavior of unsatisfiability in composite formulas. In particular, the following lemma describes how the conjunction and disjunction operators interact with an unsatisfiable sub-formula:
\begin{lemma}[Properties of $\sqcap$ and $\sqcup$ with an unsatisfiable formula]  
\label{empty_inter_union}  
For all formulas $\phi \nd \phi'$ from \TDDLfm, if $\dutyclass{\phi} = \emptyset$, then:  
\[
\dutyclass{\phi \sqcap \phi'} = \emptyset \quad \text{ and } \quad \dutyclass{\phi \sqcup \phi'} = \dutyclass{\phi'}.
\]  

That is:\begin{enumerate}
\item if a formula $\phi$ is unsatisfiable, then any conjunction formed by $\phi$ is also unsatisfiable.

\item  if a formula $\phi$ is unsatisfiable, the satisfiability of the entire expression $\phi \sqcup \phi'$ relies solely on $\phi$ formula.
\end{enumerate}
\end{lemma} 


\begin{proof}
By Lemma \ref{lemma:characdl}:
1. Intersection Case (\(\sqcap\)):  
   \[
   \dutyclass{\phi \sqcap \phi'} = \dutyclass{\phi} \cap \dutyclass{\phi'}.
   \]  
   Since \(\dutyclass{\phi} = \emptyset\), the intersection with any set \(\dutyclass{\phi'}\) results in an empty set:  
   \[
   \emptyset \cap \dutyclass{\phi'} = \emptyset.
   \]  
   Hence, \(\dutyclass{\phi \sqcap \phi'} = \emptyset\).  
\qed
\\
2. Disjunction case(\(\sqcup\)):  
   \[
   \dutyclass{\phi \sqcup \phi'} = \dutyclass{\phi} \cup \dutyclass{\phi'}.
   \]  
   Again, since \(\dutyclass{\phi} = \emptyset\), we get:  
   \[
   \emptyset \cup \dutyclass{\phi'} = \dutyclass{\phi'}.
   \]  
   Thus, \(\dutyclass{\phi \sqcup \phi'} = \dutyclass{\phi'}\).  
\end{proof}




The converse behavior is also true for disjunction: if at least one sub-formula is satisfiable, then the disjunction is satisfiable. This is stated formally in the next lemma:

\begin{lemma}[Disjunction and satisfiable sub-formula]\label{disjunctionissat} 
For any two formulas $\phi$ and $\phi'$ from \TDDLfm: if $\phi$ is satisfiable then $\phi \sqcup \phi'$ is satisfiable.
\end{lemma}
\begin{proof}
We have by Lemma \ref{lemma:characdl} : $\dutyclass{\phi \sqcup \phi'}\equiv \dutyclass{\phi} \cup \dutyclass{\phi'}$. \\
Assume $\phi$ is satisfiable, then $\dutyclass{\phi}\neq \emptyset$.\\
By the definition of union, we have:\\
$\dutyclass \phi \subseteq (\dutyclass{\phi} \cup \dutyclass{\phi'})$, thus by the assumption we obtain: $(\dutyclass{\phi} \cup \dutyclass{\phi'})\neq \emptyset$.\\
 We conclude $\dutyclass{\phi \sqcup \phi'} \neq \emptyset$, which mean that if $\phi$ is satisfiable then $\phi \sqcup \phi'$ is satisfiable
\end{proof}



While satisfiability checking determines whether a normative specification admits at least one compliant behavior, it falls short in providing explanatory insight. Specifically, it does not reveal which parts of the specification are the root cause for unsatisfiability, nor does it clarify how or why certain norms render the system infeasible. It offers a binary answer—satisfiable or not—without tracing the origins of unsatisfiability or identifying potential resolutions. To overcome this limitation, we now turn to a more detailed analysis of normative conflicts, grounded in the semantics of \TDDLfm.





\input{conflictmeat.tex}
 


		

\section{Conflict Calculus over Generalized Rules}\label{subsec:calculus}

The previous section showed that eliminating punctual conflicts can cause substantial growth in formula size.  
While some verbose conflict-free rewriting can be refactored compactly, others cannot without losing semantic precision.  
We now generalize the conflict patterns observed earlier and formalize them as inference rules.  
These rules form a \emph{conflict calculus}, enabling systematic exploration of formulas and selective conflict removal.

\medskip

\noindent
Table~\ref{syncnotation} summarizes the syntactic notations of our deductive system, grounded in the extensional semantics of \TDDLfm.  
We use standard derivability and equivalence symbols, with their semantic counterparts defined over duty classes.

\begin{table}[h]
\centering
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{|c|c|c|}
\hline
\textbf{Notation} & \textbf{Meaning} & \textbf{Semantic mapping} \\ \hline
$\phi \vdash \bot$ & $\phi$ is unsatisfiable & $\dutyclass{\phi} = \emptyset$ \\ \hline
$\vdash \phi$ & $\phi$ is valid & $\dutyclass{\phi} = 2^{\domtr}$ \\ \hline
$\phi \vdash \phi'$ & $\phi$ entails $\phi'$ & $\dutyclass{\phi} \subseteq \dutyclass{\phi'}$ \\ \hline
$\phi \equiv \phi'$ & $\phi$ is equivalent to $\phi'$ & $\dutyclass{\phi} = \dutyclass{\phi'}$ \\ \hline
\end{tabular}
\caption{Syntactic notations and their semantic mapping.}
\label{syncnotation}
\end{table}

\subsection{Generalized Conflicts Management}

We now lift the punctual conflict analysis to a higher level of abstraction.  
Rather than changing our fine-grained definition of conflicts, the following lemmas provide \emph{generalized management rules} that operate on non-atomic literals.  
They consolidate multiple punctual conflicts into larger reasoning steps, allowing one to handle clusters of conflicting intervals in a single inference.  
These big-step rules cover two fundamental forms of normative tension: \emph{deontic} and \emph{ontic} conflicts.  
Each lemma specifies the structural conditions under which such compound conflicts arise and how they can be either resolved or rewritten equivalently.


\begin{lemma}[Generalized management of Deontic Conflicts]\label{Gdeontic-conflict}
Let $\is$ and $\is'$ be interval sets and $\acta$ an action.
\begin{enumerate}[(i)]
\item If $\is \subseteq \is'$, then:
\[
\ob{\is}{a} \sqcap \forb{\is'}{a} \vdash \bot.
\]
\item If $\is \cap \is' \neq \emptyset$ and $\is \not\subseteq \is'$, then:
\[
\ob{\is}{a} \sqcap \forb{\is'}{a} 
\dutyequiv 
\ob{\is \ominus \is'}{a} \sqcap \forb{\is'}{a}.
\]
\end{enumerate}
\end{lemma}

\noindent
Case (i) expresses a \defn{total deontic conflict}: an obligation and a prohibition on the same action and time frame cannot coexist, making the conjunction unsatisfiable.  
Case (ii) captures a \defn{partial deontic conflict}, where the overlap between obligation and prohibition is only partial; the formula remains satisfiable after removing the conflicting portion.

\begin{proof}
\textbf{(i) T-DeoConf.}  
If $\is \subseteq \is'$, each required point $t\in\is$ is also forbidden at $t\in\is'$, yielding punctual conflicts $\ob{\{[t,t]\}}{a}\sqcap\forb{\{[t,t]\}}{a}$.  
No trace can satisfy both, hence the conjunction is unsatisfiable.

\smallskip
\textbf{(ii) P-DeoConf.}  
When $\is\cap\is'\neq\emptyset$ and $\is\not\subseteq\is'$, only points in $\is\cap\is'$ are conflicting.  
Obligations outside the overlap remain valid.  
Removing the conflicting portion yields the equivalent formula:
\[
\ob{\is}{a} \sqcap \forb{\is'}{a} 
\dutyequiv 
\ob{\is\ominus\is'}{a} \sqcap \forb{\is'}{a}.
\]
\end{proof}

\begin{lemma}[Generalized management of Ontic Conflict]\label{lemma:ontic-conflict}
Let $\is$ be a finite interval set and $\{a_1,\dots,a_n\}$ a set of distinct actions such that
$\size{\is} <_\infty \size{\{a_1,\dots,a_n\}}$.  
Then:
\[
\bigsqcap_{i=1}^{n} \ob{\is}{a_i} \dutymodel \bot.
\]
\end{lemma}

\noindent
This rule captures the situation where more actions are obliged than available time points make simultaneous fulfilment impossible.  
Partial ontic rewritings are intentionally omitted, as discussed earlier, due to combinatorial explosion.

\begin{proof}
Let $\size{\is}=m<n$.  
Each $\ob{\is}{a_i}$ expands as $\bigsqcup_{t\in\is}\ob{\{[t,t]\}}{a_i}$; their conjunction enumerates all assignments of actions to time points.  
Since $n>m$, some $t$ must host at least two actions $a_i,a_j$, producing punctual ontic conflicts
$\ob{\{[t,t]\}}{a_i}\sqcap\ob{\{[t,t]\}}{a_j}\dutymodel\bot$.  
By the pigeonhole principle~\cite{Dirichlet1834Vorlesungen,ajtai1994complexity}, every disjunct is unsatisfiable, hence the whole formula is unsatisfiable.
\end{proof}

\subsection{Conflict Calculus}

The conflict calculus in \ref{fig:conflict-calculus} consolidates nine inference rules previously derived as lemmas.  
Together they form a structured system for detecting, rewriting, and resolving normative conflicts.

\begin{itemize}
\item \textbf{(O-Union)} and \textbf{(F-Union)} merge adjacent or disjoint obligations and prohibitions into single literals, simplifying formulas after resolution.
\item \textbf{($\bm{\bot\sqcap}$)} and \textbf{($\bm{\bot\sqcup}$)} propagate unsatisfiability through conjunctions and disjunctions.
\item \textbf{($\bm{\sqcup\bot}$)} prunes unsatisfiable branches in disjunctions.
\item \textbf{($\bm{\bot\equiv}$)} and \textbf{($\bm{\equiv\sqcap}$)} preserve (un)satisfiability under equivalence substitution.
\item \textbf{(Distr1L)} distributes conjunction over disjunction to produce disjunctive normal form.
\item \textbf{(T-DeoConf)} and \textbf{(P-DeoConf)} identify total and partial deontic conflicts, the latter enabling safe rewriting of overlapping intervals.
\item \textbf{(OntConf)} generalizes punctual ontic conflicts, deriving unsatifiability when obligations outnumber time points.
\end{itemize}

\begin{figure}[h]
\centering
\fbox{%
\begin{minipage}{0.95\textwidth}
\[
\begin{array}{c}
\textbf{(O-Union)} \quad \displaystyle \frac{ \is = \is_1 \cup \is_2 }{ \ob{\is_1}{a} \sqcup \ob{\is_2}{a} \dutyequiv \ob{\is}{a} } 
\\[3ex]

\textbf{(F-Union)} \quad \displaystyle \frac{ \is = \is_1 \cup \is_2 }{ \forb{\is_1}{a} \sqcup \forb{\is_2}{a} \dutyequiv \forb{\is}{a} } 
\\[3ex]

\textbf{(Distr1L)} \quad \displaystyle \frac{~}{ \phi_1 \sqcap (\phi_2 \sqcup \phi_3) \dutyequiv (\phi_1 \sqcap \phi_2) \sqcup (\phi_1 \sqcap \phi_3) } 
\\[3ex]

\begin{array}{rlcl}
\textbf{($\bm{\equiv\sqcap}$)} & \displaystyle \frac{ \phi_1 \equiv \phi_1' }{ \phi_1 \sqcap \phi_2 \equiv \phi_1' \sqcap \phi_2 } 
& \quad
\textbf{($\bm{\bot\equiv}$)} & \displaystyle \frac{ \phi' \dutymodel \bot \quad \phi \equiv \phi' }{ \phi \dutymodel \bot } 
\end{array}
\\[3ex]

\textbf{($\bm{\bot\sqcap}$)} \quad \displaystyle \frac{ \phi \dutymodel \bot }{ \phi \sqcap \phi' \dutymodel \bot } 
\\[3ex]

\begin{array}{rlcl}
\textbf{($\bm{\bot\sqcup}$)} & \displaystyle \frac{ \phi \dutymodel \bot \quad \phi' \dutymodel \bot }{ \phi \sqcup \phi' \vdash \bot } 
& \quad
\textbf{($\bm{\sqcup\bot}$)} & \displaystyle \frac{ \phi' \dutymodel \bot }{ \phi \sqcup \phi' \equiv \phi } 
\end{array}
\\[3ex]

\textbf{(T-DeoConf)} \quad \displaystyle \frac{ \is \subseteq \is'}{ \ob{\is}{a} \sqcap \forb{\is'}{a} \vdash \bot } 
\\[3ex]

\textbf{(OntConf)} \quad \displaystyle \frac{ \size{\is} <_\infty \size{\{a_1,\dots,a_n\}} }{ \bigsqcap_{a_i \in \{a_1,\dots,a_n\}} \ob{\is}{a_i} \dutymodel \bot } 
\\[3ex]

\textbf{(P-DeoConf)} \quad \displaystyle \frac{ \is \cap \is' \neq \emptyset \quad \is \not\subset \is'}{ \ob{\is}{a} \sqcap \forb{\is'}{a} \dutyequiv \ob{\is \ominus \is'}{a} \sqcap \forb{\is'}{a} }
\end{array}
\]
\end{minipage}
}
\caption{Conflict calculus for \TDDLfm}
\label{fig:conflict-calculus}
\end{figure}

\begin{example}[Analyzing $\UC$ via Conflict Calculus]

Let

$
\UC_1' := \ob{\{[9,16]\}}{\delAtGate} \sqcap \MA \sqcap \SR, 
\UC_2' := \ob{\{[9,16]\}}{\delAtPark} \sqcap \MA \sqcap \SR$\\
and $\UC := \UC_1' \sqcup \UC_2'
$
with
$
\MA := \forb{\{[2,4],[8,24]\}}{\delAtGate}, 
\quad
\SR := \forb{\{[10,14]\}}{\delAtPark}.\\
$
A constructive way of prunning $\UC$ with be following the next three steps:\\
\textbf{Step 1: Total deontic conflict in $\UC_1'$.}
\begin{prooftree}
\AxiomC{}
\RightLabel{\scriptsize (T-DeoConf)}
\UnaryInfC{$\ob{\{[9,16]\}}{\delAtGate}\sqcap\forb{\{[2,4],[8,24]\}}{\delAtGate}\vdash\bot$}
\AxiomC{}
\RightLabel{\scriptsize ($\bot\sqcap$)}
\BinaryInfC{$\UC_1'\dutymodel\bot$}
\end{prooftree}
Thus $\UC_1'$ is unsatisfiable due to overlapping obligation and prohibition intervals on the same action.

\textbf{Step 2: Partial deontic conflict in $\UC_2'$.}
\begin{prooftree}
\AxiomC{}
\RightLabel{\scriptsize (P-DeoConf)}
\UnaryInfC{$\ob{\{[9,16]\}}{\delAtPark}\sqcap\forb{\{[10,14]\}}{\delAtPark}
\dutyequiv
\ob{\{[9,9],[15,16]\}}{\delAtPark}\sqcap\forb{\{[10,14]\}}{\delAtPark}$}
\AxiomC{}
\RightLabel{\scriptsize ($\equiv\sqcap$)}
\BinaryInfC{$\UC_2'\equiv\UC_2$}
\end{prooftree}
$\UC_2'$ is thus satisfiable after eliminating overlapping intervals.

\textbf{Step 3: Combined derivation for $\UC$.}
\begin{prooftree}
\AxiomC{$\UC_1'\dutymodel\bot$}
\AxiomC{$\UC_2'\equiv\UC_2$}
\RightLabel{\scriptsize ($\bot\sqcup$)}
\BinaryInfC{$\UC_1'\sqcup\UC_2'\dutyequiv\UC_2$}
\end{prooftree}
Hence the global formula $\UC$ is equivalent to its conflict free refinement $\UC_2$.
\end{example}

\medskip
\noindent
The conflict calculus thus provides a uniform reasoning layer over \TDDLfm: each rule isolates minimal sources of unsatisfiability, supports controlled rewriting, and preserves equivalence where possible.  
Its proof-theoretic structure also makes it directly implementable in theorem provers such as Coq, Isabelle, or Lean, where each rule can be encoded as a tactic enabling guided, reproducible proof search.  
This opens a path toward an interactive assistant for designing consistent normative systems, capable of explaining, verifying, and refining specifications through structured derivations.

        \section{Discussion of the Overall Framework}
        This section situates our technical contributions within a structured methodology for analyzing and resolving conflicts in timed normative specifications. We first highlight the formal pipeline of results, which connects definitions, lemmas, algorithms, and theorems into a coherent workflow. We then explain how the framework can be used in practice, showing how each component interacts to refine normative specifications and support human-in-the-loop reasoning.
        
        \subsection{Answering the Research Questions Through Formal Results}

This section situates our technical contributions within a structured methodology for analyzing and resolving conflicts. We demonstrate how the formal pipeline—connecting definitions, algorithms, and theorems—provides precise answers to the three research questions (RQ1--RQ3) posed in Section~\ref{sec:overview}.

\subsubsection{Answering RQ1: The Relation between Unsatisfiability and Conflict}

\textbf{RQ1 asked:} \emph{Is every unsatisfiable formula a conflict? Conversely, does the presence of a conflict necessarily imply that the formula is unsatisfiable?}

Our framework establishes a bidirectional equivalence between semantic unsatisfiability and the presence of syntactic conflict patterns, provided the analysis is performed at the level of the Disjunctive Punctual Normal Form (\dpnf).

\begin{itemize}
    \item \textbf{From Conflict to Unsatisfiability:} We first defined \emph{Punctual Conflicts} (Definition~\ref{puncttypes}) as atomic contradictions occurring at specific time points. We proved that any product term containing such a conflict is necessarily unsatisfiable (Theorem~\ref{thm:mus-structure}). Furthermore, if a formula is \emph{fully conflicting} (i.e., every disjunct in its normal form contains a conflict), it is unsatisfiable (Lemma~\ref{lem:full-conflict-implies-unsat}).
    
    \item \textbf{From Unsatisfiability to Conflict:} Conversely, we proved that every unsatisfiable product term must contain a deontic or ontic punctual conflict as a Minimal Unsatisfiable Subset (MUS) (Theorem~\ref{thm:mus-structure}).
    
    \item \textbf{The Exact Characterization:} We consolidated these results into \textbf{Theorem~\ref{thm:exact-unsat}}, which provides the exact characterization: A formula $\phi$ is unsatisfiable if and only if its \emph{Conflict Density} is exactly 1.
\end{itemize}

\noindent \textbf{Answer:} Yes. In \TDDLfm, unsatisfiability is strictly equivalent to being fully conflicting. Every logical inconsistency can be traced back to atomic deontic or ontic conflict patterns.

\subsubsection{Answering RQ2: Conflict Quantification}

\textbf{RQ2 asked:} \emph{Can we define a quantitative measure for the degree of conflict within a specification?}

We moved beyond binary satisfiability checks by formalizing a continuous measure of inconsistency.

\begin{itemize}
    \item \textbf{Metric Definition:} We introduced \emph{Conflict Density} ($\cd(\phi)$) in \textbf{Definition~\ref{def:Conflict density-measure}}. This metric calculates the ratio between the number of conflicting product terms found by \textbf{Algorithm~\ref{fig:conflict-extraction}} and the total number of scenarios in the specification's normal form.
    
    \item \textbf{Granularity:} This measure relies on the systematic enumeration of conflicts enabled by the \emph{Disjunctive Punctual Normal Form} (\dpnf) (Definition~\ref{def:dnf}) and the \emph{Punctual Normal Form} (Definition~\ref{def:pnf}), which decompose complex constraints into countable atomic units.
\end{itemize}

\noindent \textbf{Answer:} Yes. We quantify the degree of conflict as a rational number $\cd(\phi) \in [0,1]$, representing the proportion of infeasible execution scenarios in the specification.

\subsubsection{Answering RQ3: Properties-Preserving Resolution}

\textbf{RQ3 asked:} \emph{Is it always possible to resolve conflicts in a formula without altering its inherent semantics or compromising its structural compactness?}

Our framework provides a mixed answer: semantic preservation is guaranteed, but structural compactness is subject to trade-offs.

\begin{itemize}
    \item \textbf{Semantic Preservation:} We proved that for any formula with $\cd(\phi) < 1$, there exists a \emph{Conflict-Free Rewriting} ($\Namb(\phi)$) that is semantically equivalent to the satisfiable subset of the original formula (\textbf{Theorem~\ref{thm:cfr}}). This is implemented via \textbf{Algorithm~\ref{alg:conflict-free-rewriting}}, which prunes exactly those branches identified as conflicting.
    
    \item \textbf{Structural Compactness:} We showed that this resolution is \emph{not} always compact. \textbf{Theorem~\ref{complexityofconf}} establishes that the full normalization required for conflict elimination can induce an exponential blow-up in formula size.
    
    \item \textbf{Mitigation:} However, we demonstrated that compactness can often be restored using \emph{Literal Compression rules} (Lemma~\ref{lemma:literal-compression}) and the \emph{Conflict Calculus} (\ref{fig:conflict-calculus}). These tools allow for big-step manual simplifications (e.g., Lemma~\ref{Gdeontic-conflict}) to mitigate the verbosity of the automated output. We also suggested the conflict calculus that enables one to choose which conflicts to use to avoid size exlosion. The conflict calculus has no rule for eliminating ontic conflicts as it has an important blow-up factor.
\end{itemize}

\noindent \textbf{Answer:} We can always resolve conflicts while preserving the intended \emph{compliant behaviors} (semantics). However, we cannot guarantee \emph{structural compactness}; conflict elimination may increase the size of the specification, necessitating a post-processing refactoring step.
        
        
        \subsection{How to Use the Framework Reasoning Tools}
        
        
        The possible usages of the framework’s tools is illustrated in \ref{fig:framework_summary}. It begins with a normative specification $\phi$, which undergoes both logical and feasibility analysis. A key starting point is the SMT-based time infeasibility check, which identifies whether the timing constraints in the specification are jointly satisfiable. The specification could also be translated into Disjunctive Punctual Normal Form (DPNF). This transformation enables fine-grained conflict detection and explanation by reducing complex temporal constructs into atomic, punctual obligations and prohibitions.
        
        Conflict detection then classifies inconsistencies into ontic and deontic types. The structural transformations inform this process applied through DPNF and return the set of punctual conflicts $\mathcall{PC}(\phi)$ as well as the conflict density measure $\cd(\phi)$. Once identified, conflicts are passed to the conflict elimination phase, which removes all product terms containing conflicts. As discussed previously, this automatic conflict elimination procedure can result in returning a refined specification $\phi'$ that does not contain any conflict but may have a bad conciseness ratio.
        
        The conflict calculus provides the user with the option for a tailored trade-off and simpler reasoning while preserving soundness to the conflict detection algorithm. It offers a higher-level analysis of normative specification without going to the disjunctive punctual normal form, which is too verbose for human processing. It enables formal reasoning through rule-based derivations, allowing designers to manually prune, rewrite, or simplify problematic portions of a specification to reduce the conflict density measure while maintaining a desired concise ratio compared to the original normative specification. The calculus is also bidirectionally connected to the refined normative specification $\phi'$, as it both informs its construction and enables subsequent updates or revisions. This interactive loop reflects real-world design cycles where specifications evolve iteratively under refinement, correction, or contextual adaptation. Unless all the other tools in the framework are. The calculus is not automated and requires the user to understand the semantics and rules of the proof system but offers him shorter explanation and big steps reasoning. 
        
        The conflict density measure component receives information from the conflict detection phase to quantify the degree of normative uncertainty inherent in the original specification. This metric supports informed decision-making by offering a way to compare alternative encodings or prioritize simplification steps.
        
        Ultimately, the framework yields a refined normative specification $\phi'$ that may be conflict-free and, ideally, more amenable to implementation or automated reasoning. The conciseness ratio $\frac{\size{\phi'}}{\size{\phi}}$ evaluates the trade-off between conflict elimination and formula size. In scenarios where full normalization introduces syntactic blow-up, this ratio provides helpful guidance for designers balancing readability and conflict elimination.
        
        \begin{figure}[h!]
        \centering
        \begin{tikzpicture}[
            node distance=1.8cm and 2cm,
            rect/.style={rectangle, draw, rounded corners, text width=3.2cm, align=center, minimum height=1cm, fill=blue!10},
            decision/.style={diamond, draw, aspect=2.5, text width=3cm, align=center, fill=orange!10},
            ellip/.style={ellipse, draw, minimum width=3cm, minimum height=1.5cm, align=center, fill=green!10},
            arrow/.style={-{Stealth[round]}, thick},
            scale=0.82, transform shape,scale=0.9
        ]
        
        % Nodes
        \node[ellip] (spec) {Normative\\ Specification $\phi$};
        \node[rect, below=of spec] (smt) {SMT-based \\Time Infeasibility};
        \node[rect, below left= 1.7cm of smt] (calculus) {Conflict Calculus};
        \node[rect, below right= 1.7cm of smt] (conflicts) {Conflict Detection\\
        (\dpnf)};
        \node[rect, below= 1.5cm of conflicts] (conflicte) {Conflict Elimination};
        \node[ellip, below right=2cm of conflicts] (conflict density) {Conflict Density\\
        $\cd(\phi)$};
        \node[ellip, right=1.5cm of conflicts] (PC) {Punctual Conflicts\\ $\mathcall{PC}(\phi)$
        };
        \node[ellip, below =4cm of calculus] (resolution) {Refined\\  Specification $\phi'$};
        \node[ellip, below =2cm of conflicte] (cf-resolution) { $\Namb(\phi)$};
        % \node[ellip, below right=1.5cm of resolution] (consin) {Conciseness Ratio\\ $\frac{\size{\phi'}}{\size{\phi}}$};
        
        % Arrows
        \draw[arrow] (spec) -- (smt);
        \draw[arrow] (conflicte) -- (cf-resolution);
        \draw[arrow] (spec.west) -| (calculus.north);
        \draw[arrow] (spec.east) -| (conflicts.north);
        \draw[arrow] (smt) -- (calculus);
        \draw[arrow] (conflicts) -- (PC);
        \draw[arrow] (smt) -- (conflicts);
        %\draw[arrow] (resolution.south) (resolution.south) -- ++(0,-1.5)
          -- ++(-7,0)
          -- ++(0,14)
          -- ++(7,0)
          -- ++(0,-1.5)
          -- (spec.north); 
        
        \draw[arrow] (conflicts) -- (conflicte);
        \draw[arrow] (calculus) to[bend left=25] (resolution);
        \draw[arrow] (resolution) --(conflicts);
        \draw[arrow] (resolution) to[bend left=25] (calculus);
        %\draw[arrow]  ([xshift=0.8cm]resolution.north) |- (conflicts.west) ;
        \draw[arrow] (conflicts) -- (conflict density);
        %\draw[arrow] (resolution) -- (consin);
        
        \end{tikzpicture}
        \caption{Diagram summarizing the   conflict analysis and resolution framework.}
        \label{fig:framework_summary}
        \end{figure}



        \section{Related Work}
        To our knowledge, this is the first framework to integrate systematically:
        \begin{inparaenum}[(i)]
        \item a metric-time deontic logic with action-based semantics;
        \item structural use of interval sets for simplifying formula representations;
        \item algorithmic techniques for detecting and eliminating conflicts;
        \item a conflict calculus that supports formal, traceable derivations; and
        \item a quantitative analysis of conflict density and conciseness in normative specifications and their refinements.
        \end{inparaenum}
        
        
        
        % \begin{table}[h!]
        % \centering
        % \caption{Comparison of related frameworks along key conflict-handling dimensions.}
        % \label{tab:related-work-comparison}
        % \renewcommand{\arraystretch}{1.3}
        % \begin{tabularx}{\textwidth}{|l|X|X|X|X|}
        % \hline
        % \textbf{Work} & \textbf{Timed Constraints} & \textbf{Conflict Types} & \textbf{Conflict Detection Mechanism} & \textbf{Conflict Elimination} \\
        % \hline
        % \textbf{\cite{colombo2014detecting}} &
        % Timed traces with event triggers and deadlines; timing not encoded in the logic itself. &
        % Deontic and a combination of achievement, maintenance, preemptive, and compensable. &
        % Trace-based analysis, with manual annotations of action incompatibility and temporal alignment. &
        % No algorithmic elimination; focus is on classification and modeling. \\
        % \hline
        % \textbf{\cite{pace2020general}} &
        % Discrete time steps only; no metric constraints. &
        % Primarily \emph{environmental} conflicts (generalized ontic). &
        % Derivative semantics and constraints over traces of action sets to capture the evolution of the norms and constraints over time. &
        % No formal elimination mechanism; detection only. \\
        % \hline
        % \textbf{\cite{DBLP:journals/flap/TamargoMRG21}} &
        % Metric time using intervals &
        % Temporal inconsistency due to overlapping rules; deontic conflicts only. &
        % Belief revision via consistency-checking operator $\sigma$. &
        % Partial elimination by trimming subintervals that cause contradiction. \\
        % \hline
        % \textbf{\cite{DBLP:conf/icail/GovernatoriR23}} &
        % No metric constraints; defeasible logic setting. &
        % Deontic conflict density (lack of clear resolution). &
        % Defeasible inference rules; conflict density from unresolved rule conflict. &
        % No elimination; conflict density is diagnosed, not removed. \\
        % \hline
        % \textbf{\cite{10.1145/3597503.3639093}}&  Time points (deadline).& vacuous and situational.& SMT solving via encoding to $FOL^*$ fragment. & Not addressed.\\
        % \hline
        % \textbf{This work} &
        % Metric-time using interval sets. &
        % Deontic and ontic conflicts based on overlapping obligations and prohibitions. &
        % Syntactic and semantic detection using DPNF and a proof system. &
        % Conflict calculus and elimination algorithms based on normalization and pruning. \\
        % \hline
        % \end{tabularx}
        % \end{table}
        
        Existing works suggests many ways to define and detect normative conflicts with temporal reasoning. The majority of current frameworks either limit themselves to discrete-time models or employ only axiomatic approaches without providing operational steps for handling conflict. Our framework differs, introducing a syntactically sound and semantically founded methodology that incorporates normalization, algorithmic detection, conflict elimination, and formal conflict calculus. The following explanations make clear how our research compares to previous work.
        
        \paragraph{Conflicts Characterization}
        Pace and Schapachnik~\cite{pace2020general} propose logical criteria for identifying conflicts in contracts using temporal deontic logic. Their framework operates in a discrete-time setting, where obligations are defined over abstract steps rather than metric time points. Notably, their primary focus lies in environmental conflicts, which is another type of ontic conflicts related to the environement constraint rather than the agent. A typical example involves a contract that obliges an agent to perform actions a, b, and c, while an external constraint prohibits executing all three simultaneously. These conflicts are not necessarily due to temporal contradictions, as we consider in our work when multiple obligations are assigned to distinct actions at the same time point, but rather arise from feasibility limitations imposed by the environment.
        
        A closer comparison can be drawn with the work of Colombo and Governatori~\cite{colombo2014detecting}, who present a temporal semantic framework for analyzing various types of obligations, standard, achievement, maintenance, preemptive, and compensable—using timed traces as semantic models. Their framework captures a broader typology of conflicts, including what we define as deontic conflicts as well as achievement/achievement conflicts, which in our setting correspond to ontic conflicts. While their use of timed traces enables reasoning about the evolution of obligations over time, timing constraints are not directly embedded in the logical syntax. Instead, they are modeled via external annotations such as triggers and deadlines. This externalization of timing has significant implications. For example, in their setting, conflict detection relies on manually specifying incompatibilities between actions such as declaring that ``going to the bar” and ``writing a paper” cannot occur simultaneously. This is necessary because actions are represented as atomic propositions, all of which may co-occur at the same time point unless explicitly constrained. In contrast, our logic internalizes timing constraints as first-class constructs. Conflicts arise not from assumed action incompatibilities but from the interaction of metric intervals within which obligations and prohibitions are specified. This intrinsic modeling of time allows us to detect inconsistencies purely based on the temporal semantics of the norms, without requiring auxiliary assumptions about the actions themselves. We acknowledge that, in practice, some actions can be concurrent; our minimal ontic assumption can be relaxed by replacing the single–action capacity with a general feasibility predicate. Thus, an expressive ontic layer lies between the two settings: Under this regime, exceptions are positive, one can explicitly declare which actions are co-executable, rather than attempting to enumerate all non-compatible pairs. 
        
        A framework is presented in \cite{10.1145/3597503.3639093} that models temporal constraints using deadlines, i.e, single  time point within which a prescribed event must or must not occur (e.g., “open the curtain within 30 minutes”). These constraints are not expressed as extended intervals such as $[10,14]$ or sets of disjoint intervals, but rather as single continuous windows anchored to specific triggering conditions. The framework does not reason over arbitrary collections of time periods; instead, it focuses on whether an event satisfies its associated deadline constraint. Within this setting, they distinguish two forms of normative conflict: vacuous conflicts, which arise when a rule can never be applied without violating another, for instance, one rule obliges opening the curtains while another forbids it in all cases; and situational conflicts, which emerge only under certain conditions, where otherwise non-conflicting rules issue contradictory demands when triggered simultaneously in a specific context. 

        \paragraph{Conflict Elimination}
A comparable strategy for conflict elimination in timed normative specifications is found in the work \cite{DBLP:journals/flap/TamargoMRG21}, which introduces a belief revision framework for legal systems based on temporalised logic. Their approach also addresses normative systems with discrete time, allowing for fine-grained control over the temporal applicability of norms. At the core of their framework lies a temporal revision operator, denoted $\sigma$, which maintains consistency when new normative clause is introduced. Rather than removing the entire conflicting rules, the operator identifies the specific temporal fragments,i.e., sub-intervals, responsible for the contradiction and selectively trims them.

In contrast, our approach differs in several key respects:
\begin{inparaenum}[(i)]
\item it addresses not only deontic conflicts but also ontic conflicts, as our logic is action-based;
\item our logic does not support conditionals, while they do not consider disjunction;
\item our conflict detection and elimination revises the entire normative system as a whole, rather than prioritizing the newly introduced norm over the existing ones;
\item it leverages interval sets to yield a more concise and refined normative specification, whilst they solely rely on intervals; and \item our approach is semantic and syntax-based, equipped with algorithms and conflict calculus.
\end{inparaenum}

% \section{Conclusion}
% This paper introduced a structured framework for reasoning about conflicts in normative systems specified in a metric-time. Our approach integrates syntactic normalization, SMT-based feasibility checks, a dedicated conflict detection algorithm, and a formal conflict calculus to classify and resolve both ontic and deontic inconsistencies. By internalizing temporal constraints as first-class logical constructs, our logic avoids reliance on external assumptions about action incompatibility and enables conflict detection based purely on the interaction of time-bounded norms.

% While the logical operators presented in this work are intentionally minimal, we believe they form a necessary core for any normative formalism that aims to balance expressivity, tractability, and semantic clarity. However, we are far from expressing all normative specifications and from addressing all types of conflicts encountered in practice. Several iterative concrete extensions are envisioned:

% \begin{itemize}
% \item \textbf{Enriching the logic} with support for actions with duration, maintenance obligations, conditional and permission operators, and eventually, defeasibility mechanisms;
% \item \textbf{Modeling interaction-based conflicts} by introducing frames that capture dependency relations or mutual exclusivity between actions—such as when one action prevents, enables, or temporally interferes with another;
% \end{itemize}
% Together, these directions will advance the logic into a comprehensive, machine-verifiable tool for normative system design, with applications in contracts, autonomous agents, and legal compliance.

% Additionally, we believe that our methodology could be replicated to other logics. The normalization pipeline, punctual conflict extraction, and SMT-based feasibility checks can be carried over to other timed or agent centred normative formalisms, and to specification languages that do not adopt \TDDLfm. We expect these techniques to serve as a reusable backbone for future calculi and tools that require transparent conflict detection and verifiable repair.






\section{Conclusion}
We presented a micro metric-time normative logic, \TDDLfm, together with a pipeline for \emph{explainable} conflict analysis: syntactic normalization to disjunctive/punctual forms, a sound QF-LIA encoding for timed feasibility, a constructive conflict-extraction procedure, and a proof-theoretic conflict calculus. By internalising metric time via canonical interval sets and making the ontic resource constraint explicit (\emph{one action per time point}), conflicts arise transparently from the interaction of time-bounded norms and that constraint.
Beyond detecting conflict, we contributed additionally by: (i) defining a \emph{conflict-density} measure and proving a \emph{pruning theorem} that rewrites any partially conflicting specification into a semantically equivalent, conflict-free refinement; and (ii) complexity/algorithms for \TDDLfm\ satisfiability is NP-complete with a tight QF-LIA encoding bounded by the number of obligations, together with explicit size blow-up bounds for punctualisation (showing the conciseness vs.\ conflict-elimination trade-off). 
\paragraph{Transferability.}
We believe that our methodology is transferable to many other existing logics: more precisely agent-centred timed deontic formalisms and other contract specification languages beyond \TDDLfm, providing a systematic approach to conflict detection and verifiable repair in contracts, autonomous agents, and legal compliance.

\paragraph{Outlook.}
We plan two enrich \TDDLfm gradually and in two different directions: (1) \emph{expressivity}: actions with duration and ought to be literals (defined on states), reparation operator, conditional/permission literals and a defeasibility layer; and (2) \emph{interaction}: frames for prevention/enabling/interference between actions, and relaxing the single-action ontic constraint. We expect the second direction to require substantial methodological changes, since it requires additional structural properties on the underlying frames used to model the ontical properties of the enriched logic.





















