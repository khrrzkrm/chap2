\section{Syntactic Timed Normative Conflict Definition and Detection}
\label{sec:conflicts}

The previous sections established the semantics of \TDDLfm, including the representation of obligations and prohibitions over interval sets and the construction of normal forms. We now address how to capture \emph{conflicts} in temporal-deontic specifications formally.

Our motivation, grounded in practical use cases, is that deontic conflicts materialize at \emph{specific time points} that must be isolated and explained. The goal is not only to show that a specification is inconsistent, but to determine \emph{where}, \emph{when}, and \emph{why} inconsistency arises. We first define punctual ontic and deontic conflicts as atomic patterns. We then explain why these patterns do not suffice on their own, introduce syntax-aware invariants (\LUCO and \LAP) that stabilize conflict detection under rewriting, and finally develop a systematic procedure and quantitative measure that detect and classify all punctual conflicts that a formula \emph{has}.



\subsection{Syntactic Definitions for Conflicting Formulas}
To reason about conflicts in \TDDLfm, we first need a precise vocabulary that identifies what constitutes a conflict and when a formula specifies a conflict. We therefore begin by isolating the most elementary patterns that arise at individual time points. These punctual patterns form the atomic units from which all further reasoning about conflicts in formulas \emph{has or specifies}.

\subsubsection{Punctual Conflicts: the Atomic Patterns}
From a dilemma-oriented perspective, two types of timed normative conflicts arise. First, an agent may be simultaneously obliged and prohibited to perform the same action at the same time. Second, an agent may be obliged to perform two different actions at exactly the same time, while the agent can realize at most one of them. We formalize these punctual conflict patterns next.

\begin{definition}[Punctual Conflicts]\label{puncttypes}
Let $a,b\in\Sigma$ and $t\in\mathbb{N}$.
\begin{itemize}
    \item A \defn{punctual deontic conflict} (\textbf{P-Deon-Conf}) occurs when an obligation and a prohibition prescribe and forbid the same action at the same time:
    \[
        \ob{\{[t,t]\}}{a} \sqcap \forb{\{[t,t]\}}{a}.
    \]
    \item A \defn{punctual ontic conflict} (\textbf{P-Ont-Conf}) occurs when two distinct punctual obligations require different actions at the same time:
    \[
        \ob{\{[t,t]\}}{a} \sqcap \ob{\{[t,t]\}}{b}.
    \]
\end{itemize}
\end{definition}

These patterns are purely syntactic formulas of \TDDLfm. Whenever they appear as sub-terms of a product term composed of punctual literals (modulo commutativity and associativity), a conflict is present at that time point. A formula may contain one or several such conflicts as subformulas, and a single literal may participate in several conflicts.

\begin{example}[Punctual conflicts appear as sub-formulas]
We illustrate three formulas where conflicts occur as sub-terms. Underlined sub-terms indicate punctual conflicts.



$
\phi_1 :=
\Big(
  \underline{\ob{\{[2,2]\}}{\delAtPark} \,\sqcap\, \forb{\{[2,2]\}}{\delAtPark}}
\;\sqcap\;
  \ob{\{[2,2]\}}{\delAtGate} \,\sqcap\, \forb{\{[2,2]\}}{\pickU}
\Big)
\;\sqcup\;
\ob{\{[0,7]\}}{\delAtGate}
$
\vspace{0.5em}
$\phi_1$ contains a punctual deontic conflict on $\delAtPark$ at $t=2$.

$
\phi_2 :=
\Big(
  \underline{\ob{\{[5,5]\}}{\delAtPark} \,\sqcap\, \ob{\{[5,5]\}}{\delAtGate}}
\Big)
\,\sqcup\,
\Big(
  \underline{\ob{\{[5,5]\}}{\delAtPark} \,\sqcap\, \forb{\{[5,5]\}}{\delAtPark}}
\Big)
\;\sqcup\;
\ob{\{[0,6]\}}{\pickU}
$



Here, $\phi_2$ contains two punctual conflicts at $t=5$: one ontic and one deontic.



$
\phi_3 :=
\Big(
  \tikzmark{bpark}\ob{\{[2,2]\}}{\delAtPark\tikzmark{epark}}
  \, \sqcap\,
  \tikzmark{bgate}\ob{\{[2,2]\}}{\delAtGate\tikzmark{egate}}
  \, \sqcap\,
  \tikzmark{bpick}\ob{\{[2,2]\}}{\pickU\tikzmark{epick}}
\Big)
\;\sqcup\;
\Big(
  \ob{\{[2,2]\}}{\delAtPark}
  \,\sqcap\,
  \forb{\{[2,2]\}}{\pickU}
\Big)
$

\begin{tikzpicture}[remember picture,overlay]
  \draw ([yshift=-0.8ex]pic cs:bpark) -- ([yshift=-0.8ex]pic cs:egate);
  \draw ([yshift=-2.4ex]pic cs:bgate) -- ([yshift=-2.4ex]pic cs:epick);
  \draw ([yshift=-4.0ex]pic cs:bpark) -- ([yshift=-4.0ex]pic cs:epark);
  \draw ([yshift=-4.0ex]pic cs:bpick) -- ([yshift=-4.0ex]pic cs:epick);
\end{tikzpicture}

\noindent
$\phi_3$ contains three punctual ontic conflicts at $t=2$ between
$\{\delAtGate,\delAtPark\}$,
$\{\delAtPark,\pickU\}$, and
$\{\delAtGate,\pickU\}$.
Removing $\ob{\{[2,2]\}}{\delAtPark}$ eliminates all conflicts because this literal participates in each of them.
\end{example}

\subsubsection{Why Punctual Conflicts Are Not Enough}

Real specifications rarely contain explicit punctual literals. Interval literals may conceal conflicts that only become visible after decomposition. For example,
$\forb{\{[1,1]\}}{a}$ is atomic, whereas
$\forb{\{[1,3]\}}{a}$ decomposes via Literal Compression:
\[
\forb{\{[1,3]\}}{a}
\equiv
\forb{\{[1,1]\}}{a} \sqcap \forb{\{[2,3]\}}{a}.
\]
Thus, the punctual conflict
$\forb{\{[1,1]\}}{a} \sqcap \ob{\{[1,1]\}}{a}$
is visible in the decomposed form but \emph{not} in
$\forb{\{[1,3]\}}{a} \sqcap \ob{\{[1,1]\}}{a}$.

Another case arises when conflicting literals do appear in the formula, yet their interaction is hidden by disjunction and does not manifest as a single product term. For instance,
\[
(\ob{\{[1,1]\}}{a} \sqcup \ob{\{[2,3]\}}{a}) \sqcap \forb{\{[1,1]\}}{a}.
\]
By distributivity,\\
\\
$
(\ob{\{[1,1]\}}{a} \sqcup \ob{\{[2,3]\}}{a}) \sqcap \forb{\{[1,1]\}}{a}
\equiv
(\ob{\{[1,1]\}}{a} \sqcap \forb{\{[1,1]\}}{a})
\sqcup
(\ob{\{[2,3]\}}{a} \sqcap \forb{\{[1,1]\}}{a}).
$\\\\
The first disjunct exposes a punctual conflict at $t=1$, while the second does not. This example shows that the conflict is not syntactically evident in the original formula but only appears after applying distributive expansion. 

Hence, identifying conflicts cannot rely solely on the surface structure of a formula: conflicts may be latent within interval composition or disjunctive structure and require specific \emph{rewriting} to be made explicit.

\subsubsection{Why Naive Equivalence-Based Detection Fails}

A first idea would be to declare that a formula “has a conflict’’ whenever it is semantically equivalent to another formula that visibly contains a punctual conflict as defined in \cite{DBLP:conf/jurix/KharrazSL24}. This criterion is too weak: Boolean manipulations can erase genuine conflicts or introduce spurious ones.

\begin{example}[Illustration of problems with naive equivalence-based detection]
We demonstrate equivalences by erasing or introducing conflicts using the absorption properties of disjunction of an unsatisfiable formula with any other formula, as shown in Lemma~.\ref{empty_inter_union}.
\begin{inparaenum}[(i)]
\item \textbf{Erasing a genuine conflict.}
\[
  \phi := (\ob{\{[2,2]\}}{a} \sqcap \forb{\{[2,2]\}}{a}) \;\sqcup\; \phi'
\]
is equivalent to $\phi'$, so naive equivalence would falsely conclude that $\phi$ has no conflict.

\item \textbf{Creating a spurious conflict.}
\[
  \phi' := \phi \;\sqcup\; (\ob{\{[3,3]\}}{a} \sqcap \forb{\{[3,3]\}}{a})
\]
is equivalent to $\phi$, but naive equivalence would now falsely conclude that $\phi$ has a conflict.
\end{inparaenum}
\end{example}

To avoid such pathologies, conflict extraction must respect the syntactic structure of the formula.

\subsubsection{Syntax-Aware Conflict Detection: LUCO and LAP}


We therefore introduce two invariants that govern how literal refinements behave in conflict detection: (i) \emph{Lowest Upper Common Operator (LUCO):} preserves the Boolean position where literals meet; and (ii) \emph{Literal Ancestor Preservation (LAP):} ensures punctual descendants refine—but never alter—their ancestor literals.

These invariants ensure that conflicts cannot vanish or appear spuriously during normalization.

\begin{definition}[Lowest upper common Boolean operator under unique occurrence]\label{def:luco-unique}
Let $\phi\in\TDDLfm$ and let $\mathsf{T}(\phi)$ be its Boolean syntax tree whose internal
nodes are $\{\sqcap,\sqcup\}$ and whose leaves are literals.
Assume $\ell_i,\ell_j$ each occur exactly once in $\phi$.
The \emph{lowest upper common Boolean operator} (\LUCO) of $\ell_i$ and $\ell_j$ in $\phi$,
denoted $\LUCO_\phi(\ell_i,\ell_j)$, is the unique node $v$ of $\mathsf{T}(\phi)$ such that:
\begin{enumerate}[(i)]
    \item $v$ is labeled by $\sqcap$ or $\sqcup$;
    \item $v$ lies on both root-to-$\ell_i$ and root-to-$\ell_j$ paths; and
    \item no proper descendant of $v$ satisfies \emph{(i)} and \emph{(ii)}.
\end{enumerate}
We write $\LUCO_\phi(\ell_i,\ell_j)=\sqcap$ (resp.\ $=\sqcup$) to denote its label.
\end{definition}


\begin{example}[\LUCO on a formula with 5 literals]\label{ex:AST}
Let~$
\phi \;:=\; \Big((\ell_1 \sqcup \ell_2)\ \sqcap\ \ell_3\Big)\ \sqcup\ \Big(\ell_4 \sqcap \ell_5\Big),$
with unique occurrences of each literal. Then:
\medskip
\noindent\textbf{Syntax tree of $\phi$, $\mathsf{T}(\phi)$.}
\begin{center}
\begin{tikzpicture}[
  level distance=12mm,
  % widen root's children, tighten inner pairs:
  level 1/.style={sibling distance=52mm},
  level 2/.style={sibling distance=22mm},
  every node/.style={font=\small},
  op/.style={draw, circle, minimum size=6.5mm, inner sep=0.5mm},
  lit/.style={draw=none},
  scale=0.95, transform shape
]
\node[op] (root) {$\sqcup$}
  child { node[op] (Lcap) {$\sqcap$}
    child { node[op] (Lcup) {$\sqcup$}
      child { node[lit] {$\ell_1$} }
      child { node[lit] {$\ell_2$} }
    }
    child { node[lit] {$\ell_3$} }
  }
  child { node[op] (Rcap) {$\sqcap$}
    child { node[lit] {$\ell_4$} }
    child { node[lit] {$\ell_5$} }
  };
\end{tikzpicture}
\end{center}

\[
\LUCO_\phi(\ell_1,\ell_2)=\sqcup,\quad
\LUCO_\phi(\ell_1,\ell_3)=\LUCO_\phi(\ell_2,\ell_3)=\sqcap,\quad
\LUCO_\phi(\ell_4,\ell_5)=\sqcap,
\]
and for any $x\in\{\ell_1,\ell_2,\ell_3\}$ and $y\in\{\ell_4,\ell_5\}$,
\[
\LUCO_\phi(x,y)=\sqcup \quad\text{(the root).}
\]
\end{example}


As literals in our logic are not atomic, we introduce the notion of ancestor preservation with respect to time points in interval sets.
Informally, this invariant ensures that normalization only refines a literal: no new time points are introduced beyond those originally specified, and none of the initial ones are lost.
The modality and action remain unchanged, and the resulting punctual descendants, when recombined through their \LUCO, reconstruct exactly the original literal.


\begin{definition}[Literal ancestor preservation (\LAP)]
\label{def:lit-ancestor}
Let $\phi \nd \phi'$ be two formula from $\TDDLfm$.
We say that $\phi'$ satisfies \emph{literal ancestor preservation} of $\phi$ if there exists a mapping between literals in $\phi$ and literals in $\phi'$ such that:
\begin{enumerate}[(i)]
    \item (\textbf{Downward preservation})  
    For every literal $\ell'$ in $\phi'$, there exists an ancestor literal $\ell$ in $\phi$ with the same modality and action, and whose interval set contains that of $\ell'$.
    \item (\textbf{Upward coverage})  
    For every literal $\ell$ in $\phi$, the set of its descendants$\{\ell_1', \ell_2', \dots, \ell'_n \}$ in $\phi'$ (i.e.\ those having $\ell$ as ancestor) combine under the Boolean operator determined by their Lowest upper common Boolean operator in $\phi'$ to a sub-formula that is syntactically equivalent to $\ell$.
\end{enumerate}
\end{definition}


These invariants ensure that literals and their Boolean combinations are neither added nor altered during the successive normalizations, which is precisely the guarantee required to prove correctness.
\subsubsection{A Stable Definition of “Has a Conflict’’}

We now define the correct notion of when a formula \emph{has} a conflict.

\begin{definition}[Formula has a conflict]\label{def:has-conflict}
A formula $\phi$ \defn{has a conflict} iff there exists a formula $\phi'$ such that:
\begin{enumerate}[(i)]
    \item $\phi' \dutyequiv \phi$,
    \item $\phi'$ preserves \LUCO\ and \LAP\ with respect to $\phi$,
    \item $\phi'$ has a punctual conflict as a sub-formula.
\end{enumerate}
\end{definition}



\begin{example}[Preliminary exhibition of conflicts]
\[\text{Let }
  \phi := \ob{\{[2,3]\}}{a} \;\sqcap\; \forb{\{[2,4]\}}{a}
\]
and
\[
  \phi' := 
  \Big(\ob{\{[2,2]\}}{a} \;\sqcap\; \forb{\{[2,2]\}}{a} \;\sqcap\; \forb{\{[3,4]\}}{a}\Big)
  \;\sqcup\;
  \Big(\ob{\{[3,3]\}}{a} \;\sqcap\; \forb{\{[2,4]\}}{a}\Big).
\]

\noindent
We justify that $\phi$ specifies the conflict $\ob{\{[2,2]\}}{a} \sqcap \forb{\{[2,2]\}}{a}$ as follows:

\begin{enumerate}[(i)]
  \item \textbf{Semantic equivalence.}  
  By construction, $\phi'$ is simply the punctual decomposition of $\phi$:
  \[
    \ob{\{[2,3]\}}{a} \equiv \ob{\{[2,2]\}}{a} \sqcup \ob{\{[3,3]\}}{a}, \qquad
    \forb{\{[2,4]\}}{a} \equiv \forb{\{[2,2]\}}{a} \sqcap \forb{\{[3,4]\}}{a}.
  \]
  Substituting these equivalences yields exactly $\phi'$, hence $\phi \equiv \phi'$.

  \item \textbf{\LUCO preservation.}  
  In $\phi$, the two literals $\ob{\{[2,3]\}}{a}$ and $\forb{\{[2,4]\}}{a}$ occur under a conjunctive node $\sqcap$.  
  In $\phi'$, their punctual descendants (e.g.\ $\ob{\{[2,2]\}}{a}$ and $\forb{\{[2,2]\}}{a}$) also occur under a conjunctive $\sqcap$ inside each product term. Thus, $\LUCO$ is preserved.

  \item \textbf{\LAP preservation.}  
  Each punctual literal in $\phi'$ has a corresponding ancestor in $\phi$:
  \begin{itemize}
    \item $\ob{\{[2,2]\}}{a}$ and $\ob{\{[3,3]\}}{a}$ are descendants of $\ob{\{[2,3]\}}{a}$, and their interval sets are contained in $[2,3]$.
    \item $\forb{\{[2,2]\}}{a}$ and $\forb{\{[3,4]\}}{a}$ are descendants of $\forb{\{[2,4]\}}{a}$, and their interval sets are contained in $[2,4]$.
  \end{itemize}
  Moreover, the descendants recombine conjunctively or disjunctively exactly as required to recover their ancestors. Hence \LAP\ is satisfied.

  \item \textbf{Conflicts appear as subterm.}  
  The first disjunct of $\phi'$ visibly contains the punctual conflict
  \[
    \ob{\{[2,2]\}}{a} \;\sqcap\; \forb{\{[2,2]\}}{a}.
  \]
\end{enumerate}

\noindent
Therefore, $\phi$ \emph{has} a conflict according to Definition~\ref{def:has-conflict}, witnessed by $\phi'$.
\end{example}

This definition stabilizes the notion of conflict under normalization: conflicts cannot disappear or be fabricated through Boolean transformations, and later sections will show that every conflict that a formula has can be made explicit in its \dpnf\ form.

The definition requires only that a formula have at least one punctual conflict, although many different rewritings~$\phi'$ may preserve \LUCO\ and \LAP\ while exposing one or several such conflicts. In the next section, we develop an algorithm that uncovers \emph{all} conflicts that a formula has according to this definition.



\subsection{Systematic Enumeration of all Punctual Conflicts}

To exhibit such conflicts systematically, we define the \emph{disjunctive punctual normal form} (\dpnf). 
In this form, each disjunct corresponds to a punctual product term, and conflicts can be localized 
by analyzing these terms individually. 
We prove that transformation into \dpnf\ preserves semantics, and we establish 
soundness and completeness of the conflict-detection procedure 
(Algorithm~\ref{fig:conflict-extraction}) with respect to the definition above. 
This ensures that every punctual conflict present in a formula can be effectively detected, 
and that no spurious conflicts are introduced.

Beyond detection, we introduce the measure of \emph{conflict density} to quantify the 
proportion of conflicting punctual terms in a formula. 
Formally, conflict density is defined as the ratio between the number of detected punctual conflicts 
and the total number of disjunctive product terms in \dpnf. 
A high density reflects an increased level of normative inconsistency, 
reducing clarity for agents seeking to comply with the norms. 


We now start by defining a new normal form specific to our logic in order to exhibit punctual conflict by decomposing literals into punctual literals.

\subsubsection{Punctual Normal Form}\label{subsec:pnf}

We want to syntactically rewrite any literal from a formula to a combination of punctual literals. 
Any non-punctual interval \(I = [x,y]\) with \(x \neq y\) can be decomposed as
\[
I = [x,x] \cup [x{+}1,y],
\]
and, by orienting the equivalences \textbf{ObDis} and \textbf{FConj}, we obtain the following rewriting rules:

\begin{figure}[h]
\centering
\fbox{%
\ensuremath{
\begin{aligned}
\frac{x \neq y}{
  \ob{(\{[x,y]\} \cup \is)}{a}
  \to
  \ob{\{[x,x]\}}{a} \sqcup \ob{(\{[x{+}1,y]\} \cup \is)}{a}
}
&\ \textbf{(RightPunctOb)}
\\[1.5ex]
\frac{x \neq y}{
  \forb{(\{[x,y]\} \cup \is)}{a}
  \to
  \forb{\{[x,x]\}}{a} \sqcap \forb{(\{[x{+}1,y]\} \cup \is)}{a}
}
&\ \textbf{(RightPunctF)}
\end{aligned}
}}
\caption{Literal-to-right punctual decomposition rules}
\label{deccompressrules}
\end{figure}

\begin{example}
For $\ob{\{[2,4],[6,8]\}}{a}$, applying \textbf{RightPunctOb} yields
\[
\ob{\{[2,4],[6,8]\}}{a}
\to
\ob{\{[2,2]\}}{a} \sqcup \ob{\{[3,4],[6,8]\}}{a},
\]
introducing the punctual literal $\ob{\{[2,2]\}}{a}$.
\end{example}

Repeated application of these rules unrolls non-punctual intervals until their upper bounds. However, prohibitions may include infinite intervals (e.g.\ $[k,\infty]$), making unrestricted expansion non-terminating. To ensure finiteness, we define a bounded variant.

\begin{definition}[Punctual Normal Form up to \(k\)]
Let \(k \in \mathbb{N}\).  
A formula $\phi$ is in \emph{punctual normal form up to \(k\)} if every literal in $\phi$ is either:
\begin{itemize}
  \item a punctual literal $\ob{\{[t,t]\}}{a}$ or $\forb{\{[t,t]\}}{a}$ with \(t \le k\), or
  \item a literal $\ob{\is}{a}$ or $\forb{\is}{a}$ such that $\min(\is) > k$.
\end{itemize}
\end{definition}

We now guard the previous rules by a cutoff point \(k\), as shown below.

\begin{figure}[h]
\centering
\fbox{%
\ensuremath{
\begin{aligned}
\frac{x \neq y \ \land\ x \le k}{
  \ob{(\{[x,y]\} \cup \is)}{a}
  \to
  \ob{\{[x,x]\}}{a} \sqcup \ob{(\{[x{+}1,y]\} \cup \is)}{a}
}
&\ \textbf{(RightPunctOb$^k$)}
\\[1.5ex]
\frac{x \neq y \ \land\ x \le k}{
  \forb{(\{[x,y]\} \cup \is)}{a}
  \to
  \forb{\{[x,x]\}}{a} \sqcap \forb{(\{[x{+}1,y]\} \cup \is)}{a}
}
&\ \textbf{(RightPunctF$^k$)}
\end{aligned}
}}
\caption{Literal-to-right punctual decomposition rules up to a finite bound \(k\)}
\label{deccompressrulesbound}
\end{figure}

\begin{example}[Applying \textbf{RightPunctF$^k$} to $\forb{\{[2,4],[8,24]\}}{\delAtGate}$ with $k=16$]
\begin{align*}
\ell &:= \forb{\{[2,4],[8,24]\}}{\delAtGate} \\
&\to \forb{\{[2,2]\}}{\delAtGate} \sqcap \forb{\{[3,4],[8,24]\}}{\delAtGate} \\
&\to \forb{\{[2,2]\}}{\delAtGate} \sqcap \forb{\{[3,3]\}}{\delAtGate}
    \sqcap \cdots
    \sqcap \forb{\{[16,16]\}}{\delAtGate}
    \sqcap \forb{\{[17,24]\}}{\delAtGate}.
\end{align*}
No further rule applies beyond \(k=16\), yielding the punctual normal form up to the bound.
\end{example}

\begin{definition}[Transformer to Punctual Normal Form up to \(k\)]\label{def:pnf}
Let $\phi\in\TDDLfm$ and \(k\in\mathbb{N}\).  
The recursive function $\pnf(\phi,k)$ computes the punctual normal form of $\phi$ up to $k$:
\[
\pnf(\phi,k) :=
\begin{cases}
\bigsqcup_{t\in\is\ominus[k+1,\infty]}\ob{\{[t,t]\}}{a} \sqcup \ob{\is\cap[k+1,\infty]}{a}
& \text{if } \phi=\ob{\is}{a}, \\[1ex]
\bigsqcap_{t\in\is\ominus[k+1,\infty]}\forb{\{[t,t]\}}{a} \sqcap \forb{\is\cap[k+1,\infty]}{a}
& \text{if } \phi=\forb{\is}{a}, \\[1ex]
\pnf(\phi_1,k)\sqcup\pnf(\phi_2,k)
& \text{if } \phi=\phi_1\sqcup\phi_2, \\[0.5ex]
\pnf(\phi_1,k)\sqcap\pnf(\phi_2,k)
& \text{if } \phi=\phi_1\sqcap\phi_2.
\end{cases}
\]
Here $\is\ominus[k+1,\infty]$ restricts $\is$ to time points $\le k$.
\end{definition}

\begin{example}[$\pnf(\UC_1',16)$]
For
\[
\UC_1' := 
\ob{\{[9,16]\}}{\delAtGate} 
\sqcap 
\forb{\{[2,4],[8,24]\}}{\delAtGate} 
\sqcap 
\forb{\{[10,14]\}}{\delAtPark},
\]
we obtain:
\begin{align*}
\pnf(\UC_1',16)
&= \left(\bigsqcup_{t=9}^{16}\ob{\{[t,t]\}}{\delAtGate}\right)
   \sqcap
   \left(\bigsqcap_{t=10}^{14}\forb{\{[t,t]\}}{\delAtPark}\right)\\
&\quad\sqcap
   \left(\bigsqcap_{t=2}^{4}\forb{\{[t,t]\}}{\delAtGate}
   \sqcap
   \bigsqcap_{t=8}^{16}\forb{\{[t,t]\}}{\delAtGate}
   \sqcap
   \forb{\{[17,24]\}}{\delAtGate}\right).
\end{align*}
Intervals exceeding the bound remain non decomposed, ensuring termination.
\end{example}


We now compare the syntactic size of a formula with that of its punctual normal form.

\begin{lemma}[Size Blow-Up of Literals under \pnf]\label{lem:pnf-literal-blowup}
Let $\ell = \monadop{D}{\is}{a}$ be a literal of \TDDLfm, where $D \in \{\mathsf{O}, \mathsf{F}\}$, and let $k \in \mathbb{N}$ be a finite bound. Then:
\[
\frac{\size{\pnf(\ell,k)}}{\size{\ell}} 
\le 5\,\expf(\is) - \frac{1}{\card(\is)} ,
\]
where $\expf(\is) := \frac{\size{\is}}{\card(\is)}$ is the \emph{expansion factor} of the interval set $\is$.
\end{lemma}

\begin{proof}
For a literal $\ell = \monadop{D}{\is}{a}$,
\[
\size{\ell} = 2 + 2\card(\is),
\]
counting the operator, action, and the two numeric bounds per interval.

Under $\pnf$, each time point $t$ in $\is \ominus [k{+}1,\infty]$ becomes a punctual literal $\monadop{D}{\{[t,t]\}}{a}$, connected by conjunctions or disjunctions depending on $D$. The number of punctual literals is at most $\size{\is}$, and the number of binary connectives is $\size{\is} - 1$.

Each punctual literal contributes a fixed size of $4$, giving
\[
\size{\pnf(\ell,k)} \le 4\size{\is} + (\size{\is}-1) + C 
= 5\size{\is} - 1 + C,
\]
where $C$ accounts for a possible tail term and is absorbed in the bound.

Hence,
\[
\frac{\size{\pnf(\ell,k)}}{\size{\ell}}
\le \frac{5\size{\is}-1}{2+2\card(\is)}
= \frac{5\expf(\is)\card(\is)-1}{2+2\card(\is)}
\le 5\,\expf(\is) - \frac{1}{\card(\is)} .
\]
\end{proof}

\begin{lemma}[Formula Size Blow-Up and Average Expansion Factor]\label{lem:pnf-size-expansion}
Let $\phi$ be a formula in \TDDLfm\ and $k \in \mathbb{N}$ a finite bound.
Let $\phi_x$ be the set of literals of $\phi$, and $\mathcall{I}_\phi$ the set of interval sets occurring in those literals.
Define the \emph{average expansion factor} of $\phi$ as:
\[
\expf_a(\phi) := 
\frac{1}{\card(\mathcall{I}_\phi)}
\sum_{\is \in \mathcall{I}_\phi} \expf(\is).
\]
Then the size of $\pnf(\phi,k)$ grows linearly with both $\expf_a(\phi)$ and $\size{\phi}$:
\[
\size{\pnf(\phi,k)} = 
\mathcal{O}\big(\expf_a(\phi)\cdot \size{\phi}\big).
\]
\end{lemma}


\subsubsection{A \tool{DPNF} Algorithm for Enumerating Punctual Conflicts}\label{subsec:dpnf}

To systematically expose all punctual conflicts specified by a formula, we exploit the punctual and disjunctive normal forms introduced earlier.  
Given $\phi \in \TDDLfm$, we first transform it into $\pnf(\phi,k)$, where $k$ is the maximal time point appearing in any obligation literal of $\phi$.  
Next, we convert $\pnf(\phi,k)$ into its disjunctive normal form $\dnf$, producing a disjunction of product terms in which punctual conflicts can be directly pattern-matched.  
Algorithm~\ref{fig:conflict-extraction} implements this procedure.

\begin{minipage}{0.95\textwidth}
\begin{algorithm}[H]
\caption{Procedure \textsc{PunctualConflicts} \mathcall{PC}}
\label{fig:conflict-extraction}
\KwIn{A formula $\phi \in \TDDLfm$}
\KwOut{A set $\mathcall{PC}$ of tuples $(\pt, \mathcall{C})$ where $\pt$ is a product term and $\mathcall{C}$ is a set of punctual conflicts in $\pt$}

\BlankLine
$k \gets$ \textsc{MaxOPoint}$(\phi)$ \tcp*{Max obligation time point in $\phi$}

$\phi_{\text{pnf}} \gets \pnf(\phi, k)$ \tcp*{Punctual normal form up to $k$}

$\phi_{\text{dnf}} \gets \dnf(\phi_{\text{pnf}})$ \tcp*{Convert to disjunctive normal form}

$\mathcall{PC} \gets \emptyset$ \tcp*{Initialize conflict set}

\ForEach{product term $\pt$ in $\phi_{\text{dnf}}$}{
    $\mathcall{C} \gets \emptyset$ \tcp*{Initialize local conflict set}
    
    \ForEach{pair of literals $(\ell_1, \ell_2)$ in $\pt$}{
        \If{$(\ell_1, \ell_2)$ matches \textbf{P-Deon-Conf} or \textbf{P-Ont-Conf}}{
            $\mathcall{C} \gets \mathcall{C} \cup \{\ell_1 \sqcap \ell_2\}$ \tcp*{Add conflict}
        }
    }
    \If{$\mathcall{C} \neq \emptyset$}{
        $\mathcall{PC} \gets \mathcall{PC} \cup \{(\pt, \mathcall{C})\}$ \tcp*{Add conflict tuple}
    }
}
\Return $\mathcall{PC}$

\end{algorithm}
\end{minipage}

Here, \textsc{MaxOPoint}$(\phi)$ returns the largest finite time point from any obligation interval in $\phi$.  
The algorithm then scans each product term of the disjunctive form and records all literal pairs matching the deontic or ontic conflict patterns, returning them as tuples $(\pt,\mathcall{C})$.

\begin{example}[Conflict detection and density]\label{ex:easy}
To illustrate, consider a compact specification combining both deontic and ontic punctual conflicts:
\[
\phi := \ob{\{[1,2]\}}{\delAtGate} 
\sqcap 
\forb{\{[2,5]\}}{\delAtGate} 
\sqcap 
\ob{\{[1,2]\}}{\pickU}.
\]
The maximal obligation time point is $k=2$.  
Applying $\pnf(\phi,2)$ expands obligations and prohibitions up to $t\le2$, while retaining the tail $[3,5]$.  
Subsequent $\dnf$ and conflict extraction yield the results summarized in Table~\ref{table:conflict-analysis}.

\begin{table}
    \centering
    \renewcommand{\arraystretch}{1.5}
    \begin{tabular}{|l|p{12cm}|c|}
    \hline
    \textbf{Step} & \textbf{Value} & \textbf{Size} \\
    \hline
    $\phi$ 
    & 
    $\ob{\{[1,2]\}}{\delAtGate} \sqcap \forb{\{[2,5]\}}{\delAtGate} \sqcap \ob{\{[1,2]\}}{\pickU}$
    & 14 \\
    \hline
    $\pnf(\phi,2)$ 
    & 
    $\left( \ob{\{[1,1]\}}{\delAtGate} \sqcup \ob{\{[2,2]\}}{\delAtGate} \right) 
    \sqcap 
    \left( \forb{\{[2,2]\}}{\delAtGate} \sqcap \forb{\{[3,5]\}}{\delAtGate} \right)
    \sqcap 
    \left( \ob{\{[1,1]\}}{\pickU} \sqcup \ob{\{[2,2]\}}{\pickU} \right)$
    & 33 \\
    \hline
    $D\pnf(\phi,2))$ 
    & 
    $
    \begin{aligned}
    \left(
        \ob{\{[1,1]\}}{\delAtGate}
        \sqcap \forb{\{[2,2]\}}{\delAtGate}
        \sqcap \forb{\{[3,5]\}}{\delAtGate}
        \sqcap \ob{\{[1,1]\}}{\pickU}
      \right)\,\underline{pt_1}
      \\
      \sqcup\;
      \left(
        \ob{\{[1,1]\}}{\delAtGate}
        \sqcap \forb{\{[2,2]\}}{\delAtGate}
        \sqcap \forb{\{[3,5]\}}{\delAtGate}
        \sqcap \ob{\{[2,2]\}}{\pickU}
      \right)\,\underline{pt_2}
      \\
      \sqcup\;
      \left(
        \ob{\{[2,2]\}}{\delAtGate}
        \sqcap \forb{\{[2,2]\}}{\delAtGate}
        \sqcap \forb{\{[3,5]\}}{\delAtGate}
        \sqcap \ob{\{[1,1]\}}{\pickU}
      \right)\,\underline{pt_3}
      \\
      \sqcup\;
      \left(
        \ob{\{[2,2]\}}{\delAtGate}
        \sqcap \forb{\{[2,2]\}}{\delAtGate}
        \sqcap \forb{\{[3,5]\}}{\delAtGate}
        \sqcap \ob{\{[2,2]\}}{\pickU}
      \right)\,\underline{pt_4}
    \end{aligned}
    $
    & 76 \\
    \hline
    $\mathcall{PC}(\phi)$ 
    & 
    $
    \begin{aligned}
    &\big(\pt_1,\{\ob{\{[1,1]\}}{\delAtGate} \sqcap \ob{\{[1,1]\}}{\pickU}\}\big), \\
    &\big(\pt_3,\{\ob{\{[2,2]\}}{\delAtGate} \sqcap \forb{\{[2,2]\}}{\delAtGate} \}\big)\\
    &\big(\pt_4,\{\ob{\{[2,2]\}}{\delAtGate} \sqcap \forb{\{[2,2]\}}{\delAtGate}, \ob{\{[2,2]\}}{\delAtGate} \sqcap  \ob{\{[2,2]\}}{\pickU}\} \big)
    \end{aligned}
    $
    & -- \\
    \hline
    \end{tabular}
    \caption{Normal form analysis with sizes for $\phi := \ob{\{[1,2]\}}{\delAtGate} \sqcap \forb{\{[2,5]\}}{\delAtGate} \sqcap \ob{\{[1,2]\}}{\pickU}$.}
    \label{table:conflict-analysis}
    \end{table}

Three punctual conflicts are found:  
(1) an ontic conflict at $t=1$ between $\ob{\{[1,1]\}}{\delAtGate}$ and $\ob{\{[1,1]\}}{\pickU}$;  
(2) a deontic conflict at $t=2$ between $\ob{\{[2,2]\}}{\delAtGate}$ and $\forb{\{[2,2]\}}{\delAtGate}$;  
(3) a mixed case at $\pt_4$ containing both.
\end{example}

\begin{lemma}[\dpnf preserves semantics]\label{lem:dpnf-semantics}
For any $\phi\in\TDDLfm$ and $k\in\mathbb{N}$,
\[
\dutyclass{\phi}
=\dutyclass{\dnf(\pnf(\phi,k))},
\qquad
\text{i.e.}\quad
\dnf(\pnf(\phi,k))\dutyequiv \phi.
\]
\end{lemma}

\begin{proof}
By Lemma~\ref{lemma:literal-compression}, $\pnf(\phi,k)\dutyequiv\phi$.  
By Lemma~\ref{lem:dnf}(i), $\dnf(\phi)\dutyequiv\phi$.  
Composing these yields $\dnf(\pnf(\phi,k))\dutyequiv\phi$.
\end{proof}

Before proving correctness, we establish the \emph{structural invariants} preserved by the
punctual and disjunctive normalizations. These invariants ensure that the transformations
$\pnf$ and $\dnf$ maintain the Boolean hierarchy and the syntactic relationships between
literals in~$\phi$. In particular:
\begin{enumerate}[(i)]
\item the lowest upper common Boolean operator (\LUCO) between literals is preserved;
\item ancestor relations between literals are maintained; and
\item punctual descendants are introduced exactly at overlapping time points.
\end{enumerate}
Together, these guarantees allow the algorithm to detect every punctual conflict without
creating spurious ones.

\begin{lemma}[\LUCO preservation under $\pnf$]\label{lem:pnf-luco}
Let $\phi\in\TDDLfm$, $k\in\mathbb{N}$, and assume unique occurrences of literals in~$\phi$.
For any literals $\ell,\ell'$ in $\phi$ and their punctual (or residual) descendants
$\hat\ell,\hat\ell'$ in $\pnf(\phi,k)$, we have
\[
\LUCO_{\pnf(\phi,k)}(\hat\ell,\hat\ell')=\LUCO_\phi(\ell,\ell').
\]
\end{lemma}

\begin{proof}
By Definition~\ref{def:pnf}, $\pnf$ acts as homomorphism on conjunction and disjunction.
Transformations occur locally: each literal is unfolded \emph{in place} into a disjunction
(for $\tool{O}$) or conjunction (for $\tool{F}$) of punctual or residual components.
No Boolean connective along the path from root to leaf is moved across levels.
Hence the lowest upper common operator (\LUCO) dominating both positions remains unchanged.
\end{proof}

\begin{lemma}[Literal ancestor preservation under $\pnf$]\label{lem:pnf-ancestor}
Let $\phi\in\TDDLfm$ and $k\in\mathbb{N}$. Then $\pnf(\phi,k)$ satisfies
\emph{literal ancestor preservation} of $\phi$ (Definition~\ref{def:lit-ancestor}).
\end{lemma}

\begin{proof}
(\emph{Downward}) Each literal $\ell'$ produced by $\pnf(\phi,k)$ descends from a unique
literal $\ell$ in~$\phi$ with identical modality and action. Its interval set is contained
in that of~$\ell$, corresponding to punctual points $t\le k$ or the residual tail.

(\emph{Upward}) For any literal $\ell$ in~$\phi$, its descendants in $\pnf(\phi,k)$ are:
(a) for $\tool{O}$, the family
$\{\ob{\{[t,t]\}}{a}\mid t\in\is\cap[0,k]\}$, possibly plus
$\ob{\is\cap[k{+}1,\infty]}{a}$;
(b) for $\tool{F}$, the analogous conjunctive family.
Their nearest common Boolean operator in $\pnf(\phi,k)$ is the one introduced locally at
$\ell$—a disjunction for $\tool{O}$ or conjunction for $\tool{F}$, and by
\textbf{ObDis}/\textbf{FConj} the resulting expression is syntactically equivalent to~$\ell$.
\end{proof}

\begin{lemma}[Witness punctualization under $\pnf$]\label{lem:witness-punct-pnf}
Let $\phi\in\TDDLfm$ with unique literal occurrences and
$k=\textsc{MaxOPoint}(\phi)$. Suppose literals
$\ell=\monadop{D}{\is}{a}$ and $\ell'=\monadop{D'}{\is'}{a'}$
occur in~$\phi$ with $\LUCO_\phi(\ell,\ell')=\sqcap$ and share some
$t\in\is\cap\is'$ where $t\le k$. Then $\pnf(\phi,k)$ contains punctual descendants
$\hat\ell^p=\monadop{D}{\{[t,t]\}}{a}$ and
$\hat\ell^{\prime p}=\monadop{D'}{\{[t,t]\}}{a'}$
that remain under the same conjunctive~\LUCO relation.
\end{lemma}

\begin{proof}
From Definition~\ref{def:pnf}, $t\le k$ and $t\in\is,\is'$ ensure creation of punctual
descendants exactly at the positions of $\ell$ and $\ell'$. By Lemma~\ref{lem:pnf-luco},
the corresponding conjunctive~\LUCO is preserved.
\end{proof}

\begin{lemma}[\LUCO preservation and localization under $\dnf$]\label{lem:dnf-luco}
Let $\phi\in\TDDLfm$ with unique literal occurrences.
\begin{enumerate}[(i)]
\item \textbf{LUCO preservation.}  
For any literals $\ell,\ell'$ in $\phi$ and their descendants
$\hat\ell,\hat\ell'$ in $\dnf(\phi)$ at corresponding positions,
\[
\LUCO_{\dnf(\phi)}(\hat\ell,\hat\ell')=\LUCO_\phi(\ell,\ell').
\]
\item \textbf{Localization to product terms.}  
If $\LUCO_\phi(\ell,\ell')=\sqcap$, then some product term $\pt$ of $\dnf(\phi)$ contains
both $\hat\ell$ and $\hat\ell'$.  
If $\LUCO_\phi(\ell,\ell')=\sqcup$, no product term contains both.
\end{enumerate}
\end{lemma}

\begin{proof}
The $\dnf$ normalization is obtained by orienting distributivity
(e.g.\ $\phi_1\sqcap(\phi_2\sqcup\phi_3)\!\to\!(\phi_1\sqcap\phi_2)\sqcup(\phi_1\sqcap\phi_3)$)
Moreover, applying associativity and commutativity.  
These rewritings never invert $\sqcap$/$\sqcup$ but only propagate one operator outward,
So dominance relations along root-to-leaf paths remain intact.

(i) Suppose, for contradiction, that a pair of literals changes its \LUCO after
normalization. Then their former lowest common operator either ceases to be common or
lowest. Since $\dnf$ introduces no deeper operator and preserves labels, neither case can
occur; hence \LUCO is preserved.

(ii) Under the cross-product semantics of $\dnf$, a conjunctive node yields product terms
pairing one choice from each branch, so descendants under the same $\sqcap$ co-occur,
while those under $\sqcup$ are separated.
\end{proof}

\begin{example}[\LUCO preservation under $\dnf$]
For the formula of Example~\ref{ex:AST},
\[
\phi = \big((\ell_1 \sqcup \ell_2)\sqcap \ell_3\big)\sqcup\big(\ell_4 \sqcap \ell_5\big),
\qquad
\dnf(\phi) = (\ell_1 \sqcap \ell_3)\sqcup(\ell_2 \sqcap \ell_3)\sqcup(\ell_4 \sqcap \ell_5).
\]
The \LUCO relations are preserved:
\[
\begin{aligned}
\LUCO_{\dnf(\phi)}(\ell_1,\ell_3)&=\sqcap=\LUCO_{\phi}(\ell_1,\ell_3)\\
\LUCO_{\dnf(\phi)}(\ell_2,\ell_3)&=\sqcap=\LUCO_{\phi}(\ell_2,\ell_3),\\
\LUCO_{\dnf(\phi)}(\ell_4,\ell_5)&=\sqcap=\LUCO_{\phi}(\ell_4,\ell_5),\\
\LUCO_{\dnf(\phi)}(\ell_1,\ell_2)&=\sqcup=\LUCO_{\phi}(\ell_1,\ell_2).
\end{aligned}
\]
Thus, the \LUCO label is invariant, even though its syntactic position may shift.
\end{example}

\medskip
The preceding lemmas ensure that the normalization pipeline preserves both
syntactic structure (\LUCO) and lineage of literals (\LAP). Hence, any punctual conflict
specified in~$\phi$ remains traceable in $\dnf(\pnf(\phi,k))$, allowing for sound and
complete conflict extraction.

\begin{theorem}[Correctness of Algorithm~\ref{fig:conflict-extraction}]
\label{thm:conflict-sound-complete}
Let $\phi$ be any formula in \TDDLfm, and let $k=\textsc{MaxOPoint}(\phi)$.  
Then Algorithm~\ref{fig:conflict-extraction} is \emph{sound and complete} for detecting
punctual conflicts in~$\phi$, meaning the set $\mathcall{PC}(\phi)$ returned by the algorithm
contains \emph{exactly all} the punctual conflicts specified by~$\phi$.
\end{theorem}

\begin{proof}
\textbf{(I) Soundness.}  
For any $(\pt,\mathcall{C})\in\mathcall{PC}(\phi)$ and $\hat\ell\sqcap\hat\ell'\in\mathcall{C}$,
the literals $\hat\ell,\hat\ell'$ are punctual and match either
\textbf{(P-Deon-Conf)} or \textbf{(P-Ont-Conf)} within some product term of
$\dnf(\pnf(\phi,k))$.  
By Lemma~\ref{lem:pnf-ancestor}, each has an ancestor $\ell,\ell'$ in~$\phi$ with the
same modality and covering~$t$.  
Lemmas~\ref{lem:pnf-luco} and~\ref{lem:dnf-luco} guarantee that their \LUCO is preserved,
so $\ell\sqcap\ell'$ is in fact specified in~$\phi$.
Hence, no \emph{fabricated} conflicts are introduced.

\smallskip
\textbf{(II) Completeness.}  
\begin{enumerate}[(1)]
\item \emph{All relevant time points exposed.}  
Choosing $k=\textsc{MaxOPoint}(\phi)$ unfolds every point relevant to
$\tool{O}/\tool{O}$ or $\tool{O}/\tool{F}$ conflicts.  
No conflict involves two prohibitions.  
By Lemmas~\ref{lem:pnf-luco} and~\ref{lem:dnf-luco}, all \LUCO relations are preserved, so no punctual literal is removed.

\item \emph{All conflicts localized and enumerated.}  
If the literals $\ell_i,\ell_j$ form a conflict in~$\phi$ with
$\LUCO_\phi(\ell_i,\ell_j)=\sqcap$ and shared $t$, then by
Lemma~\ref{lem:witness-punct-pnf} punctual descendants appear in $\pnf(\phi,k)$
under the same~\LUCO.  
By Lemma~\ref{lem:dnf-luco}(ii) they co-occur in a product term of
$\dnf(\pnf(\phi,k))$. The algorithm checks all pairs, ensuring complete enumeration.

% \item \emph{All conflict types covered.}  
% By Lemma~\ref{lem:typeccomp}, punctual conflicts are exactly ontic or deontic.
% Algorithm~\ref{fig:conflict-extraction} matches precisely these two cases.
\end{enumerate}
Combining (I) and (II) establishes the theorem.
\end{proof}

After establishing the soundness and completeness of
Algorithm~\ref{fig:conflict-extraction}, we analyze the cost of the full normalization chain
on which the algorithm depends. The growth arises from two stages:
(i) \emph{punctual expansion} in $\pnf(\phi,k)$, which replaces each interval set by a Boolean
combination of punctual literals up to~$k$, and
(ii) the \emph{cross-product blow-up} caused by distributing conjunctions over the disjunctions
introduced by~$\pnf$.

\begin{theorem}[Complexity of full normalization]\label{complexityofconf}
Let $\phi$ be a formula in \TDDLfm and let $k\in\mathbb{N}$ be a finite time bound.
The transformation $\phi\mapsto\dnf(\pnf(\phi,k))$ has worst-case space complexity
exponential in both the average expansion factor of the interval sets in~$\phi$
and the size of~$\phi$.
\end{theorem}

\begin{proof}
We analyze the two stages separately.

\textbf{Step 1: Punctual normalization.}
By Lemma~\ref{lem:pnf-size-expansion}, the size of $\pnf(\phi,k)$ is bounded linearly in
$\size{\phi}$ and in the average expansion factor~$\expf_a(\phi)$:
\[
\size{\pnf(\phi,k)}\in\mathcall{O}\big(\expf_a(\phi)\cdot\size{\phi}\big).
\]
Hence this step is polynomial in $\size{\phi}$ when $\expf_a(\phi)$ is bounded.

\textbf{Step 2: Disjunctive normalization.}
Lemma~\ref{lem:dnf} guarantees that every formula can be rewritten as an equivalent DNF
$\phi'=\bigsqcup_i\phi_i'$, but distributing conjunctions over disjunctions introduces an
exponential cross-product. Each obligation literal $\ob{\is}{a}$ in $\pnf(\phi,k)$ yields a
disjunction of $\size{\is}$ punctual obligations, and each such disjunction multiplies the
number of disjunct. Therefore, the number of product terms in
$\dnf(\pnf(\phi,k))$ is exponential in the number of punctual obligations produced by $\pnf$,
which itself is linear in $\expf_a(\phi)\cdot\size{\phi}$.

Consequently,
\[
\size{\dnf(\pnf(\phi,k))}\in
\mathcall{O}\!\left(2^{\expf_a(\phi)\cdot\size{\phi}}\right),
\]
and this bound characterizes the worst-case space of the normalization chain.
\end{proof}



\subsection{Conflict Density}

We now introduce a quantitative view of conflicts in \TDDLfm.  
The \emph{conflict density} of a formula measures how frequently conflicts occur within its punctual representation.  
A high conflict density indicates a restrictive or overloaded specification: it reduces the set of feasible behaviors, complicates compliance checking, and  complicates its interpretation.  
We obtain a simple diagnostic tool for refining normative specifications by the following formal definition.

\begin{definition}[Conflict density]\label{def:Conflict density-measure}
Let $\phi$ be a formula in \TDDLfm and let $k=\textsc{MaxOPoint}(\phi)$.  
The \defn{conflict density} of $\phi$, written $\cd(\phi)$, is the ratio between the number of conflicting product terms and the total number of product terms in $\dnf(\pnf(\phi,k))$:
\[
\cd(\phi) := \frac{\size{\mathcall{PC}(\phi)}}{\Xi(\phi)}.
\]
Where:
\begin{itemize}
    \item $\size{\mathcall{PC}(\phi)}$ is the number of product terms identified as conflicting by Algorithm~\ref{fig:conflict-extraction}, and
    \item $\Xi(\phi)$ is the total number of product terms in $\dnf(\pnf(\phi,k))$.
\end{itemize}
\end{definition}

Conflict density captures the proportion of punctual obligations involved in conflicts.  
A formula with $\cd(\phi)=0$ is \defn{conflict-free}; when $\cd(\phi)=1$ it is \defn{fully conflicting}.

\begin{example}[Conflict density computation]
From Table~\ref{table:conflict-analysis} for Example~\ref{ex:easy}, we have:
\[
\Xi(\phi)=4, \qquad \size{\mathcall{PC}(\phi)}=3.
\]
Hence,
\[
\cd(\phi)=\frac{3}{4}=0.75.
\]
Thus, $75\%$ of the product terms in $\phi$ contain conflicts, signaling an over-constrained specification.
\end{example}

\begin{example}[Conflict density for \UC]\label{ex:Conflict density-UC1-UC2}
For our use case, Algorithm~1 reports 13 deontic punctual conflicts: five on the action $\delAtPark$ at time points $10,11,12,13,14$, and eight on the action $\delAtGate$ at each time point in $[9,16]$. Consequently,
$$
\size{\mathcall{PC}(\UC)}=13, \qquad
\Xi(\UC)=16, \qquad
\cd(\UC)=\tfrac{13}{16}\approx 0.81.
$$
About $81\%$ of the punctual obligations in $\UC$ are involved in conflicts.

\end{example}


A formula with $\cd(\phi)=0$ is \defn{conflict-free}; a formula with $\cd(\phi)=1$ is \defn{fully conflicting} in the sense that every product term in its \dpnf contains at least one punctual conflict.  The following section lifts these punctual patterns and the conflict density measure to a proof-theoretic level, by relating conflicts in \TDDLfm\ to minimal unsatisfiable subsets.

\section{Semantic Characterization and Elimination of Timed Normative Conflicts}\label{sec:unsat-conflicts}

This section lays the semantic basis for timed normative conflicts. We first recall propositional unsatisfiability, unsatisfiable cores, and minimal unsatisfiable subsets (MUS). We then transfer these notions to \TDDLfm\ by viewing product terms of the disjunctive punctual normal form (\dpnf) as local clause sets. The key outcome is that punctual conflicts in \TDDLfm\ coincide with MUSes over punctual literals inside a single product term. This yields an exact assessment and explainability for formula unsatisfiability via conflict density and supports conflict-free rewriting. We close with the syntactic cost of conflict elimination.

\subsection{Unsatisfiable Cores and MUS in Propositional Logic}

A propositional formula \(F\) is \emph{satisfiable} if some valuation makes \(F\) true, and \emph{unsatisfiable} otherwise. If \(F\) is unsatisfiable, an \emph{unsatisfiable core} is any subset \(F'\subseteq F\) that is unsatisfiable. Cores isolate unsatisfiable sub-formulas but may contain clauses that are not necessary for proving unsatisfiability of the overall formula, as studied in \cite{Cimatti2007UnsatCores}.

To address this limitation, the notion \emph{minimal unsatisfiable subset} (MUS) refines unsatisfiable cores by requiring irreducibility: an MUS is an unsat core \(U\subseteq F\) such that removing any clause makes \(U\) satisfiable. MUSes represent irreducible contradictions and are explored only when the studied formula is unsatisfiable. The structure and computation of MUSes have been widely studied \cite{MarquesSilva2010MUSsurvey,Liffiton2008MUS}, and it is well known that an unsatisfiable formula can contain several MUSes. A single clause may also appear in multiple MUSes, since different minimal combinations of clauses can independently give rise to unsatisfiability \cite{Liffiton2005AllMUS}.

In our setting, this perspective is guided by the output of our conflict detection procedure (Algorithm~\ref{fig:conflict-extraction}): conflicts surface locally inside individual product terms of \dpnf, not across the disjunction. We therefore analyze MUSes \emph{per product term}, where the roles of clauses are played by punctual literals. The minimal unsatisfiable subsets of these literals are exactly the punctual conflicts that causes unsatisfiability in \TDDLfm.

\subsection{From Propositional MUSes to Punctual MUSes in \TDDLfm}

In the propositional setting, MUS analysis is performed on sets of clauses. 
A clause belongs to an MUS when it is part of the smallest subset of clauses that cannot all be true at the same time. 
In \TDDLfm, the surface syntax contains interval-based obligations and prohibitions, but after unfolding to disjunctive punctual normal form, the structure becomes closer to the propositional one.
Let \(\phi\) be a \TDDLfm\ formula. 
For \(k=\textsc{MaxOPoint}(\phi)\),
\[
  \dpnf(\phi,k) \;=\; \bigsqcup_i \pt_i
\]
enumerates all product terms \(\pt_i\) that are conjunctions of punctual obligations and prohibitions that may be active up to \(k\). 
Each \(\pt_i\) describes one complete punctual scenario: for each relevant time point and action it fixes whether the action is required, forbidden, or unconstrained. 
Satisfiability of \(\pt_i\) is purely local: \(\pt_i\) is satisfiable if and only if there exists a timed trace that meets all these punctual requirements.

This suggests the following correspondence. 
At the level of \dpnf, the global formula \(\phi\) behaves like a disjunction of local clause sets, one per product term. 
Unsatisfiability of \(\phi\) means that \emph{every} such local scenario is impossible, therefore every product term is unsatisfiable. 
Conversely, if some product term is satisfiable, then \(\phi\) is satisfiable because that term already provides a compliant behaviour. 
The natural analogue of a clause level MUS is then not a subset of the whole formula, but a minimal unsatisfiable subset of punctual literals \emph{inside a single product term}. 
This is exactly what we call a punctual MUS.

Intuitively, a punctual MUS collects the smallest set of punctual prescriptions that cannot be jointly followed at the concrete times they refer to. 
From a normative point of view, it isolates the exact punctual situation where an agent faces an impossible choice. 
From a SAT viewpoint, it is the minimal unsatisfiable core at the level of punctual literals that sits inside one product term of the \dpnf.

\begin{definition}[Punctual MUS]\label{def:punctual-MUS}
Let \(L=\{\ell_1,\dots,\ell_n\}\) be punctual literals taken from a single product term \(\pt_i\). 
The conjunction \(\bigsqcap_{\ell\in L}\ell\) is a \emph{punctual minimal unsatisfiable subset} if:
\begin{enumerate}[(i)]
  \item \(\bigsqcap_{\ell\in L}\ell\) is unsatisfiable under the trace semantics of \TDDLfm, and
  \item for every nonempty strict subset \(L'\subset L\), the conjunction \(\bigsqcap_{\ell\in L'}\ell\) is satisfiable.
\end{enumerate}
\end{definition}

Condition (i) states that the literals in \(L\) cannot all be enforced on any trace. 
Condition (ii) is the minimality requirement, it ensures that each literal in \(L\) is necessary for the unsatisfiability and that no smaller subset already conflicts. 
The definition is syntactic, since it speaks about inclusion between sets of literals, and semantic, since unsatisfiability is evaluated with respect to timed traces. 
Punctual MUSes therefore mirror classical MUSes, but are grounded at the level of punctual normative statements in \TDDLfm.

To understand the possible shape of punctual MUSes, we first look at the simplest building blocks. 
Single punctual literals never generate conflicts, they always have a trivial satisfying trace.

\begin{lemma}[Satisfiability of isolated punctual literals]\label{lem:punct-solo-sat}
For any \(a\in\Sigma\) and \(t\in\mathbb{N}\), both \(\ob{\{[t,t]\}}{a}\) and \(\forb{\{[t,t]\}}{a}\) are satisfiable.
\end{lemma}

\begin{proof}
Witnesses are \(\trace{(a,t)}\) for \(\ob{\{[t,t]\}}{a}\) and \(\emptytrace\) for \(\forb{\{[t,t]\}}{a}\).
\end{proof}

Conflicts, therefore, appear only when we combine punctual literals. 
We now show that there are exactly two kinds of minimal combinations that fail, which correspond to two very natural normative intuitions.

\begin{lemma}[Deontic punctual conflict is a punctual MUS]\label{lem:punct-deontic}
For any \(a\in\Sigma\) and \(t\in\mathbb{N}\), the set \(\{\ob{\{[t,t]\}}{a},\ \forb{\{[t,t]\}}{a}\}\) is a punctual MUS.
\end{lemma}

\begin{proof}
The conjunction is unsatisfiable, since no trace can both perform and avoid \(a\) at time \(t\). 
Minimality follows from Lemma~\ref{lem:punct-solo-sat}, each literal alone is satisfiable.
\end{proof}

\begin{lemma}[Ontic punctual conflict is a punctual MUS]\label{lem:punct-ontic}
For any distinct \(a,b\in\Sigma\) and any \(t\in\mathbb{N}\), the set \(\{\ob{\{[t,t]\}}{a},\ \ob{\{[t,t]\}}{b}\}\) is a punctual MUS.
\end{lemma}

\begin{proof}
The conjunction is unsatisfiable, since the trace semantics admits at most one action at time \(t\). 
Again, by Lemma~\ref{lem:punct-solo-sat} each singleton is satisfiable, so the pair is minimal.
\end{proof}

These two lemmas show that direct normative conflicts at a point in time (obligate and forbid the same action) and physical or behavioural impossibility at a point in time (obligate two distinct actions that cannot both happen) are punctual MUSes. 
The next lemma shows that there are no other punctual MUS patterns.

\begin{lemma}[Completeness of punctual MUS types]\label{lem:punct-completeness}
Every punctual minimally unsatisfiable subset in \TDDLfm\ is either a deontic or an ontic punctual conflict.
\end{lemma}


\begin{proof}
Exhaust over the identity of the actions and the equality of the time points. 
If the time points differ, the literals constrain different instants and can always be satisfied together. 
If they concern the same action at the same time, pairs of the form 
\(\ob{\{[t,t]\}}{a}\) with \(\ob{\{[t,t]\}}{a}\) and 
\(\forb{\{[t,t]\}}{a}\) with \(\forb{\{[t,t]\}}{a}\) 
are redundant but satisfiable, while the mixed pair 
\(\ob{\{[t,t]\}}{a}\) with \(\forb{\{[t,t]\}}{a}\) 
produces a deontic punctual conflict.

If they concern distinct actions at the same time, the pair 
\(\ob{\{[t,t]\}}{a}\) with \(\ob{\{[t,t]\}}{b}\) 
yields an ontic punctual conflict by the single–action–per–time semantics, whereas any combination that includes at least one prohibition, such as 
\(\ob{\{[t,t]\}}{a}\) with \(\forb{\{[t,t]\}}{b}\), 
remains satisfiable, since prohibitions do not force any action to occur.

\end{proof}

Soundness follows from Lemmas~\ref{lem:punct-deontic} and \ref{lem:punct-ontic}, and completeness from Lemma~\ref{lem:punct-completeness}. 
Every punctual MUS in \TDDLfm\ is therefore either deontic or ontic. 
Algorithmically, this means that conflict detection at the punctual level reduces to a simple pattern matching task inside product terms of \dpnf. 
Conceptually, it shows that all punctual minimal unsatisfiable subsets in \TDDLfm\ can be read as either “ought and ought not” for the same action at a time, or “ought and ought” for two incompatible actions at a time.


\subsection{Unsatisfiability in Terms of Conflict Density}

Let \(\cd(\phi)\) denote the fraction of product terms in \(\dpnf(\phi,k)\) that contain a punctual conflict. Write \(\Xi(\phi)\) for the number of product terms and \(\mathcall{PC}(\phi)\) for the set of conflicting product terms, so \(\cd(\phi)=\size{\mathcall{PC}(\phi)}/\Xi(\phi)\).

\begin{lemma}[Fully conflicting implies unsatisfiable]\label{lem:full-conflict-implies-unsat}
If \(\cd(\phi)=1\), then \(\phi\) is unsatisfiable.
\end{lemma}

\begin{proof}
Every product term in \(\dpnf(\phi,k)\) is unsatisfiable only if it contains a conflict. When the formula is fully conflicting it means that the number of conflicting product terms equals the number of product terms returned by the \(\dpnf(\phi,k)\), as each one is unstisfiable then the conjunction of n unsatisfiable product terms is also unsatisfiable as showed in Lemma~\ref{empty_inter_union}.
\end{proof}

\begin{theorem}[Punctual MUS structure of unsatisfiable product terms]\label{thm:mus-structure}
Let $\pt$ be a product term in $\dpnf(\phi,k)$.  
Then $\pt$ is unsatisfiable iff it contains a punctual deontic or ontic conflict.  
Moreover, each such conflict forms a minimal unsatisfiable subset of punctual literals.
\end{theorem}

\begin{proof}[Proof sketch]
If $\pt$ is unsatisfiable, minimality of the unsatisfiable conjunction of literals implies the existence of an unsatisfiable pair of punctual literals. By Lemma~\ref{lem:punct-completeness}, the only such pairs are the deontic or ontic patterns.  
Conversely, any deontic or ontic punctual conflict yields an unsatisfiable and inclusion-minimal product term, since removing literals in MUS restores satisfiability.
\end{proof}

\begin{corollary}[Unsatisfiable implies full conflict]\label{cor:unsat-implies-full-conflict}
If \(\phi\) is unsatisfiable, then \(\cd(\phi)=1\).
\end{corollary}

\begin{proof}
\(\phi\) is the disjunction of its product terms. If \(\phi\) is unsatisfiable, each product term is unsatisfiable. By Theorem~\ref{thm:mus-structure}, each contains a punctual conflict, so every term is counted in \(\mathcall{PC}(\phi)\).
\end{proof}

\begin{theorem}[Exact characterization of unsatisfiability]\label{thm:exact-unsat}
A formula \(\phi\in\TDDLfm\) is unsatisfiable if and only if \(\cd(\phi)=1\).
\end{theorem}

\begin{proof}
Combine Lemma~\ref{lem:full-conflict-implies-unsat} with Corollary~\ref{cor:unsat-implies-full-conflict}.
\end{proof}

\subsection{Semantic Preserving Conflict-free Pruning and Induced Verbosity}

When \(\cd(\phi)<1\), at least one product term is conflict-free. Pruning all conflicting terms yields an equivalent conflict-free disjunction.

\begin{theorem}[Conflict-free rewriting]\label{thm:cfr}
If \(\cd(\phi)\neq1\), there exists \(\phi'\) with \(\phi\equiv\phi'\) and \(\cd(\phi')=0\).
\end{theorem}

\begin{proof}[Proof sketch]
Compute \(k=\textsc{MaxOPoint}(\phi)\) and \(\phi_{\mathrm{dpnf}}=\bigsqcup_i \pt_i\). Use Algorithm~\ref{fig:conflict-extraction} to classify product terms. Let \(I=\{i\mid \pt_i \text{ has no punctual conflict}\}\). Set \(\phi'=\bigsqcup_{i\in I}\pt_i\). Removed terms are unsatisfiable, so \(\phi\equiv\phi'\), and by construction \(\cd(\phi')=0\).
\end{proof}

\begin{algorithm}[H]
\caption{Conflict-Free Rewriting \(\Namb\)}\label{alg:conflict-free-rewriting}
\KwIn{\(\phi\in\TDDLfm\)} \KwOut{\textbf{False} if all terms conflict, else a conflict-free \(\Namb(\phi)\)}
$k\gets\textsc{MaxOPoint}(\phi)$; \quad
\(\phi_{\mathrm{dpnf}}\gets\dnf(\pnf(\phi,k))\); \quad
\(\CF\gets\emptyset\)\;
\ForEach{product term \(\pt\) in \(\phi_{\mathrm{dpnf}}\)}{
  \If{\(\pt\) contains no deontic or ontic punctual conflict}{
    \(\CF\gets\CF\cup\{\pt\}\)
  }
}
\If{\(\CF=\emptyset\)}{\Return \textbf{False}}
\(\Namb(\phi)\gets\bigsqcup_{\pt\in\CF}\pt\); \Return \(\Namb(\phi)\)
\end{algorithm}

Conflict elimination can enlarge the formula. In particular, avoiding simultaneous obligations at the same time forces \dnf\ to retain only assignments with pairwise distinct time points, which inflates the disjunction.

\begin{example}
\[
\phi := 
\ob{\{[0,3]\}}{\mathsf{a}} \sqcap
\ob{\{[0,3]\}}{\mathsf{b}} \sqcap
\ob{\{[0,3]\}}{\mathsf{c}}.
\]
Table~\ref{table:ontic-triple-conflict} summarizes the transformation pipeline—\pnf, \dnf, conflict extraction, and the conflict-free rewriting $\Namb(\phi)$.  
The final formula is roughly $20\times$ larger than the original.

Intuitively, $\dnf(\pnf(\phi,3))$ enumerates all $4^3$ assignments of times to $(\mathsf{a},\mathsf{b},\mathsf{c})$.  
To avoid conflicts, only combinations with pairwise distinct times remain, i.e.\ $4\!\cdot\!3\!\cdot\!2=24$ product terms.

\begin{table}[h]
\centering
\renewcommand{\arraystretch}{1.4}
\begin{tabular}{|l|p{8cm}|c|}
\hline
\textbf{Step} & \textbf{Expression} & \textbf{Size} \\ \hline
$\phi$ 
& $\ob{\{[0,3]\}}{\mathsf{a}}\sqcap\ob{\{[0,3]\}}{\mathsf{b}}\sqcap\ob{\{[0,3]\}}{\mathsf{c}}$
& 18 \\ \hline
$\pnf(\phi,3)$ 
& $\big(\bigsqcup_{i=0}^{3}\ob{\{[i,i]\}}{\mathsf{a}}\big)
\sqcap\big(\bigsqcup_{i=0}^{3}\ob{\{[i,i]\}}{\mathsf{b}}\big)
\sqcap\big(\bigsqcup_{i=0}^{3}\ob{\{[i,i]\}}{\mathsf{c}}\big)$
& 59 \\ \hline
$\dnf(\pnf(\phi,3))$ 
& $\bigsqcup_{0\le i,j,k\le3}
  \big(\ob{\{[i,i]\}}{\mathsf{a}}\sqcap
       \ob{\{[j,j]\}}{\mathsf{b}}\sqcap
       \ob{\{[k,k]\}}{\mathsf{c}}\big)$
& 959 \\ \hline
Punctual conflicts 
& $\big\{
\ob{\{[t,t]\}}{\mathsf{a}}\sqcap\ob{\{[t,t]\}}{\mathsf{b}},
\ob{\{[t,t]\}}{\mathsf{a}}\sqcap\ob{\{[t,t]\}}{\mathsf{c}},
\ob{\{[t,t]\}}{\mathsf{b}}\sqcap\ob{\{[t,t]\}}{\mathsf{c}}
\mid t\!\in\!\{0,1,2,3\}\big\}$ 
& -- \\ \hline
$\Namb(\phi)$
& $\bigsqcup_{\substack{i,j,k\in\{0,1,2,3\}\\ \text{pairwise distinct}}}
  \big(\ob{\{[i,i]\}}{\mathsf{a}}\sqcap
       \ob{\{[j,j]\}}{\mathsf{b}}\sqcap
       \ob{\{[k,k]\}}{\mathsf{c}}\big)$
& 359 \\ \hline
$\size{\Namb(\phi)}/\size{\phi}$ 
& Blow-up factor & $\approx20$ \\ \hline
\end{tabular}
\caption{Conflict-elimination size comparison for 
$\phi := \ob{\{[0,3]\}}{\mathsf{a}} \sqcap \ob{\{[0,3]\}}{\mathsf{b}} \sqcap \ob{\{[0,3]\}}{\mathsf{c}}$.}
\label{table:ontic-triple-conflict}
\end{table}
\end{example}

Although this example illustrates worst case blow-ups, conflict-free formulas often admit concise equivalents by \emph{merging} punctual literals over the same action.  
Disjunctions of punctual obligations can be compacted via \textbf{ObDis}, and conjunctions of punctual prohibitions via \textbf{FConj}.

\begin{example}
\[
\UC_2' :=
\ob{\{[9,16]\}}{\delAtPark}
\sqcap
\forb{\{[10,14]\}}{\delAtPark}
\sqcap
\forb{\{[2,4],[8,24]\}}{\delAtGate}.
\]
The conflict-free rewriting $\Namb(\UC_2')$ retains the non-conflicting obligations $t\!\in\!\{9,15,16\}$.  
Table~\ref{table:refactoring-uc2} compares the original, verbose rewriting, and a merged equivalent $\UC_2''$.

\begin{table}[h]
\centering
\renewcommand{\arraystretch}{1.4}
\begin{tabular}{|l|p{10.2cm}|c|}
\hline
\textbf{Formula} & \textbf{Expression} & \textbf{Size} \\ \hline
$\UC_2'$ 
& $\ob{\{[9,16]\}}{\delAtPark}\sqcap
   \forb{\{[10,14]\}}{\delAtPark}\sqcap
   \forb{\{[2,4],[8,24]\}}{\delAtGate}$
& 16 \\ \hline
$\Namb(\UC_2')$
& $\bigsqcup_{t\in\{9,15,16\}}\!
  \Big(\ob{\{[t,t]\}}{\delAtPark}\sqcap
  \bigsqcap_{u\in[10,14]}\forb{\{[u,u]\}}{\delAtPark}\sqcap
  \bigsqcap_{v\subin\{[2,4],[8,16]\}}\forb{\{[v,v]\}}{a}\sqcap
  \forb{\{[17,24]\}}{a}\Big)$
& 94 \\ \hline
$\UC_2''$
& $\ob{\{[9,9],[15,16]\}}{\delAtPark}\sqcap
   \forb{\{[10,14]\}}{\delAtPark}\sqcap
   \forb{\{[2,4],[8,24]\}}{\delAtGate}$
& 18 \\ \hline
\end{tabular}
\caption{Refactoring a verbose conflict-free rewriting $\Namb(\UC_2')$ into a compact equivalent $\UC_2''$.}
\label{table:refactoring-uc2}
\end{table}
Here $\UC_2''$ merges the surviving punctual obligations on \delAtPark\ into a single interval set, while prohibitions on \delAtGate\ are recombined into their original form.
\end{example}

These examples motivate a strategy of \emph{controlled conflict-density management}:  
When conciseness is essential, designers may either  
(i) keep compact high-level formulas that implicitly contain ontic conflicts and defer their resolution to planning, or  
(ii) eliminate conflicts up front and refactor the resulting \dpnf\ with merging rules (\textbf{ObDis}, \textbf{FConj}) to restore compactness.  
In the next section, we introduce a generalized punctual conflict rule that unifies deontic and ontic cases and enables concise and big-step reasoning without requiring any \dpnf rewriting.