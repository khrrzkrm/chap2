\chapter{Reasoning about Blame in Multi-Party Collaborative Contracts}
\section{Overview}
\subsection{Motivation}

Normative specifications are often presented as constraints on what an agent must do or must avoid.

In many practical contexts, however, compliance is not achieved solely by individual agents.

Instead, compliance results from interactions in which each party may enable, disregard, or obstruct the other party's actions.

This chapter examines collaborative normative settings in which agents are not engaged in zero-sum games, yet strategic behavior and conflicting incentives may still arise.

The analysis focuses on two agents, as the fundamental challenges are already present in the simplest bilateral contracts.



\paragraph{Interactions and collaboration.}

The standard deontic formalism describes the duties and prohibitions of a single agent in isolation.

In contrast, many norms require that a desired outcome be realized only through the contributions of both parties.

For instance, a tenant may attempt to pay rent, but the payment may succeed only if the landlord provides a payment channel or accepts the transfer.

Similarly, occupancy is meaningful only if one party grants access while the other actually occupies.

A robust model must therefore distinguish between (i) attempts made by each agent and (ii) successful collaboration that results from a compatible combination of these attempts.

Additionally, the model must account for non-interference, in which compliance requires one party to refrain from actions that would prevent the other from fulfilling its obligations.



\paragraph{Open-ended normative interactions.}

Normative specifications may govern long-term collaborations.

For instance, contracts typically govern interactions that can persist indefinitely unless properly terminated, often with a periodic structure.

A rental agreement, for example, imposes recurring monthly obligations, conditional repairs triggered by requests, and contrary-to-duty obligations that arise after non-compliance.

This motivates the development of a trace model that supports (a) aggregation at the level specified by the norm (e.g., months) and (b) prefix-based evaluation, as monitoring and dispute resolution depend on partial observations of ongoing relationships.



\paragraph{Blame and accountability.}

When a collaborative norm is breached, it is insufficient to merely state that the contract has been violated.

It is necessary to identify who is responsible for the violation and to provide justification for this attribution.

This requirement is equally important in contractual disputes and regulatory contexts, where enforcement decisions depend on explicit accounts of causation and justification.

In bilateral scenarios such as landlord–tenant disputes, courts typically reconstruct a timeline to determine which party obstructed the other: for example, whether the tenant failed to pay while entitled to possession, whether the landlord denied access without adhering to legal procedures (such as notice, deadlines, or court orders), or whether the landlord's denial of access justified rent withholding or reduction. Frequently, both parties contribute to escalation, and resolution depends on allocating remedies proportionate to the harms caused at each stage, including restoring access, ordering payment of arrears, granting rent reductions for unusable periods, awarding damages for proven losses, and verifying compliance with termination and eviction procedures. In addition to qualitative attribution, practical compliance analysis requires a quantitative assessment of the extent of non-compliance, such as the number of months' rent unpaid, frequency of denied access, or missed repair obligations. A blame concept suitable for compliance tools must therefore be formally defined, operationally verifiable, and robust under incremental observation. This chapter develops such a notion, implements executable monitors, and extends the framework with quantitative measures that surpass the traditional first-failure perspective.



\paragraph{Research questions.}

These considerations motivate the following research questions from a formal method perspective:

\begin{enumerate}

\item How can collaboration be modeled as a first-class semantic object, distinguishing individual attempts from jointly successful outcomes?

\item Which trace abstractions effectively capture both cooperative behavior and non-interference at the granularity defined by contractual periods?

\item How can open-ended, potentially infinite, streams of duties and rights be specified and monitored within a contractual framework?

\item How can blame and quantitative accountability be defined to more accurately reflect real-world legal reasoning and support automated monitoring?

\end{enumerate}



\subsection{Methodology}

To address the research questions, we adopt a \emph{constructive formal methods} approach.
Our methodology is predicated on the rigorous separation of \emph{specification} (the denotational meaning of a contract) from \emph{implementation} (the operational mechanism of monitoring).
This separation ensures that the resulting tools are correct-by-construction rather than ad-hoc scripts.

The research follows a four-phase structural pipeline:

\paragraph{Phase 1: Semantic Abstraction.}
We begin by abstracting the domain of interaction.
Methodologically, we reject standard atomic trace models in favor of a \emph{multi-layered} approach.
We model interaction not as a given sequence of events, but as the semantic intersection of independent agent strategies.
This allows us to reason formally about causal concepts like obstruction and interference before defining normative rules.

\paragraph{Phase 2: Denotational Specification.}
We adopt a \emph{semantics-first} strategy.
Rather than defining the logic via its execution (e.g., how an automaton processes it), we first define its abstract truth conditions.
Our approach prioritizes \emph{tightness}, the ability to render progressive and precise verdicts on finite prefixes and distinguish exact (tight) prefixes for violation/satisfaction from their equivalent post continuation.
We start with a binary compliance semantics, refine it into a blame assignment model, and finally extend it to a quantitative domain.
This layering ensures that complex accountability metrics remain consistent with the fundamental notion of compliance.

\paragraph{Phase 3: Structural Synthesis.}
To bridge theory and practice, we employ \emph{automata-theoretic synthesis}.
We treat the logic as a blueprint for generating deterministic Moore machines.
Our methodology relies on structural induction: we define an operational transformation for every logical operator, ensuring that the structure of the monitor mirrors the structure of the contract.

\paragraph{Phase 4: Formal Verification.}
Finally, we validate the pipeline through \emph{conformance proofs}.
We do not merely test the monitors; we prove that the synthesized automata are logically isomorphic to the denotational semantics defined in Phase 2.
This closes the loop, guaranteeing that the executable artifacts faithfully represent the normative intent.

\subsection{Contributions}

This chapter establishes a comprehensive framework for the specification and runtime verification of collaborative normative systems.
The primary contribution is a fully verified pipeline bridging high-level normative abstractions and low-level executable monitors.

The specific theoretical and technical contributions are:

\begin{enumerate}[Con1]

\item \textbf{Attempt-Based Interaction Model.}
We introduce a formal algebra that distinguishes between an agent's \emph{attempt} and the \emph{interaction outcome}.
Unlike standard models that conflate ``failure to act'' with ``blocked action,'' our model treats non-interference as a first-class semantic property.
This enables the formal verification of ``active participation''—determining if an agent did everything in their power to fulfill a duty.

\item \textbf{The Two-Agents Collaborative Normative Logic (\cDL).}
We formalize \cDL, a logic tailored for bilateral, periodic contracts over atomic actions.
It extends standard deontic specifications with:
\begin{itemize}
  \item \emph{Atomic Responsibility and Power Modalities:} Explicit constructs for Obligation, Prohibition, and Power, parameterized by the responsible/beneficiary agent,  and the target action.
  \item \emph{Regular Expression Control Flow:} The use of regular expressions to define complex temporal \emph{triggers} for activating duties and \emph{guards} for termination conditions.
  \item \emph{Contrary-to-duty operators} that handle reparable violations.
  \item \emph{Explicit Repetition Operator:} A dedicated operator for modeling periodic, recurring obligations (e.g., "pay rent every month"). Unlike Linear Temporal Logic (LTL), which typically encodes repetition through nested "Always" ($\square$) and "Next" ($\bigcirc$) operators that flatten the temporal structure, our repetition operator preserves the \emph{periodicity} as a first-class structural element.
\end{itemize}
Crucially, \cDL is defined over the attempt-based model, allowing it to capture the collaborative nuances of real-world contracts.

\item \textbf{Theory of Tight and Quantitative Semantics.}
We introduce a family of \emph{Forward Tight Semantics} designed for online monitoring.
\begin{itemize}
    \item We define a \textbf{5-valued verdict domain} that distinguishes between eager (first) violations and irrelevant post-violation extensions.
    \item We extend this to a \textbf{Quantitative Blame Semantics} that accumulates violations over time, allowing for the calculation of cumulative penalties in open-ended contracts.
\end{itemize}

\item \textbf{Correct-by-Construction Monitor Synthesis.}
We provide a compilation algorithm that transforms any \cDL specification into a deterministic Moore machine.
We provide structural proofs demonstrating that this monitor is \emph{operationally equivalent} to the tight semantics.
This result eliminates the need to verify the monitoring tool itself, as correctness is guaranteed by the synthesis process.

\item \textbf{Formalization of Accountability.}
Beyond binary compliance, we contribute a formal definition of \emph{blame assignment} in cooperative settings.
We prove that our blame semantics is a consistency-preserving refinement of the standard violation semantics, providing a mathematical basis for dispute resolution and liability assessment.

\end{enumerate}



\paragraph{Organization.}

We first ground the problem in a rental-agreement example and extract the modeling requirements.

We then develop the trace and synchronization layer for collaborative interaction, introduce \cDL, and finally present the monitor-based semantics, blame attribution, and quantitative extensions.




  \section{Use Case: Flat Rental Contract}
  \label{sec:motivating-example}


  To ground the theoretical development in a concrete setting, we consider a simplified residential flat rental agreement. The contract is intentionally abstracted to remove legal boilerplate and retain only the core structure relevant to our analysis. This allows us to isolate the essential logical phenomena, in particular the collaborative interaction between agents and the temporal evolution of their duties, without distracting legal detail.
  
  \begin{example}\label{ME}
    We present a simplified rental contract in \ref{fig:ucd} between a tenant (agent~1) and a landlord (agent~2).
    The clauses illustrate cooperative actions such as paying rent and granting occupancy:
    payment requires both the tenant’s offer and the landlord’s acceptance, while occupancy requires
    both the tenant’s willingness to occupy and the landlord’s permission.
    The contract also includes a reparation clause and a termination condition.
    All clauses are monthly regulated and repeat over time.
    \begin{figure}[H]
    \begin{adjustbox}{varwidth=\textwidth,fbox,center}
    \textbf{Occupancy and Rent Payment}
    \begin{enumerate}[(C1)]
    \item The Tenant shall pay the full monthly rent on or before the due date.
    \item The Landlord shall guarantee the Tenant’s right to quiet enjoyment and occupancy of the premises, provided the Tenant complies with the agreement.
    \item In the event of non-payment or late payment of rent:
    \begin{enumerate}[(i)]
    \item If the Tenant fails to pay by the due date, a late fee of 10\% of the monthly rent shall be assessed.
    \item This late fee shall be due and payable along with the next month’s rent.
    \item The late fee does not waive any other rights or remedies available to the Landlord under this agreement or the law.
    \end{enumerate}
    \item If the Tenant submits a formal request for necessary repairs, the Landlord shall carry out the required repairs within one (1) month of receiving the request.
    \end{enumerate}
    
    \textbf{Termination Notice and Continued Occupancy}
    \begin{enumerate}[(C5)]
    \item The Tenant may terminate this rental agreement by giving written notice at least three (3) months prior to the intended termination date. Upon doing so, the Tenant shall:
    \begin{enumerate}[(i)]
    \item Continue to pay the full monthly rent during the three-month notice period.
    \item Retain the right to occupy the premises for the entirety of the notice period.
    \item Comply with all other terms of the rental agreement during the notice period.
    \item Vacate the premises no later than the final day of the notice period, unless otherwise agreed in writing.
    \end{enumerate}
    \end{enumerate}
    \end{adjustbox}
    \caption{Use Case: Simplified Rental Contract between a Landlord and a Tenant}
    \label{fig:ucd}
   \end{figure}
    \end{example}
    
  
    \subsection*{Informal Projection of Interaction Scenarios on the Contract}
    To ground these challenges in concrete behavior, let us consider three hypothetical execution traces (scenarios) over a timeline of months $t=1, 2, \dots$.
    These scenarios highlight the divergence between simple observation (what happened) and normative analysis (who is responsible).
    
    \paragraph{Scenario 1: Obstruction (The ``Handshake'' Problem).}
    Consider the obligation to pay rent (Clause C1) at month $t=1$.
    \begin{itemize}
        \item \textbf{Action:} The Tenant attempts to initiate the bank transfer.
        \item \textbf{Reaction:} The Landlord, wishing to manufacture a reason for eviction, closes the receiving bank account or refuses the check.
        \item \textbf{Observable Outcome:} No money is transferred.
        \item \textbf{Normative Analysis:} A naive monitor observing only ``payment status'' would flag a violation by the Tenant. However, in our collaborative framework, the Tenant has fulfilled their duty by \emph{attempting} the act. The failure is attributed to the Landlord's interference. This necessitates distinguishing \emph{attempted payment} from \emph{successful payment}.
    \end{itemize}
    
    \paragraph{Scenario 2: Violation and Reparation (The CTD Chain).}
    Consider a scenario where the Tenant genuinely runs out of funds.
    \begin{itemize}
        \item \textbf{Month 1:} Tenant fails to pay rent.
        \item \textbf{Immediate Verdict:} Violation of C1. The contract enters a ``violated'' state.
        \item \textbf{Normative Shift:} Clause C3 (Reparation) activates. The Tenant now holds a \emph{secondary obligation}: pay Month 1 Rent + Month 2 Rent + 10\% Fee at Month 2.
        \item \textbf{Month 2:} Tenant pays the total accumulated amount.
        \item \textbf{Final Verdict:} The violation is considered \emph{repaired}. The contract returns to a compliant state. The monitor must track this ``state recovery'' rather than permanently aborting at the first failure.
    \end{itemize}
    
    \paragraph{Scenario 3: Termination and Temporal Reconfiguration.}
    Consider the Tenant exercising the power to terminate (Clause C5).
    \begin{itemize}
        \item \textbf{Month 5:} Tenant issues a formal written notice to terminate.
        \item \textbf{Normative Shift:} This is not a violation, but a \emph{state change}. The contract, previously open-ended, is now fixed to terminate at Month 8 ($5+3$).
        \item \textbf{Month 6--8:} The Tenant stops paying rent, assuming the notice ended the contract immediately.
        \item \textbf{Verdict:} Violation. The monitor must enforce that the \emph{obligations persist} during the notice period (Clause C5-i). The exercising of power did not delete the obligations but merely set a horizon for their expiration.
    \end{itemize}
    
    \subsection*{Formal Modeling Challenges}
    \label{subsec:formal-challenges}
    While conceptually straightforward, formalizing this contract requires resolving several semantic challenges that standard specification languages (such as LTL or standard Deontic Logic) fail to address adequately.
    
    \paragraph{1. The ``Handshake'' Semantics (Attempts vs.\ Outcomes).}
    Clauses C1 and C2 illustrate that compliance is a \emph{joint achievement}.
    For example, ``Rent Payment'' (C1) semantically implies that the Tenant offers the money \emph{and} the Landlord accepts it.
    Standard trace models often represent this as a single atomic event $pay$.
    However, in a dispute, we must distinguish between:
    \begin{itemize}
        \item The Tenant failing to offer rent (Tenant violation).
        \item The Tenant offering, but the Landlord blocking the transfer (Landlord interference).
    \end{itemize}
    \textbf{Challenge:} The formalism must treat \emph{attempts} and \emph{successful outcomes} as distinct semantic layers to correctly attribute blame.
    
    \paragraph{2. Contrary-to-Duty Structures (Reparation).}
    Clause C3 introduces non-monotonicity. If C1 is violated, the contract does not simply evaluate to $\mathit{false}$ (breach). Instead, it transitions to a sub-ideal state where a secondary obligation (the late fee) becomes active.
    This creates a \emph{reparation chain}: Primary Duty $\rightarrow$ Violation $\rightarrow$ Secondary Duty.
    \textbf{Challenge:} The logic must support \emph{recoverable violations}, allowing the monitoring status to fluctuate between ``violated'' and ``repaired'' over time.
    
    \paragraph{3. Reactive Triggers and Monitoring Horizons.}
    Clause C4 (Repairs) imposes a duty with a relative deadline: ``within one month of request.''
    From a monitoring perspective, this requires \emph{forward-looking tightness}.
    We cannot wait for an infinite trace to determine if the repair happened.
    \textbf{Challenge:} The semantics must identify the \emph{exact finite prefix} where the deadline is missed to trigger a verdict immediately (eager rejection).
    
    \paragraph{4. Hohfeldian Powers and Structural Change.}
    Clause C5 (Termination) represents a \emph{Power} rather than a simple duty.
    By exercising this power, the Tenant unilaterally alters the normative landscape, changing an open-ended/infinite contract into a finite one (ending in 3 months).
    \textbf{Challenge:} The framework must model agents not only as actors within the rules but as entities capable of modifying the rules (or their duration) dynamically.
    \subsection*{Summary}
    This motivates the need for a new logic of collaboration, one that can:
    \begin{enumerate}
    \item represents the strategies of multiple agents acting in tandem rather than in opposition,
    \item expresses obligations, powers, reparations, and triggers in a uniform framework,
    \item capture open-ended dynamics where obligations evolve over time, and
    \item supports the analysis of compliance, blame, and verification of strategies against contract clauses.
    \end{enumerate}
    Such a framework requires both a formal model of interacting agent behaviors and a language with syntax and semantics suited to normative reasoning in collaborative, time-sensitive contracts.
  
  
  
The subsequent section introduces a formal model of interaction. We define the collaborative outcome as a trace derived from the synchronization of two independent traces, each capturing the behavior of a distinct agent.
  
  \section{Abstractions for Collaborative Interaction}
   \label{sec:multiagent-sync}
  
This section builds on the trace models and synchronization operators introduced in \texttt{traces.tex}. We keep periodic synchronized set traces as the underlying execution model and define an interaction layer that (i) distinguishes agent-local attempts from jointly successful outcomes and (ii) prepares the ground for strategy analysis and, later, normative evaluation.
  
The choice of synchronization is not cosmetic. It clarifies what constitutes feasible joint behavior, which, in turn, drives semantic validity, strategy quantification, and downstream analysis of compliance, responsibility, or blame.
  
% 
%   Synchronization disciplines adopt different assumptions about time. Interleaving and handshake reason about order without a global clock. Lockstep assumes a single round clock. Timed models use absolute time stamps. We work with two agents \(\agt=\{1,2\}\), discrete time \(\mathbb{N}\), and per-agent alphabets \(\Sigma_i\).  
  
  

  We introduce the attempted/successful abstraction, suited for capturing interference and collaboration between agents in the context of collaborative normative specifications, and discuss how it resembles and differs from existing synchronization techniques in the literature.
    This contribution is not cosmetic: it determines which joint behaviors are feasible and, therefore, what formulas are satisfied, and how knowledge and responsibility are assessed.
  
  
\paragraph{Method and structure.}

 To reason about \emph{attempted, prevented, and successful collaboration}, we introduce our contribution of attempted/successful
  abstraction on periodic, agent-tagged set traces o collaborative alphabets: (i) \emph{attempted} collaboration is captured by
  per-agent enabler sets (active participation) in a period; (ii) \emph{prevented} collaboration arises
  from blocker (non-interference violations); and (iii) \emph{successful} collaboration is defined by
  the operator \(\mathrm{Succ}\), the point-wise intersection of the two agents’ untagged suggested sets
  (equivalently, the set-theoretic image of lockstep-with-handshakes on the collaboration alphabet).
  
  

  
  \subsection{Agent-Level Attempts and Joint Outcomes}
  \subsubsection{Modeling Requirements}
  \label{subsec:what-to-model}
  
  The aim is to capture two complementary facets of collaboration between agents that standard system-centric models overlook, as illustrated in Example~\ref{ME}:
  
  \begin{itemize}
    \item \textbf{Negative performance (non-interference).}
    One agent must \emph{refrain} from actions that would prevent the other from achieving a legitimate objective.
    In a tenant--landlord scenario, the landlord should not perform blocking actions such as
    \(\textsf{cut\_power}\), \(\textsf{change\_lock}\), or \(\textsf{enter\_flat}\), which would hinder the tenant’s ability to \(\textsf{occupy}\) the flat.
  
    \item \textbf{Active participation (positive performance).}
  An agent must \emph{contribute} and perform actions that make the objective of the counterpart achievable within the agreed period.
    For example, the landlord should provide/confirm \(\textsf{account\_info}\), \(\textsf{ack\_pay}\), and \(\textsf{grant\_occ}\) upon settlement; symmetrically, the tenant should \(\textsf{pay\_rent}\) and not \(\textsf{return\_payment}\).
  \end{itemize}
  
  \noindent These performance aspects are common in normative / contract settings but are underexplored by classical synchronization operators (interleaving, lockstep, handshake), which specify \emph{how} events align rather than whether agents \emph{refrain} from harmful actions or \emph{contribute} enabling ones.
  
  \subsection{From Metric-Timed Words to Periodic Synchronized Set Traces}
  
  \begin{example}[Timed words only (agents Tenant$(1)$ and Landlord$(2)$)]
  \label{ex:timed-words-only}
  \[
  \begin{aligned}
  \Sig{1}&=\{\,\textsf{pay\_rent},\ \textsf{pay\_rent\_f},\ \textsf{start\_occ}\, \textsf{stop\_occupy}\},\\
  \Sig{2}&=\{\,\textsf{ack\_pay},\ \textsf{grant\_occ},\ \textsf{ref\_pay},\ \textsf{change\_lock}\,\}.
  \end{aligned}
  \]
  
  \noindent\textit{Scenario (Four-Month Interaction).}
  Over four months (days $t\in\{0,\dots,120\}$), the landlord grants occupancy on day~1
  (\textsf{grant\_occ}). The tenant does not move in during the first month, but pays rent
  on day~5 (\textsf{pay\_rent}), acknowledged on day~6 (\textsf{ack\_pay}). In the second month, the tenant
  begins occupying the flat (\textsf{start\_occ}) on day~35 after the start of the contract; the landlord posts an administrative
  acknowledgement on day~37 (\textsf{ack\_pay}) without a new rent event that month. In month~3,
  The tenant continues to occupy, but this month the tenant does not pay; the landlord takes no action. In the fourth month, the
  tenant pays a late fee on day~95 (\textsf{pay\_rent\_f}); the landlord refuses that payment the
  same day (\textsf{ref\_pay}) and changes the lock on day~96 (\textsf{change\_lock}).
  
  \medskip
  \noindent\defn{Metric-timed words.}
  
  \[
  \begin{aligned}
  \taumt_{1}&=\trace{(\textsf{pay\_rent},5),\ (\textsf{start\_occ},35),\ (\textsf{pay\_rent\_f},95)},\\
  \taumt_{2}&=\trace{(\textsf{grant\_occ},1),\ (\textsf{ack\_pay},6),\ (\textsf{ack\_pay},37),\\
             &\hspace{3.4em}(\textsf{ref\_pay},95),\ (\textsf{change\_lock},96)}.
  \end{aligned}
  \]
  \end{example}
  
  \noindent\textbf{From days to months: Why periodize?}
  Since the contract regulates obligations and permissions \emph{per month} rather than per day, we periodize
  the timeline into month windows $\Ik{0},\Ik{1},\Ik{2},\Ik{3},\ldots$ and aggregate the actions of each agent
  within the same window into a \emph{set}. This yields a synchronous round-based abstraction aligned with the contract calendar.
  
  \begin{definition}[Periodic synchronized set trace]
  A \defn{periodic synchronized set trace} for agent $i$ over alphabet $\Sig{i}$ is a (finite or infinite)
  sequence of per-period action sets
  \[
  \pi_i \;=\; \trace{\Aik{i}{0},\ \Aik{i}{1},\ \Aik{i}{2},\ \dots}\ \in\ \wordsets{\Sig{i}}^{*}\ \ (\text{or }\wordsets{\Sig{i}}^{\omega}).
  \]
  Each $\Aik{i}{k}\subseteq \Sig{i}$ represents the set of actions attributed to agent $i$ during the the period $k$
  (empties allowed).
  \end{definition}
  
  \begin{lemma}[Conversion from metric time to periodic synchronized trace]
  \label{lem:agg-to-periodic}
  Let \(\taumt_i\in(\Sigma_i\times\mathbb{N})^{*}\) be a (finite) timed word for agent \(i\), and let
  \((I_k)_{k\in\mathbb{N}}\) be a partition of \(\mathbb{N}\) into disjoint, totally ordered \emph{period windows}
  (e.g., ongoing months) such that
  \[
  k<\ell,\ t\in I_k,\ s\in I_{\ell}\ \Rightarrow\ t<s.
  \]
  Then there exists a periodic synchronized timed trace \(\pi_i=\trace{A^{(i)}_0,\dots,A^{(i)}_K}\in(2^{\Sigma_i})^{*}\) defined by
  \[
  A^{(i)}_k \;:=\; \{\, a\in\Sigma_i \mid \exists\, t\in I_k:\ (a,t)\in \taumt_i \,\}.
  \]
  Moreover, the aggregation \emph{preserves inter-period order}:
  \[
  \forall k\ \forall a\in A^{(i)}_k\ \forall b\in A^{(i)}_{k+1}\;\;
  \exists\, t_a\in I_k,\ t_b\in I_{k+1}:
  \ (a,t_a)\in\taumt_i,\ (b,t_b)\in\taumt_i,\ \text{and } t_a<t_b.
  \]
  \end{lemma}
  
  \begin{proof}
  By definition of $\AggI$. Given $a\in \Aik{i}{k}$ and $b\in \Aik{i}{\ell}$ with $k<\ell$, choose witnesses
  $t_a\in \Ik{k}$ and $t_b\in \Ik{\ell}$; the window order yields $t_a<t_b$.
  \end{proof}
  
  Nevertheless, aggregation has a cost, as it loses intra-period order, action multiplicity, and exact timestamps. Therefore, selecting the appropriate period normalization is crucial.
  
  \begin{example}[Transforming timed words into periodic set traces, continued from Example. \ref{ex:timed-words-only}]
  \label{ex:agg-30-locked}
  By fixing the period to 30, we can decompose the 120 days into 4 horizons:
  
  \[
  \Ik{0}=[0,30],\qquad \Ik{1}=[31,60],\qquad \Ik{2}=[61,90],\qquad \Ik{3}=[91,120].
  \]
  The two timed traces $\taumt_1$ and $\taumt_2$ could be transformed into:
  \[
  \begin{aligned}
  \pi_1&=\trace{%
  \underbrace{\{\textsf{pay\_rent}\}}_{\Ik{0}},\
  \underbrace{\{\textsf{start\_occ}\}}_{\Ik{1}},\
  \underbrace{\emptyset}_{\Ik{2}},\
  \underbrace{\{\textsf{pay\_rent\_f}\}}_{\Ik{3}}},\\[2pt]
  \pi_2&=\trace{%
  \underbrace{\{\textsf{grant\_occ},\ \textsf{ack\_pay}\}}_{\Ik{0}},\
  \underbrace{\{\textsf{ack\_pay}\}}_{\Ik{1}},\
  \underbrace{\emptyset}_{\Ik{2}},
  \underbrace{\{\textsf{ref\_pay\_f},\ \textsf{change\_lock}\}}_{\Ik{3}}}.
  \end{aligned}
  \]
  By Lemma~\ref{lem:agg-to-periodic}, for agent~1 the element $\textsf{start\_occ}\in \Aik{1}{1}$ precedes
  $\textsf{pay\_rent\_f}\in \Aik{1}{3}$ (witness times $35<95$), and similarly for agent~2.
  \end{example}
  
  % Normalized capitalization for subsubsection
  \subsubsection{Abstraction to a Collaboration Alphabet}
  The second aspect of the abstraction is the notion of interaction alphabets. The action alphabets of both agents are merged into a single alphabet, and the trace encodes that when $a$ is an event, it indicates that an agent has either instantiated it or accepted to collaborate on it. Conversely, the absence of an action from the event signifies that the agent either did not perform it or actively performed another action to prevent its success. This abstraction is demonstrated using the running example, showing that it maintains the same meaning while reducing the number of action types. An operator is then introduced to compute the successful interaction at each period of the synchronized trace. This transformation cannot be automated unless the set of enabling and interfering actions is explicitly stated in the normative specification; otherwise, the digitization engineer must define them manually, as is done here.
  
  We consider three collaborative objectives that are identified in the Example.\ref{ME}:
  \(\PAY\) (rent payment), \(\PAYF\) (penalty/late-fee payment), and \(\OCC\) (tenant’s occupancy).
  We write \(\Sigma_C=\{\PAY,\PAYF,\OCC\}\).
  
  In the next step, we need to define how the actions of the agents, namely $\Sigma_1$ and $\Sigma_2$, relate to collaborative action over $\Sigma_C$, more specifically, whether they are enabler or interference actions. We do not take the union \(\Sigma_1\cup\Sigma_2\) as a synchronization operator discussed in the Subsection~\ref {operators}. Instead, we define a many-to-one \emph{abstraction} from concrete per-agent actions to the collaboration alphabet \(\Sigma_C\).
   On the tenant side, \textsf{pay\_rent} and \textsf{pay\_rent\_f} are enablers because they instantiate the tenant’s contribution toward \PAY and \PAYF; \textsf{start\_occ} is an enabler for \OCC because it is the tenant’s side of taking possession. A chargeback \textsf{return\_payment} and \textsf{return\_payment\_f}  is blocking: it nullifies the very transfer that \PAY and \emph{PAY\_F} rely on. On the landlord side, \textsf{ack\_pay} enables \PAY, while \textsf{grant\_occ} enables \OCC by authorizing access. In contrast, \textsf{ref\_pay} blocks \PAY even if the tenant initiated payment, and \textsf{change\_lock}, \textsf{cut\_power}, or \textsf{enter\_flat} block \OCC by making continued possession impracticable or unlawful. This enabler/blocker partition is precisely what our “suggested/successful” abstraction needs: success in a period occurs when both sides propose the required enablers and neither side performs a blocker.
  
  
  \paragraph{Distinguishing enabling from Blocking actions} For each agent \(i\in\{1,2\}\) we partition the alphabet into
  \(\SigA{i}\) (actions that constitute \emph{active participation}, i.e., enablers)
  and \(\SigI{i}\) (actions that constitute \emph{negative performance}, i.e., blockers), with
  \(\Sig{i}=\SigA{i}\uplus\SigI{i}\) (disjoint union). In our running example:
  
  \[
  \begin{aligned}
  \SigA{1} &= \{\,\textsf{pay\_rent},\ \textsf{pay\_rent\_f},\ \textsf{start\_occ}\,\},\\
  \SigI{1} &= \{\,\textsf{refuse\_inspection}\,\}.\\[4pt]
  \SigA{2} &= \{\,\textsf{ack\_pay},\ \textsf{grant\_occ}\,\},\\
  \SigI{2} &= \{\,\textsf{ref\_pay},\ \textsf{change\_lock},\ \textsf{ref\_pay\_f} ,\ \textsf{enter\_flat}\,\}.
  \end{aligned}
  \]
  
  \[
  \Sig{1}=\SigA{1}\uplus\SigI{1},\qquad
  \Sig{2}=\SigA{2}\uplus\SigI{2},\qquad
  \Sigma=\Sig{1}\cup\Sig{2}.
  \]
  
  For brevity, below we write the \emph{enabler} and \emph{blocker} sets as
  \[
  E_i:=\SigA{i}\quad\text{and}\quad B_i:=\SigI{i}\qquad(i\in\{1,2\}).
  \]
  Presence of \(a\in E_i\) in period \(k\) signals that agent \(i\) took a
  \emph{positively contributing} action; presence of \(b\in B_i\) signals a
  \emph{defeating} (interfering) action. The absence of a symbol indicates it was not suggested/endorsed during that period.
  
  
  \paragraph{Transformation sketch} After defining this relation, we can transform any periodic synchronous word  $\pi_1$ over $\Sigma_1$ and $\pi_2$ over  $\Sigma_2$ to a corresponding word over $\Sigma_C$, written $\pi_i^C$:
  \begin{itemize}
  \item If an action $a$ is on event $A$ from $\pi_i$ and that action is in $E_i$, then this action is transformed to its equivalent collaborative action and inserted on the resulting word $\pi_i^C$.
  \item If an action $a$ is on event $A$ from $\pi_i$ and that action is in $B_i$, then this action is not transformed and not inserted on the resulting word $\pi_i^C$.
  \end{itemize}
  And additionally, we do not add any collaborative action not present in an event on the equivalent event in $\pi_i^C$ unless it is a continuous collaboration with implicit collaboration, as $\textsf{start\_occ}$ signals the start of occupying the flat, so it is kept inserted in the following events in the timed word of the tenant and landlord as long as tenant does not leave nor the landlord blocks actively the occupation.
  
  
  
  \begin{example}[Transforming the periodic synchronized words over $\Sigma_1,\Sigma_2 $ to periodic synchronized words over $\Sigma_C$ ]\label{ex:collab}
  Using the traces from Example~\ref{ex:agg-30-locked},
  \[
  \begin{aligned}
  \pi_1&=\trace{%
  \underbrace{\{\textsf{pay\_rent}\}}_{\Ik{0}},\ 
  \underbrace{\{\textsf{start\_occ}, \textsf{pay\_rent} \}}_{\Ik{1}},\ 
  \underbrace{\emptyset}_{\Ik{2}},\ 
  \underbrace{\{\textsf{pay\_rent\_f}\}}_{\Ik{3}}
  },\\[2pt]
  \pi_2&=\trace{%
  \underbrace{\{\textsf{grant\_occ},\ \textsf{ack\_pay}\}}_{\Ik{0}},\ 
  \underbrace{\{\textsf{ack\_pay}\}}_{\Ik{1}},\ 
  \underbrace{\emptyset}_{\Ik{2}},\ 
  \underbrace{\{\textsf{ref\_pay\_f},\ \textsf{change\_lock}\}}_{\Ik{3}}
  }.
  \end{aligned}
  \]
  With \(E_1(\PAY)=\{\textsf{pay\_rent}\}\),\(E_1(\PAYF)=\{\textsf{pay\_rent\_f}\}\)
  \(E_2(\PAY)=\{\textsf{ack\_pay}\}\),
  \(B_2(\PAY)=\{\textsf{ref\_pay}\}\),
  \(E_1(\OCC)=\{\textsf{start\_occ}\}\),
  \(E_2(\OCC)=\{\textsf{grant\_occ}\}\),
  \(B_2(\OCC)=\{\textsf{change\_lock}\}\),
  Consequently, the collaboration alphabet is:
  \[
  \Sigma_C=\{\PAY,\ \PAYF,\ \OCC\}.
  \]
  The corresponding collaboration-trace abstractions of $\pi_1$ and $\pi_2$ are $\pi_1^C$ and $\pi_2^C$:
  \[
  \begin{aligned}
  \pi_1^{C}&=\trace{%
  \underbrace{\{\pay{1}\}}_{\Ik{0}},\ 
  \underbrace{\{\occ{1},\ \pay{1}\}}_{\Ik{1}},\ 
  \underbrace{\{\occ{1}\}}_{\Ik{2}},\ 
  \underbrace{\{\payf{1}\}}_{\Ik{3}}
  },\\[2pt]
  \pi_2^{C}&=\trace{%
  \underbrace{\{\occ{2},\ \pay{2}\}}_{\Ik{0}},\ 
  \underbrace{\{\occ{2},\ \pay{2}\}}_{\Ik{1}},\ 
  \underbrace{\{\occ{2}\}}_{\Ik{2}},\ 
  \underbrace{\emptyset}_{\Ik{3}}
  }.
  \end{aligned}
  \]
  Reading: in month \(\Ik{0}\), agent~1 positively contributes to $\PAY$, and agent~2 allows $\OCC$\ and accepts $\PAY$.
  In \(\Ik{1}\), agent~1 pays the rent and occupies the flat and agent~2 contributes to $\PAY$ and allows the occupation $\OCC$. In \(\Ik{2}\), agent~1 keeps $\OCC$ but does not pay, and the landlord keeps allowing $\OCC$. In \(\Ik{3}\), the landlord blocks both $\PAY$ and denies $\OCC$, although the tenant wants to keep occupying the flat and pays.
  \end{example}
  
  
  \subsubsection{Successful Collaboration via the \texorpdfstring{$\mathrm{Succ}$}{Succ} Operator}
  
  
  \begin{definition}[Successful collaboration operator]
  Let  $\Sigma$ be an alphabet and let $\Sigma^{(1)}:=\{\,a^{(1)}\mid a\in\Sigma\,\}$ and
  $\Sigma^{(2)}:=\{\,a^{(2)}\mid a\in\Sigma\,\}$ be disjoint tagged copies.
  The \emph{successful collaboration operator}, written $\mathsf{Succ}$ of two periodic synchronous trace $\pi_1$ over $\Sigma^{(1)}$ and $\pi_2$ over $\Sigma^{(2)}$ on the same maximum horizon $T$ is defined eventwise by:
  \[\forall k\in\{0,\dots,T\},
  \mathrm{Succ}(\pi_1,\pi_2)[k]
  \ := \unlab\!\big(\pi_1[k]\big) \cap\ \unlab\!\big(\pi_2[k]\big).
  \]
  where $\unlab$ is the function removing the agent identifier tag from an event.
  \end{definition}
  \begin{example}[Successful collaboration ]
  From the two transformed traces  $\pi_1^{C}$ and $\pi_2^{C}$ from the Example.\ref{ex:collab}
  We illustrate \(\mathrm{Succ}(\pi_1^{C},\pi_2^{C})\)  in Figure.~\ref{example:succ-meet}
  \boxalignfigure{ \resizebox{0.96\textwidth}{!}{
  \begin{tikzpicture}[y=2cm,x=3cm]
    % Uniform rectangle nodes for all events (no colors)
    \tikzset{
      event/.style={
        draw,
        rectangle,
        text width=26mm,     % fixed width for all nodes
        minimum height=9mm,  % fixed height for all nodes
        align=center,
        font=\small
      }
    }
  
    % top row: agent 1 (tagged)
    \node[event] at (1,0)   (t1) {$\{\pay{1}\}$};
    \node[event] at (2,0)   (t2) {$\{\occ{1},\pay{1}\}$};
    \node[event] at (3,0)   (t3) {$\{\occ{1}\}$};
    \node[event] at (4,0)   (t4) {$\{\payf{1}\}$};
  
    % middle row: agent 2 (tagged)
    \node[event] at (1,-1)  (l1) {$\{\occ{2},\pay{2}\}$};
    \node[event] at (2,-1)  (l2) {$\{\occ{2},\pay{2}\}$};
    \node[event] at (3,-1)  (l3) {$\{\occ{2}\}$};
    \node[event] at (4,-1)  (l4) {$\emptyset$};
  
    % bottom row: success = unlabel + intersection
    \node[event] at (1,-2) (h1) {$\{\PAY\}$};
    \node[event] at (2,-2) (h2) {$\{\OCC,\PAY\}$};
    \node[event] at (3,-2) (h3) {$\{\OCC\}$};
    \node[event] at (4,-2) (h4) {$\emptyset$};
  
    % time/progression connectors
    \path[shorten >=0pt]
      (0,0) node[left] {$\pi_1^{C}$} edge[|-]
      (t1) (t1) edge (t2) (t2) edge (t3) (t3) edge (t4) (t4) edge[->] +(1,0)
      (0,-1) node[left] {$\pi_2^{C}$} edge[|-]
      (l1) (l1) edge (l2) (l2) edge (l3) (l3) edge (l4) (l4) edge[->] +(1,0)
      (0,-2) node[left, align=center] {$\mathrm{Succ}(\pi_1^{C}, \pi_2^{C})$ } edge[|-]
      (h1) (h1) edge (h2) (h2) edge (h3) (h3) edge (h4) (h4) edge[->] +(1,0)
      (0,-3);
  \end{tikzpicture}}}
  {Example: successful collaboration computation example}
  {example:succ-meet}
  {\vspace{10pt}}{\vspace{-18pt}}
  \end{example}
  
  \noindent\textbf{Basic properties.}
  Since \(\mathrm{Succ}\) is pointwise set intersection after tag erasure,
  it inherits three immediate facts:
  \emph{(i) Commutative and idempotent}:
  \(\mathrm{Succ}(\pi_1,\pi_2)=\mathrm{Succ}(\pi_2,\pi_1)\) and
  \(\mathrm{Succ}(\pi,\pi)=\unlab(\pi)\).
  \emph{(ii) Monotone (pointwise \(\subseteq\))}: writing
  \(\pi\le\pi'\) to mean
  \(\forall k:\ \unlab(\pi[k])\subseteq\unlab(\pi'[k])\),
  if \(\pi_1\le\pi_1'\) and \(\pi_2\le\pi_2'\) then
  \(\mathrm{Succ}(\pi_1,\pi_2)\le \mathrm{Succ}(\pi_1',\pi_2')\).
  \emph{(iii) Absorbing empty trace}:
  if \(\forall k,\ \pi_2[k]=\emptyset\),
  then \(\forall k,\ \mathrm{Succ}(\pi_1,\pi_2)[k]=\emptyset\).
  
  \begin{remark}{Relation to \(\parallel_{\mathrm{hs}}^{A}\).}
  If we declare every collaborative objective to be a handshake,
  \(A=\Sigma_C\), then the lockstep-with-handshakes product enforces that
  \(\PAY\), \(\PAYF\), \(\OCC\) can only appear at a period when both agents
  present the same letter. Concretely, if we view each period’s set
  \(A^{(i)}_k\) as the multiset of letters occurring “at that round” and apply
  \(\parallel_{\mathrm{hs}}^{A}\) round wise, then after collapsing paired
  handshakes to a single shared symbol (via \(\mathsf{coll}_A\)) and unlabeling,
  We obtain exactly the success:
  \[
  \mathrm{Succ}(\pi_1,\pi_2)
  \ =\
  \unlab\!\big(\mathsf{coll}_{\Sigma_C}\big(\pi_1\parallel_{\mathrm{hs}}^{\Sigma_C}\pi_2\big)\big),
  \]
  i.e., \(\mathrm{Succ}\) is the set-theoretic intersection semantics of
  lockstep-plus-handshakes on the collaboration alphabet.    
  \end{remark}
  
  \subsection{Interaction Strategies as Moore Machines}
  Instead of reconstructing compliance post hoc from past events, the approach models how agents intend to behave in the future. Agents may wish to run their intended strategies against the contract to determine compliance, prevent future violations, and identify how other parties may potentially obstruct or exploit the contract.
  
  Because collaborative success depends on both parties, each agent devises a strategy conditioned on the observed behavior of the other. For example, the landlord may plan differently depending on whether the tenant pays, while the tenant may stop paying if the landlord prevents continued occupancy or fails to repair reported damages.
  
  
  
  \subsubsection{Strategy Model}
  
  We capture interaction strategies with \emph{input/output} models that operate at the period granularity.
  At each period $k$, each agent $i$ observes the other agent's period-$k$ output and updates its
  internal state to produce its own period-$(k{+}1)$ output. We use \emph{Moore machines} so that an
  agent’s output at period $k$ depends only on its current state (perfect monitoring with one-period delay).
  A synchronous feedback composition couples the two machines.
  
  % In the preamble (once):
  % \newcommand{\PAY}{\mathsf{PAY}}
  % \newcommand{\PAYF}{\mathsf{PAYF}}
  % \newcommand{\OCC}{\mathsf{OCC}}
  % \newcommand{\unlab}{\mathsf{unlab}}
  
  \begin{definition}[Deterministic Moore machine]
  \label{def:moore}
  A deterministic Moore machine for agent $i$ is a 6-tuple
  \[
  M_i \;=\; (S_i, s^0_i,\ \Sigma_I^i,\ \Sigma_O^i,\ \delta_i,\ \lambda_i),
  \]
  where:
  \begin{itemize}
    \item $S_i$ is a finite set of states with initial state $s^0_i\in S_i$;
    \item $\Sigma_I$ is the input alphabet (the other agent’s \emph{untagged} collaborative letters);
    \item $\Sigma_O^i$ is the set of output alphabet;
    \item $\delta_i: S_i \times 2^{\Sigma_I} \to S_i$ is a deterministic transition function;
    \item $\lambda_i: S_i \to 2^{\Sigma_O}$ is the output function.
  \end{itemize}
  Given an input stream $X=(X_0,X_1,\dots)$ with $X_k\subseteq\Sigma_I$, the induced run is
  $s^0_i,s^1_i,\dots$ with $s^{k+1}_i=\delta_i(s^k_i,X_k)$ and outputs $Y_k=\lambda_i(s^k_i)$.
  \end{definition}
  
  \begin{definition}[Run and output of a deterministic Moore machine]
    \label{def:moore-run}
    Let 
    \[
    M_i \;=\; (S_i, s^0_i,\ \Sigma_I^i,\ \Sigma_O^i,\ \delta_i,\ \lambda_i)
    \]
    be a deterministic Moore machine for agent $i$ as in Definition~\ref{def:moore}.
    An \emph{input stream} for $M_i$ is a finite or infinite sequence 
    $X = (X_0,X_1,\dots)$ with $X_k \subseteq \Sigma_I^i$ for all positions $k$.
    
    \medskip
    \noindent\textbf{Run.}
    The \emph{run of $M_i$ on $X$} is the unique sequence of states
    \[
    \rho_i(X) \;=\; (s^0_i,s^1_i,s^2_i,\dots)
    \]
    inductively defined by
    \[
    s^{0}_i := s^0_i,
    \qquad
    s^{k+1}_i := \delta_i(s^k_i, X_k)
    \quad\text{for all }k \ge 0.
    \]
    
    \noindent For finite input $X$ of length $n{+}1$ we write $|X|=n{+}1$ and 
    $\rho_i(X) = (s^0_i,\dots,s^{n+1}_i)$.
    
    \medskip
    \noindent\textbf{Extended transition function.}
    For later use, we define the extended transition function
    \[
    \delta_i^{*} : S_i \times (2^{\Sigma_I^i})^{*} \to S_i
    \]
    by
    \[
    \delta_i^{*}(s, \varepsilon) := s,
    \qquad
    \delta_i^{*}(s, X_0\cdot X') := 
    \delta_i^{*}\bigl(\delta_i(s,X_0),\,X'\bigr),
    \]
    for $X_0 \in 2^{\Sigma_I^i}$ and $X' \in (2^{\Sigma_I^i})^{*}$.
    For a finite input word $X$, we write
    \[
    \delta_i(s^0_i,X) \;:=\; \delta_i^{*}(s^0_i,X),
    \]
    so that the last state of the run on $X$ is $\delta_i(s^0_i,X)$.
    
    \medskip
    \noindent\textbf{Output word and terminal output.}
    The \emph{output word} induced by $M_i$ on $X$ is
    \[
    \lambda_i^{\omega}(X) \;:=\; (Y_0,Y_1,\dots)
    \quad\text{with}\quad
    Y_k := \lambda_i(s^k_i).
    \]
    For a finite input word $X$ the \emph{terminal output} of $M_i$ on $X$ is
    \[
    \lambda_i\bigl(\delta_i(s^0_i,X)\bigr),
    \]
    which is the output associated with the last state of the run on $X$.
    \end{definition}
  
  \subsubsection{Synchronous Feedback Composition}
  
  We present the property of two Moore machines that can feed each other and progress together.
  
  \begin{definition}[Complementary Moore machines]
  \[\text{Let } 
  M_i \;=\; (S_i, s^0_i,\ \Sigma_I^i,\ \Sigma_O^i,\ \delta_i,\ \lambda_i) \text{ and } M_j \;=\; (S_j, s^0_j,\ \Sigma_I^j,\ \Sigma_O^j,\ \delta_j,\ \lambda_j) 
  \]
  be two deterministic Moore machines, we say that \emph{$M_i$ and $M_j$ are complementary} if and only if:
  \[ \Sigma_I^i = \Sigma_O^j \text{ and } \Sigma_O^i = \Sigma_I^j.\]
  \end{definition}
  In the following, we introduce an example of how to use Moore machines to capture two strategies that the landlord and the tenant should consider in the motivating example.
  \begin{example}[Interaction strategies and their Moore encodings]
  \label{ex:twomoore}
  Consider the two first informal strategies $\strat_1^1$ and $\strat_2^1$ from respectively the tenant(1) and the landlord(2):
  
  \medskip
  \noindent\textbf{Tenant $\strat_1^1$.}
  “I pay in the first month; from the second month on, I occupy and keep paying as long as the landlord does not stop me. If the landlord stops my occupancy, I stop paying.”
  
  \noindent\textbf{Landlord $\strat_2^1$.}
  “I enable occupancy from the first month and accept payment; if the tenant fails to pay for \emph{two consecutive} months, I stop enabling occupancy.”
  We encode both of those strategies using: $\Sigma_C^{(1)}:=\{a^{(1)}\mid a\in\Sigma_C\}$ and
  $\Sigma_C^{(2)}:=\{a^{(2)}\mid a\in\Sigma_C\}$ be the tagged disjoint copies.
  Both machines use $S=\{s_0,s_1,s_2\}$ with initial state $s_0$.
  Transitions are guarded by the current letters of the agent \emph{other} (seen as a set).
  
  \begin{figure}[h]
  \centering
  \begin{subfigure}[t]{0.70\textwidth}
  \centering
  \scalebox{0.9}{
  \begin{tikzpicture}[shorten >=1pt,node distance=3cm,on grid,auto]
    % Tenant machine M_1^1
    \node[state,initial] (s_0) {$s_0/\mathrm{A_1}$};
    \node[state,right=of s_0] (s_1) {$s_1/\mathrm{B_1}$};
    \node[state,right=of s_1] (s_2) {$s_2/\mathrm{C_1}$};
  
    \path[->]
      (s_0) edge[bend left=10] node {$\OCC^{(2)}$} (s_1)
      (s_1) edge[loop above] node {$\OCC^{(2)}$} ()
            edge[bend left=10] node {$\overline{\OCC^{(2)}}$} (s_2);
  \end{tikzpicture}}
  \caption{$M_1^1$ (tenant).\\ $\mathrm{A_1}=\{\PAY^{(1)}\}$, $\mathrm{B_1}=\{\OCC^{(1)},\PAY^{(1)}\}$, $\mathrm{C_1}=\emptyset$.}
  \label{fig:moore-tenant}
  \end{subfigure}
  
  \begin{subfigure}[t]{0.70\textwidth}
  \centering
  \scalebox{0.9}{
  \begin{tikzpicture}[shorten >=1pt,node distance=3cm,on grid,auto]
    % Landlord machine M_2^1
    \node[state,initial] (s_0) {$s_0/\mathrm{A_2}$};
    \node[state,right=of s_0] (s_1) {$s_1/\mathrm{A_2}$};
    \node[state,right=of s_1] (s_2) {$s_2/\mathrm{B_2}$};
  
    \path[->]
      (s_0) edge[loop above] node {$\PAY^{(1)}$} ()
            edge[bend left=10] node {$\overline{\PAY^{(1)}}$} (s_1)
      (s_1) edge[bend left=10] node {$\PAYF^{(1)}$} (s_0)
            edge[bend left=10] node {$\PAY^{(1)}$} (s_2);
  \end{tikzpicture}}
  \caption{$M_2^1$ (landlord). Outputs: $\mathrm{A_2}=\{\OCC^{(2)},\PAY^{(2)}\}$, $\mathrm{B_2}=\emptyset$.}
  \label{fig:moore-landlord}
  \end{subfigure}
  
  \caption{Moore machines for the tenant and landlord representing their strategies over tagged $\Sigma_C$.
  In the transition, the $\lnot \PAY^{i}$ in the Moore machine $M_j$ is a shorthand for any input from $M_i$ not containing $\PAY^{i}$, similarly $\PAY^{i}$ is a shorthand for any input from $M_i$ containing $\PAY^{i}$}
  \label{fig:moore-strategies}
  \end{figure}
  
  \noindent\textit{Formalization (matching Fig.~\ref{fig:moore-strategies}).}
  \[
  \begin{aligned}
  M_1^1&=(S,s_0,\ \Sigma_I^{(1)},\Sigma_O^{(1)},\ \delta_1,\lambda_1),
  &\Sigma_I^{(1)}&=2^{\Sigma_C^{(2)}},& \Sigma_O^{(1)}&=2^{\Sigma_C^{(1)}},\\
  M_2^1&=(S,s_0,\ \Sigma_I^{(2)},\Sigma_O^{(2)},\ \delta_2,\lambda_2),
  &\Sigma_I^{(2)}&=2^{\Sigma_C^{(1)}},& \Sigma_O^{(2)}&=2^{\Sigma_C^{(2)}}.
  \end{aligned}
  \]
  For $X\subseteq\Sigma_C^{(2)}$, $Y\subseteq\Sigma_C^{(1)}$:
  \[
  \delta_1(s_0,X)=\begin{cases}s_1&\OCC^{(2)}\in X\\ s_0&\text{otherwise}\end{cases},\ \ 
  \delta_1(s_1,X)=\begin{cases}s_1&\OCC^{(2)}\in X\\ s_2&\text{otherwise}\end{cases},\ \ 
  \delta_1(s_2,X)=s_2,
  \]
  \[
  \delta_2(s_0,Y)=\begin{cases}s_0&\PAY^{(1)}\in Y\\ s_1&\text{otherwise}\end{cases},\ \ 
  \delta_2(s_1,Y)=\begin{cases}s_0&\PAYF^{(1)}\in Y\\ s_2&\PAY^{(1)}\in Y\\ s_1&\text{otherwise}\end{cases},\ \ 
  \delta_2(s_2,Y)=s_2.
  \]
  
  Notice that two Moore machines are complementary.
  \end{example}
  
  Now we move to the step where both strategies are fixed and transformed to compute their outcome. To do so, we introduce the product of two complementary Moore machines.
  
  
  \begin{definition}[Product of Complementary Determinstic Moore Machines]
  
  \[\text{Let }
  M_i \;=\; (S_i, s^0_i,\ \Sigma_I^j,\ \Sigma_O^i,\ \delta_i,\ \lambda_i)
  \quad\text{and}\quad
  M_j \;=\; (S_j, s^0_j,\ \Sigma_I^i,\ \Sigma_O^j,\ \delta_j,\ \lambda_j)
  \]
  be two deterministic complementary Moore machines.
  The \emph{product} of $M_i$ and $M_j$ is the automaton
  \[
  M_i \otimes M_j \;=\; (\,\Sigma,\ Q,\ q_0,\ \delta,\ F\,)
  \]
  where
  \begin{itemize}
      \item $\Sigma = 2^{\Sigma_O^i \cup \Sigma_O^j}$ is the \emph{joint alphabet},
      \item $Q = S_i \times S_j$ is the \emph{state space},
      \item $q_0 = (s^0_i, s^0_j)$ is the \emph{initial state},
      \item $F = \emptyset$ ,
      \item $\delta \subseteq Q \times \Sigma \times Q$ is the \emph{transition relation}, defined by
      \[
      \big((s_i,s_j),\, A,\, (s'_i,s'_j)\big) \in \delta
      \]
      if and only if
      \[
      A = \lambda_i(s_i) \cup \lambda_j(s_j), 
      \quad s'_i = \delta_i(s_i,\lambda_j(s_j)), 
      \quad s'_j = \delta_j(s_j,\lambda_i(s_i)).
      \]
  \end{itemize}
  The \emph{language} $L(M_i \otimes M_j) \subseteq \Sigma^\omega$ consists of all infinite words
  \[
  \trace{A_0, A_1, A_2 \dots}
  \]
  such that there exists a run
  \[
  (s^0_i, s^0_j) \xrightarrow{A_0} (s_{i,1}, s_{j,1}) \xrightarrow{A_1} (s_{i,2}, s_{j,2}) \xrightarrow{A_2} \dots
  \]
  with $A_k = \lambda_i(s_{i,k}) \cup \lambda_j(s_{j,k})$ for all $k \geq 0$.
  \end{definition}
  
  
  
  \begin{lemma}[Unique run and word of product machines]
  \label{lem:product-word}
  Let
  \[
  M_i = (S_i, s^0_i,\ \Sigma_I^j,\ \Sigma_O^i,\ \delta_i,\ \lambda_i)
  \quad\text{and}\quad
  M_j = (S_j, s^0_j,\ \Sigma_I^i,\ \Sigma_O^j,\ \delta_j,\ \lambda_j)
  \]
  be two complementary deterministic Moore machines.  
  Then their product $M_i \otimes M_j$ admits a \emph{unique run}
  \[
  (s^0_i,s^0_j)\,(s_{i,1},s_{j,1})\,(s_{i,2},s_{j,2})\dots
  \]
  and this run induces a \emph{unique word}
  \[
  \pi \;=\; \trace{A_0,A_1,A_2,\dots} \;\in\; \big(2^{\Sigma_O^i \cup \Sigma_O^j}\big)^\omega,
  \]
  where
  \[
  A_t \;=\; \lambda_i(s_{i,t}) \cup \lambda_j(s_{j,t}), \qquad t \ge 0,
  \]
  and the successor states are determined by
  \[
  s_{i,t+1} = \delta_i(s_{i,t},\,\lambda_j(s_{j,t})),\qquad
  s_{j,t+1} = \delta_j(s_{j,t},\,\lambda_i(s_{i,t})).
  \]
  \end{lemma}
  
  \begin{proof}
  Determinism ensures that for every product state $(s_{i,t},s_{j,t})$ there is exactly one
  successor $(s_{i,t+1},s_{j,t+1})$, determined by the mutual feedback of outputs.
  By induction on $t$, this yields a unique run of the product automaton starting from $(s^0_i,s^0_j)$.
  Collecting the joint outputs at each step produces the word $\pi$, which is therefore unique.
  If the run stabilizes in a sink state with constant outputs, $\pi$ is ultimately periodic
  and may be regarded as finite; otherwise $\pi$ is infinite.
  \end{proof}
  
  \begin{example}[Product automaton sketch for $M_1^1 \times M_2^1$]
  \label{ex:product-automaton}
  We now project the two Moore machines $M_1^1$ (tenant) and $M_2^1$ (landlord) of
  Example~\ref{ex:twomoore} into their synchronous product $M_1^1 \times M_2^1$.
  Each state of the product records the joint output of both agents in that period, denoted by $\{A_1,A_2\}$, with $A_1\in 2^{\Sigma_C^{(1)}}$ and $A_2\in 2^{\Sigma_C^{(2)}}$.
  The initial state corresponds to $(s^0_1,s^0_2)$; subsequent states reflect how both machines
  progress under synchronous feedback. Once a stable pair of states is reached, the product
  loops, generating the same joint output forever.
  
  \begin{figure}[h]
  \centering
  \begin{subfigure}[t]{0.70\textwidth}
  \centering
  \scalebox{0.9}{
  \begin{tikzpicture}[shorten >=1pt,node distance=3cm,on grid,auto]
    % Tenant machine M_1^1
    \node[state,initial] (s_0) {$s_0^1/\mathrm{A_1}$};
    \node[state,right=of s_0] (s_1) {$s_1^1/\mathrm{B_1}$};
    \node[state,right=of s_1] (s_2) {$s_2^1/\mathrm{C_1}$};
  
    \path[->]
      (s_0) edge[bend left=10] node {$\OCC^{(2)}$} (s_1)
      (s_1) edge[loop above] node {$\OCC^{(2)}$} ()
            edge[bend left=10] node {$\overline{\OCC^{(2)}}$} (s_2);
  \end{tikzpicture}}
  \caption{$M_1^1$ (tenant), with\\ $\mathrm{A_1}=\{\PAY^{(1)}\}$, $\mathrm{B_1}=\{\OCC^{(1)},\PAY^{(1)}\}$, $\mathrm{C_1}=\emptyset$.}
  \label{fig:moore-tenant-prod}
  \end{subfigure}
  \vspace{0.5cm}
  \begin{subfigure}[t]{0.70\textwidth}
  \centering
  \scalebox{0.9}{
  \begin{tikzpicture}[shorten >=1pt,node distance=3cm,on grid,auto]
    % Landlord machine M_2^1
    \node[state,initial] (s_0) {$s_0^2/\mathrm{A_2}$};
    \node[state,right=of s_0] (s_1) {$s_1^2/\mathrm{A_2}$};
    \node[state,right=of s_1] (s_2) {$s_2^2/\mathrm{B_2}$};
  
    \path[->]
      (s_0) edge[loop above] node {$\PAY^{(1)}$} ()
            edge[bend left=10] node {$\overline{\PAY^{(1)}}$} (s_1)
      (s_1) edge[bend left=10] node {$\PAYF^{(1)}$} (s_0)
            edge[bend left=10] node {$\PAY^{(1)}$} (s_2);
  \end{tikzpicture}}
  \caption{$M_2^1$ (landlord), with : $\mathrm{A_2}=\{\OCC^{(2)},\PAY^{(2)}\}$, $\mathrm{B_2}=\emptyset$}
  \label{fig:moore-landlord-prod}
  \end{subfigure}
  \vspace{0.5cm}
  \begin{subfigure}[t]{0.70\textwidth}
  \centering
  \begin{tikzpicture}[shorten >=1pt,node distance=3cm,on grid,auto,
    every state/.style={inner sep=6pt,font=\scriptsize}]
    % States show pairs of original machine states
    \node[state,initial] (s0) {$(s_0^1,s_0^2)$};
    \node[state, right=of s0] (s1) {$(s_0^1,s_1^2)$};
  
    % Transitions are labeled with the union of outputs
    \path[->]
      (s0) edge node {$A_1 \cup A_2$} (s1)
      (s1) edge[loop right] node {$B_1 \cup A_2$} (s1);
  \end{tikzpicture}
  \caption{Product automaton $M_1^1 \times M_2^1$, with states as pairs $(s_i^1,s_j^2)$ and transitions labeled by the joint outputs.}
  \label{fig:product-sketch}
  \end{subfigure}
  
  \caption{Tenant’s machine $M_1^1$, landlord’s machine $M_2^1$, and their product 
  automaton $M_1^1 \times M_2^1$. 
  Each product state is labeled by the joint output $\lambda_1(s_i^1)\cup\lambda_2(s_j^2)$.}
  \label{fig:moore-product-full}
  \end{figure}
  
  \noindent
  Concretely, The run of the product $M_1^1 \times M_2^1$ in  Fig.~\ref{fig:moore-strategies}, corresponds to the omega-word\\
  $\trace{\{\PAY^{(1)},\OCC^{(2)},\PAY^{(2)}\}~\
   (\{\OCC^{(1)},\PAY^{(1)},\OCC^{(2)},\PAY^{(2)}\})^\omega}.$
  \end{example}
  
  
  
%   \section{The Two-Agents Collaborative Normative Logic \cDL}
%   \subsection{Syntax of \cDL}
%   As summarized in Fig.~\ref{fig:cdl-syntax}, the syntax of \cDL\ is organized into three blocks: regular expressions, literals, and contracts.
  
%   \begin{figure}[h]
%   \centering
%   \fbox{%
%   \begin{minipage}{0.96\textwidth}
%   \captionof{figure}{Syntax of \cDL}
%   \label{fig:cdl-syntax}
%   \small
%   Given a collaboration alphabet $\Sigma_C$ and let
%   $\Sigma := \Sigma_C^{(1)} \cup \Sigma_C^{(2)}$ be the tagged action alphabet.
%   With:
%   $a \in \Sigma_C$ (collaboration action),\;
%   $p \in \{1,2\}$ (party).\;
%   $A \in 2^\Sigma$ (party tagged action set),\;
%   $n \in \mathbb{N^*}$ (non-zero natural number).\;
%   The syntax of \cdl is defined inductively via the following grammar:
  
%   \medskip
%   \[
%   \begin{alignedat}{3}
%   \textbf{Regular expressions}\quad
%   \re\ &::=&\ \mathsf{A}                                      && \hfill[\text{tagged action set}] \\
%      &\mid&\ \Gamma                             && \hfill[\text{trump card}] \\
%      &\mid&\ \varepsilon                             && \hfill[\text{empty word}] \\
%      &\mid&\ \emptyset                              &&  \hfill\quad\qquad [\text{empty set of actions}] \\
%      &\mid&\ (\re \mid \re)                           && \hfill[\text{union}] \\
%      &\mid&\ \re \cdot \re                           && \hfill[\text{concatenation}] \\
%      &\mid&\ \re^{n}                                  && \hfill[\text{n-repetition}] \\
%      &\mid&\ \re^{+}                                  && \hfill[\text{Kleene plus}] \\[6pt]
%   %
%   \textbf{Literals}\quad
%   \ell\ &::=&\ \obl[p]{a}                           && \hfill[\text{obligation}] \\
%        &\mid&\ \frb[p]{a}                           && \hfill[\text{prohibition}] \\
%        &\mid&\ \perm[p]{a}                          && \hfill[\text{permission}] \\
%        &\mid&\ \top                                 && \hfill[\text{valid}] \\
%        &\mid&\ \bot                                 && \hfill[\text{invalid}] \\[6pt]
%   %
%   \textbf{Contracts}\quad
%   C\ &::=&\ \ell                                    && \hfill[\text{literal}] \\
%     &\mid&\ C \wedge C                              && \hfill[\text{conjunction}] \\
%     &\mid&\ C ; C                                   && \hfill[\text{sequence}] \\
%     &\mid&\ C \repair C                             && \hfill[\text{reparation}] \\
%     &\mid&\ \trig[re]{C}                   && \hfill[\text{triggered}] \\
%     &\mid&\ \guard[re]{C}                           && \hfill[\text{guarded}] \\
%     &\mid&\ C^n                                     && \hfill[\text{n-repetition}]\\
%     &\mid&\ \repit{C}                               && \hfill[\text{infinite-repetition}]
%   \end{alignedat}
%   \]
%   \end{minipage}}
%   \end{figure}
  
  
   
%   \medskip
%   \noindent\textbf{Regular expressions (\emph{re}).}
%   This block specifies \emph{when} clauses apply by describing patterns over monthly positions.
%   An \emph{atom} is a tagged action-set \(A \subseteq \Sigma\) stating what the two parties did in a month.
%   Complex expressions are formed with \emph{union} \((re \mid re)\), \emph{concatenation} \((re \cdot re)\) for next-month sequencing,
%   \emph{power} \(re^n\) (exactly \(n\) repetitions), and \emph{Kleene plus} \(re^+\) (one or more repetitions).
%   The \emph{wildcard} \(\Gamma\) is the union of all $A \subseteq \Sigma$ used to skip a position, and \(\emptyset\) denotes the \emph{empty set of actions}.
%   These constructs enable patterns such as “a repair is requested this month” (an atom), “after any number of months if Agent $1$ asks for termination (\(\Gamma \cdot\)), or “three consecutive months” \((re)^3\).
  
%   \medskip
%   \noindent\textbf{Literals (\emph{\(\ell\)}).}
%   This block provides the primitive deontic statements for a single month:
%   \emph{obligation} \(\obl[p]{a}\), \emph{prohibition} \(\frb[p]{a}\), and \emph{power} \(\perm[p]{a}\),
%   plus the constants \emph{valid} \(\top\) and \emph{invalid} \(\bot\).
%   Here \(p \in \{1,2\}\) identifies the party (tenant or landlord) and \(a \in \Sigma_C\) is a collaboration action.
%   Intuitively, literals say \emph{what} is required/forbidden/allowed of \emph{whom}, independently of timing.
  
%   \medskip
%   \noindent\textbf{Contracts (\emph{C}).}
%   This block composes literals into full specifications using:
%   \emph{conjunction} \((C \wedge C)\) to combine requirements in the same time position;
%   \emph{sequence} \((C;C)\) for next-time progression;
%   \emph{reparation} \((C \repair C')\) for contrary-to-duty fall-backs saying you are requested to perform $C$, if you fail you must conform to $C'$ in the next time position;
%   \emph{triggered} clauses \(\trig[re]{C}\) that activate \(C\) when a pattern \(re\) occurs;
%   \emph{guarded} clauses \(\guard[re]{C}\) that encapsulate conditions under which conforming to a contract is no longer necessary; and
%   \emph{repetition} \(\repit{C}\) for repetitive occurrence of a contract.
%   Together, these constructs could be used to capture the clauses of a contract, the conditions under which they are activated or terminated, and how the clauses relate to each other regarding reparations or the timing of their application. More specifically, the combination of repetition and a guarded contract can capture the notion of open-ended contracts.
%    In the following example, we illustrate how we could capture our motivating example:
%   \subsection{Illustrating the Encoding in \cDL for the Motivating Example}
%   \begin{example}[Encoding the rental clauses in \cDL]
%   \label{ex:contract-encoding}
%   We now illustrate how the rental agreement introduced in Example~\ref{ME} 
%   can be systematically encoded in the \cDL\ syntax (see Fig.~\ref{fig:cdl-syntax}).  
%   We define the collaboration alphabet that captures all joint actions relevant to the contract:
%   \[
%   \Sigma_C = \{\PAY,\ \PAYF,\ \OCC,\ \notifrepair,\ \notifterm,\ \REPAIR\}.
%   \]
%   Each element corresponds to a collaborative outcome:
%   \PAY\ (rent payment), \PAYF\ (late fee payment), \OCC\ (occupancy), 
%   \notifrepair\ (tenant’s repair request), \notifterm\ (termination notice), 
%   and \REPAIR\ (landlord performing repair).
  
%   \medskip
%   The encoding proceeds clause by clause, following the contract structure:
  
%   \begin{itemize}
%     \item \textbf{C1 (Tenant pays rent):}  
%     The tenant is obliged to pay the rent each month.  
%     \[
%     C_1 := \obl[1]{\PAY}.
%     \]
  
%     \item \textbf{C2 (Landlord guarantees occupancy):}  
%     The tenant gets the power to occupy the flat. 
%     Thus, the landlord is required not to interfere with the tenant’s occupancy, 
%     encoded as a permission to allow the collaborative outcome \OCC.  
%     \[
%     C_2 := \perm[1]{\OCC}.
%     \]
  
%     \item \textbf{C3 (Late-payment reparation):}  
%     Clause C3 introduces a contrary-to-duty (CTD) structure: if the tenant fails to fulfill the primary obligation (C1), a compensatory obligation to pay the late fee arises.  
%     This relationship is encoded as a reparation construct:
%     \[
%     C_3 := \obl[1]{\PAY}\ \repair\ \obl[1]{\PAYF}.
%     \]
  
%     \item \textbf{C4 (Triggered repair request):}  
%     The tenant’s request for repairs activates the landlord’s duty to perform them within the following month.  
%     This is expressed using a triggered clause:
%     \[
%     C_4 := 
%     \trig[\{\notifrepair^{(1)}\}]{\obl[2]{\REPAIR}}.
%     \]
  
%     \item \textbf{C5 (Termination and continuation):}  
%     The tenant may terminate the contract unilaterally by issuing a termination notice.  
%     After this notice, the contract’s active obligations (rent, occupancy, repairs) 
%     persist for three additional months before ending.  
%     This behavior is captured with a guarded contract:
%     \[
%     C_5 := \guard[\,\Gamma^+ \cdot \{\notifterm^{(1)}\} \cdot \Gamma^{3}\,] (\ C_3\ \wedge\ C_2\ \wedge\ C_4\ ).
%     \]
%   \end{itemize}
  
%   \medskip
%   This step-by-step encoding shows how \cDL\ integrates temporal regular patterns, deontic modalities, 
%   and event-triggered obligations in a single formalism.  
%   Clauses (C1–C5) together specify a full-cycle contract where collaborative actions such as payment, occupancy, repair, and termination are modeled as 
%   conditional and time-bounded obligations between the two agents.
%   \end{example}
  
  
%   We move now to the first semantic definition for this logic, where we just care about whether a contract was satisfied.



%\input{tightmotivation.tex}


%\input{forwardtight.tex}

%\input{quantitativeviol.tex}

