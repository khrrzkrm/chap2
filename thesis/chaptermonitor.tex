\chapter{Reasoning about Blame in Multi-Party Collaborative Contracts}\label{chap:monitoring}

This chapter addresses the challenge of monitoring and diagnosing failures in collaborative systems where compliance depends on the joint behavior of multiple autonomous agents, building on a corrected and reformulated syntax and semantics of our earlier work \cite{Kharraz23}. The central technical novelty lies in treating collaboration itself as a semantic object. Unlike traditional runtime verification and temporal logic frameworks, which evaluate compliance solely in terms of realized events, the framework developed here distinguishes between what each agent attempted, what was obstructed, and what jointly succeeded. This distinction is essential for responsibility attribution in collaborative contracts and cannot be reconstructed from standard trace semantics after the fact. By formalizing interaction as a collaborative process, we establish a rigorous basis for blame attribution when contractual obligations are not met. This foundation supports the development of a logic and a runtime verification pipeline capable of handling temporal constraints, reparable violations, and the open-ended structure of real-cases of legal multi-party contracts.
\section{Overview}

In this section, we outline the theoretical and practical necessity for a blame-aware monitoring framework. We begin by motivating the problem through the lens of open-ended normative interactions, where simple binary verdicts of satisfaction or violation are insufficient for dispute resolution. We then detail the specific research questions that guide our inquiry and describe the constructive methodology used to answer them. Finally, we summarize the chapter's core contributions, including the novel Attempt-Based Interaction Model and the Two-Agents Collaborative Normative Logic (\cDL), which collectively enable precise, automated accountability in digital contracts.

\subsection{Motivation}

Normative specifications are typically presented as constraints on what an individual agent must do or avoid. In many practical contexts, however, compliance is not achieved solely by individual agents but results from interactions where different parties may enable, disregard, or obstruct each other. This chapter examines collaborative normative settings where, even without zero-sum competition, strategic behavior and conflicting incentives arise. Our analysis focuses on two agents, as the fundamental challenges of collaboration are fully present even in bilateral contracts.

\paragraph{Interactions and collaboration.}
Standard deontic formalism describes duties in isolation, yet many norms require that a desired outcome be realized through the joint contributions of both parties. For instance, a tenant's payment succeeds only if the landlord provides a channel to receive it; similarly, occupancy requires both the tenant's attempt to occupy and the landlord's permission. A robust model must therefore distinguish between the \emph{attempts} made by each agent and the \emph{successful collaboration} resulting from their compatibility. Additionally, the model must account for \emph{non-interference}, ensuring that compliance involves refraining from actions that obstruct the counterparty.

\paragraph{Open-ended normative interactions.}
Contracts often govern long-term collaborations that persist indefinitely unless terminated. A rental agreement, for example, imposes recurring obligations and conditional repairs that repeat over time. This motivates the development of a trace model that supports aggregation at the granularity of the norm (e.g., monthly periods) and allows for \emph{prefix-based evaluation}, as monitoring depends on partial observations of ongoing relationships.

\paragraph{Blame and accountability.}
When a collaborative norm is breached, the mere detection of a violation is insufficient; it is necessary to identify the responsible agent and provide a justification.
This attribution of responsibility is critical in disputes where enforcement relies on explicit causal links.
Courts, for example, must reconstruct event timelines to determine if a landlord's initial obstruction causally justified a tenant's subsequent non-payment.
Beyond establishing causality, practical analysis requires a \emph{quantitative assessment} of non-compliance, distinguishing a simple binary verdict from a granular count of unpaid months or denied access.
Consequently, a blame concept suitable for automated compliance tools must be formally defined, operationally verifiable, and robust under incremental observation.

\paragraph{Research questions.}
These considerations motivate the following questions from a formal methods' perspective:
\begin{enumerate}[RQ1]
\item How can collaboration be modeled as a first-class semantic object, distinguishing individual attempts from jointly successful outcomes?
\item Which trace abstractions effectively capture cooperative behavior and non-interference at the granularity of contractual periods?
\item How can open-ended clauses, specifically \emph{repetitions} of duties be specified and monitored within a contractual framework?
\item How can blame and quantitative accountability be defined to reflect legal reasoning and support automated monitoring?
\end{enumerate}

\subsection{Methodology}

To address these questions, we adopt a \emph{constructive formal methods} approach. Our methodology is predicated on the rigorous separation of \emph{specification} (the denotational meaning) from \emph{implementation} (the operational mechanism), ensuring tools are correct-by-construction. The research follows a four-phase structural pipeline:

\paragraph{Phase 1: Semantic Abstraction.}
We abstract the domain of interaction by rejecting atomic trace models in favor of a \emph{multi-layered} approach. Interaction is modeled as the semantic intersection of independent strategies, allowing us to reason formally about obstruction and interference.

\paragraph{Phase 2: Denotational Specification.}
We adopt a \emph{semantics-first} strategy, defining abstract truth conditions before execution mechanisms. We prioritize \emph{tightness}—the ability to render precise verdicts on finite prefixes. We start with binary compliance, refine it into a blame-assignment model, and extend it to the quantitative domain.

\paragraph{Phase 3: Structural Synthesis.}
We bridge theory and practice using \emph{automata-theoretic synthesis}. We treat the logic as a blueprint for generating deterministic Moore machines, employing structural induction to ensure the monitor's structure mirrors the contract.

\paragraph{Phase 4: Formal Verification.}
We validate the pipeline through \emph{conformance proofs}. We prove that the synthesized automata are logically isomorphic to the denotational semantics, guaranteeing that the executable artifacts faithfully represent the normative intent.

\subsection{Contributions}

This chapter establishes a comprehensive framework for the specification and runtime verification of collaborative normative systems. The primary contribution is a verified pipeline bridging high-level normative abstractions and low-level executable monitors. The specific contributions are:

\begin{enumerate}[Con1]

\item \textbf{Attempt-Based Interaction Model.}
We introduce a formal analysis that distinguishes an agent's \emph{attempt} from the \emph{interaction outcome}. Unlike models that conflate failure to act with blocked action, we treat non-interference as a first-class semantic property, enabling the verification of ``active participation''.

\item \textbf{The Two-Agents Collaborative Normative Logic (\cDL).}
We formalize \cDL, a logic tailored for bilateral, periodic contracts. It extends standard deontic specifications with atomic responsibility modalities, regular expression control flow for triggers and guards, and explicit operators for repetition and contrary-to-duty reparations.

\item \textbf{Theory of Tight and Quantitative Semantics.}
We introduce a \emph{Forward Tight Semantics} for online monitoring. This includes a 5-valued verdict domain that distinguishes eager violations from post-violation extensions and a \emph{Quantitative Blame Semantics} that accumulates penalties over time for open-ended contracts.

\item \textbf{Correct-by-Construction Monitor Synthesis.}
We provide a compilation algorithm that transforms \cDL specifications into deterministic Moore machines. We provide structural proofs that this monitor is operationally equivalent to the tight semantics, guaranteeing correctness by synthesis.

\item \textbf{Formalization of Accountability.}
We contribute a formal definition of \emph{blame assignment} in cooperative settings. We prove that our blame semantics is a consistency-preserving refinement of standard violation semantics, providing a mathematical basis for liability assessment.

\end{enumerate}

\paragraph{Organization.}
We first ground the problem in a rental-agreement example and extract the modeling requirements. We then develop the trace and synchronization layer for collaborative interaction, introduce \cDL, and finally present the monitor-based semantics, blame attribution, and quantitative extensions.

\section{Use Case: Flat Rental Contract}
\label{sec:motivating-example}

To ground the theoretical development in a concrete setting, we examine a simplified residential flat rental agreement. This agreement is abstracted to exclude legal boilerplate, retaining only the core structural elements relevant to our analysis. This abstraction isolates the essential logical phenomena, specifically the collaborative interactions between agents and the temporal evolution of their duties.

\begin{example}\label{ME}
    We present the structure of this simplified rental contract in \ref{fig:ucd}, involving a tenant (agent~1) and a landlord (agent~2). The clauses illustrate cooperative actions such as paying rent and granting occupancy: payment requires both the tenant's offer and the landlord's acceptance, while occupancy requires both the tenant's willingness to occupy and the landlord's permission. The contract also includes a reparation clause and a termination condition, all of which are regulated on a monthly basis and repeat over time.

    \begin{figure}[h!]
    \centering
    \fbox{
    \begin{minipage}{0.95\textwidth}
        \small
        \textbf{Occupancy and Rent Payment}
        \begin{enumerate}
            \item[(C1)] The tenant shall pay the full monthly rent on or before the due date.
            \item[(C2)] The landlord shall guarantee the tenant's right to quiet enjoyment and occupancy of the premises, provided the tenant complies with the agreement.
            \item[(C3)] In the event of non-payment or late payment of rent:
            \begin{enumerate}
                \item[(i)] If the tenant fails to pay by the due date, a late fee of 10\% of the monthly rent shall be assessed.
                \item[(ii)] This late fee shall be due and payable along with the next month's rent.
                \item[(iii)] The late fee does not waive any other rights or remedies available to the landlord under this agreement or the law.
            \end{enumerate}
            \item[(C4)] If the tenant submits a formal request for necessary repairs, the landlord shall carry out the required repairs within one (1) month of receiving the request.
        \end{enumerate}
        
        \vspace{0.5em}
        \textbf{Termination Notice and Continued Occupancy}
        \begin{enumerate}
            \item[(C5)] The tenant may terminate this rental agreement by giving written notice at least three (3) months prior to the intended termination date. Upon doing so, the tenant shall:
            \begin{enumerate}
                \item[(i)] Continue to pay the full monthly rent during the three-month notice period.
                \item[(ii)] Retain the right to occupy the premises for the entirety of the notice period.
                \item[(iii)] Comply with all other terms of the rental agreement during the notice period.
                \item[(iv)] Vacate the premises no later than the final day of the notice period, unless otherwise agreed in writing.
            \end{enumerate}
        \end{enumerate}
    \end{minipage}
    }
    \caption{Use Case: Simplified Rental Contract between a landlord and a tenant}
    \label{fig:ucd}
   \end{figure}
\end{example}

\subsection{Illustrative Interaction Scenarios}
To illustrate the practical implications of these clauses, we analyze three hypothetical execution traces over a timeline of months $t=1, 2, \dots$. These scenarios highlight the divergence between simple observation (what happened) and normative analysis (who is responsible).

\paragraph{Scenario 1: Obstruction (The ``Handshake'' Problem).}
Consider the obligation to pay rent (Clause C1) at month $t=1$.
\begin{itemize}
    \item \textbf{Action:} The tenant attempts to initiate the bank transfer.
    \item \textbf{Reaction:} The landlord, wishing to manufacture a reason for eviction, closes the receiving bank account or refuses the check.
    \item \textbf{Observable Outcome:} No money is transferred.
    \item \textbf{Normative Analysis:} A naive monitor observing only ``payment status'' would flag a violation by the tenant. However, in a collaborative framework, the tenant has fulfilled their duty by \emph{attempting} the act. The failure is attributed to the landlord's interference, necessitating a distinction between \emph{attempted payment} and \emph{successful payment}.
\end{itemize}

\paragraph{Scenario 2: Violation and Reparation (The CTD Chain).}
Consider a scenario where the tenant genuinely runs out of funds.
\begin{itemize}
    \item \textbf{Month 1:} tenant fails to pay rent.
    \item \textbf{Immediate Verdict:} Violation of C1. The contract enters a ``violated'' state.
    \item \textbf{Normative Shift:} Clause C3 (Reparation) activates. The tenant now holds a \emph{secondary obligation}: pay Month 1 Rent + Month 2 Rent + 10\% Fee at Month 2.
    \item \textbf{Month 2:} tenant pays the total accumulated amount.
    \item \textbf{Final Verdict:} The violation is considered \emph{repaired}, and the contract returns to a compliant state. The monitor must track this ``state recovery'' rather than permanently aborting at the first failure.
\end{itemize}

\paragraph{Scenario 3: Termination and Temporal Reconfiguration.}
Consider the tenant exercising the power to terminate (Clause C5).
\begin{itemize}
    \item \textbf{Month 5:} tenant issues a formal written notice to terminate.
    \item \textbf{Normative Shift:} This is not a violation but a \emph{state change}. The contract, previously open-ended, is now fixed to terminate at Month 8 ($5+3$).
    \item \textbf{Month 6--8:} The tenant stops paying rent, assuming the notice ended the contract immediately.
    \item \textbf{Verdict:} Violation. The monitor must enforce that the \emph{obligations persist} during the notice period (Clause C5-i). The exercising of power did not delete the obligations but merely set a horizon for their expiration.
\end{itemize}

\subsection{Formal Modeling Challenges}
\label{subsec:formal-challenges}

While conceptually straightforward, formalizing this contract requires resolving several semantic challenges that standard specification languages (such as LTL or standard Deontic Logic) fail to address adequately.

\paragraph{1. The ``Handshake'' Semantics (Attempts vs.\ Outcomes).}
Clauses C1 and C2 illustrate that compliance is a \emph{joint achievement}. For example, ``Rent Payment'' (C1) semantically implies that the tenant offers the money \emph{and} the landlord accepts it. Standard trace models often represent this as a single atomic event $pay$. However, in a dispute, we must distinguish between the tenant failing to offer rent (tenant violation) and the tenant offering but the landlord blocking the transfer (landlord interference).\\
\textbf{Challenge 1:} The formalism must treat \emph{attempts} and \emph{successful outcomes} as distinct semantic layers to correctly attribute blame.

\paragraph{2. Contrary-to-Duty Structures (Reparation).}
Clause C3 introduces non-monotonicity. If C1 is violated, the contract does not simply evaluate to $\mathit{false}$ (breach). Instead, it transitions to a sub-ideal state where a secondary obligation (the late fee) becomes active. This creates a \emph{reparation chain}: Primary Duty $\to$ Violation $\to$ Secondary Duty.\\
\textbf{Challenge 2:} The logic must support \emph{recoverable violations}, allowing the monitoring status to fluctuate between ``violated'' and ``repaired'' over time.

\paragraph{3. Reactive Triggers and Monitoring Horizons.}
Clause C4 (Repairs) imposes a duty with a relative deadline: ``within one month of request''. From a monitoring perspective, this requires \emph{forward-looking tightness}. We cannot wait for an infinite trace to determine if the repair happened.
\\\textbf{Challenge 3:} The semantics must identify the \emph{exact finite prefix} where the deadline is missed to trigger a verdict immediately (eager rejection).

\paragraph{4. Hohfeldian Powers and Structural Change.}
Clause C5 (Termination) represents a \emph{Power} rather than a simple duty. By exercising this power, the tenant unilaterally alters the normative landscape, changing an open-ended/infinite contract into a finite one (ending in 3 months).
\\\textbf{Challenge 4:} The framework must model agents not only as actors within the rules but as entities capable of modifying the rules or their duration dynamically.

\subsection*{Summary}
These scenarios motivate the need for a new logic of collaboration. This logic must represent strategies of multiple agents acting in tandem rather than in opposition, express obligations and powers in a uniform framework, capture open-ended dynamics, and support the analysis of compliance and blame. Such a framework requires both a formal model of interacting agent behaviors and a language with syntax and semantics suited to normative reasoning in collaborative, time-sensitive contracts.

  
\section{Abstractions for Collaborative Interaction}
\label{sec:multiagent-sync}

This section builds on the trace models and synchronization operators introduced in \ref{traces}. We keep periodic synchronized set traces as the underlying execution model and define an interaction layer that (i) distinguishes agent-local attempts from jointly successful outcomes and (ii) prepares the ground for strategy analysis and, later, normative evaluation.

The choice of synchronization is not cosmetic. It clarifies what constitutes feasible joint behavior, which, in turn, drives semantic validity, strategy quantification, and downstream analysis of compliance, responsibility, or blame.

% 
%   Synchronization disciplines adopt different assumptions about time. Interleaving and handshake reason about order without a global clock. Lockstep assumes a single round clock. Timed models use absolute time stamps. We work with two agents \(\agt=\{1,2\}\), discrete time \(\mathbb{N}\), and per-agent alphabets \(\Sigma_i\).  



We introduce the attempted/successful abstraction, suited for capturing interference and collaboration between agents in the context of collaborative normative specifications, and discuss how it resembles and differs from existing synchronization techniques in the literature.
 This contribution is not cosmetic: it determines which joint behaviors are feasible, what formulas are satisfied, and how knowledge and responsibility are assessed.


\paragraph{Method and structure.}

To reason about \emph{attempted, prevented, and successful collaboration}, we introduce our contribution of attempted/successful
abstraction on periodic, agent-tagged set traces of collaborative alphabets: (i) \emph{attempted} collaboration is captured by
per-agent enabler sets (active participation) in a period; (ii) \emph{prevented} collaboration arises
from blocker (non-interference violations); and (iii) \emph{successful} collaboration is defined by
the operator \(\mathrm{Succ}\), the point-wise intersection of the two agents’ untagged suggested sets
(equivalently, the set-theoretic image of lockstep-with-handshakes on the collaboration alphabet).

\subsubsection{Modeling Requirements}
\label{subsec:what-to-model}

The aim is to capture two complementary facets of collaboration between agents that standard system-centric models overlook, as illustrated in Example~\ref{ME}:

\begin{itemize}
 \item \textbf{Negative performance (non-interference).}
 One agent must \emph{refrain} from actions that would block the other from achieving a legitimate objective.
 In a tenant--landlord scenario, the landlord should not perform blocking actions such as
 \(\textsf{cut\_power}\), \(\textsf{change\_lock}\), or \(\textsf{enter\_flat}\), which would hinder the tenant’s ability to \(\textsf{occupy}\) the flat.

 \item \textbf{Active participation (positive performance).}
An agent must \emph{contribute} and perform actions that make the objective of the counterpart achievable within the agreed period.
 For example, the landlord should provide/confirm \(\textsf{account\_info}\), \(\textsf{ack\_pay}\), and \(\textsf{grant\_occ}\) upon settlement; symmetrically, the tenant should \(\textsf{pay\_rent}\) and not \(\textsf{return\_payment}\).
\end{itemize}

\noindent These performance aspects are common in normative / contract settings but are underexplored by classical synchronization operators (interleaving, lockstep), which specify \emph{how} events align rather than whether agents \emph{refrain} from harmful actions or \emph{contribute} enabling ones.

\subsection{From Metric-Timed to Collaborative Periodic Synchronized Set Traces}

In this subsection, we explicate the abstraction process as a two-step transformation starting from raw timed observations that record the timing and content of agent actions.
First, these raw inputs are organized into \textbf{agent-local metric-timed traces}, a format that strictly preserves individual responsibility and temporal order.
From this metric foundation, we impose contractual granularity by aggregating behavior into \textbf{period-based set traces} aligned with the contract's calendar.
Finally, concrete actions within these sets are abstracted into \textbf{collaborative objectives}.
This yields a representation where attempts, obstructions, and potential joint successes can be analyzed independently.
Throughout this pipeline, representational detail is reduced while ensuring that all normatively relevant distinctions are preserved.
Crucially, no behavior is discarded or reinterpreted; rather, it is lifted to a level of abstraction suitable for contractual reasoning.
Example~\ref{ex:timed-words-only} serves as the concrete starting point for this process, illustrating the four-month execution before any synchronization or success computation is applied.


\begin{example}[Four-month rental dispute as metric-timed traces]
 \label{ex:timed-words-only}
 We return to the rental agreement introduced in Example~\ref{ME}, in which a tenant (agent~1) and a landlord (agent~2) have signed a monthly contract governing rent payments and occupancy.
 We observe their concrete behavior over a period of four months, corresponding to days $t\in\{0,\dots,120\}$.
 
 During the first month of observation, the tenant transfers the rent on day~5 (\textsf{pay\_rent}), yet does not move into the flat. One day later, on day~6, the landlord formally acknowledges receipt of the payment (\textsf{ack\_pay}).

In the second month, the interaction becomes more active. On day~35, the tenant begins occupying the flat (\textsf{start\_occ}) and then makes the rent payment the next day. The landlord responds by issuing an administrative acknowledgement on day~37 (\textsf{ack\_pay}).

In the third month, the dispute begins: the tenant continues to occupy the flat but makes no rent payments, while the landlord remains passive and takes no observable action.

In the fourth month, the tenant attempts to address the earlier non-payment by transferring a late fee on day~95 (\textsf{pay\_rent\_f}). This attempt is immediately rejected by the landlord on the same day (\textsf{ref\_pay}). On the following day, day~96, the landlord escalates the situation by changing the lock, thereby actively preventing continued occupancy (\textsf{change\_lock}).
 From the concrete observations, we identify the following agent-local action alphabets:
 \[
   \begin{aligned}
   \Sigma_1 &= \{\,\textsf{pay\_rent},\ \textsf{pay\_rent\_f},\ \textsf{start\_occ},\ \textsf{stop\_occupy}\,\},\\
   \Sigma_2 &= \{\,\textsf{ack\_pay},\ \textsf{grant\_occ},\ \textsf{ref\_pay},\ \textsf{change\_lock}\,\}.
   \end{aligned}
 \]
 
 The observed behavior of each agent is encoded as a metric-timed trace, where each event is paired with its occurrence time:
 \[
 \begin{aligned}
 \taumt_{1}
 &=\trace{(\textsf{pay\_rent},5),\ (\textsf{start\_occ},35),\ (\textsf{pay\_rent},36), (\textsf{pay\_rent\_f},95)},\\
 \taumt_{2}
 &=\trace{(\textsf{grant\_occ},1),\ (\textsf{ack\_pay},6),\ (\textsf{ack\_pay},37),\ (\textsf{ref\_pay},95),\ (\textsf{change\_lock},96)}.
 \end{aligned}
 \]
 These timed words constitute the most concrete representation of the interaction and serve as the starting point for the abstraction pipeline developed in this section.
 \end{example}

From these metric-timed traces, the behavior in each month is precise at a day level and could be abstracted in a monthly view. In the first month, rent is paid and accepted, and occupancy is granted but not yet exercised. In the second month, occupancy begins, and payment is acknowledged without conflict.
In the third month, the tenant continues to occupy while failing to pay, and the landlord remains passive. 
In the fourth month, the tenant attempts to remedy the earlier violation by paying a late fee, which is explicitly rejected, and then engages in active obstruction of occupancy by changing the lock.
While this description is clear at the level of concrete events, it is not yet aligned with the contractual semantics, which operate on monthly obligations and joint outcomes rather than individual timestamps. This motivates the next step: synchronizing the agent-local traces into a common period-based structure that supports collaboration, interference, and normative evaluation.
\subsubsection{Step 1: Abstraction into Periodic Synchronized Set trace}
Since the contract regulates obligations and permissions \emph{per month} rather than per day, we periodize
the timeline into month windows $\Ik{1},\Ik{2},\Ik{3},\ldots$ and aggregate the actions of each agent
within the same window into a \emph{set}. This yields a synchronous round-based abstraction aligned with the contract calendar.

\begin{definition}[Periodic synchronized set trace]\label{def:periodic}
  A \defn{periodic synchronized set trace} for agent $i$ over the alphabet $\Sigma_i$, relative to a global clock with a fixed period length, is an infinite sequence of action sets indexed from $1$:
  \[
  \pi_i \;=\; \trace{\Aik{i}{1},\ \Aik{i}{2},\ \Aik{i}{3},\ \dots}
  \ \in\ (2^{\Sigma_i})^{\infty}.
  \]
  Each element $\Aik{i}{k}\subseteq \Sigma_i$ represents the set of actions attributed to agent $i$ during period $k$ (where $\emptyset$ denotes inactivity).
  \end{definition}

\noindent Having defined the target domain of period-based set traces, we now establish the link to the concrete observations.
Since our starting point are metric-time traces of individual events (as seen in Example~\ref{ex:timed-words-only}), we must map these timestamps into the discrete calendar defined by the contract.
The following definition formalizes this abstraction process by partitioning the timeline into fixed-size windows and aggregating all events occurring within each window into a single set.
  
  \begin{definition}[Aggregation to periodic synchronized set trace]
  Let $x \in \mathbb{N}$ be a fixed period length.
  Define the aggregation function
  \[
  \AGGI_{x} : (\Sigma \times \mathbb{N})^{*} \longrightarrow (2^{\Sigma})^{*}
  \]
  as follows.
  
  Given a finite metric-timed trace
  \[
  \taumt = \trace{(a_1,t_1),\dots,(a_n,t_n)}
  \quad\text{with } a_j \in \Sigma,\ t_j \in \mathbb{N}\ \text{for all } j\in\{1,\dots,n\},
  \]
  we partition time into period windows of length $x$:
  \[
    I_k \;:=\;
    [(k-1)x + 1,\ kx]
    \qquad (k \ge 1).
  \]
  The aggregated periodic synchronized set trace
  \[
  \AGGI_x(\taumt) := \pi = \trace{A_1,\dots,A_K}
  \]
  is defined by
  \[
  A_k := \{\, a \in \Sigma \mid \exists\, t \in I_k:\ (a,t) \in \taumt \,\},
  \]
  where
  \[
  K := \max\{\, k \mid I_k \cap \{t_1,\dots,t_n\} \neq \emptyset \,\}.
  \]
  \end{definition}
  
  \begin{proof}
  By definition of $\AGGI_x$, membership $a \in A^{(i)}_k$ and $b \in A^{(i)}_{\ell}$ yields witnesses
  $t_a \in I_k$ and $t_b \in I_{\ell}$ with $(a,t_a),(b,t_b) \in \taumt_i$.
  Since $k < \ell$, the windows are disjoint and strictly ordered (i.e., $\max(I_k) < \min(I_{\ell})$), which implies $t_a < t_b$.
  \end{proof}

\begin{lemma}[Order preservation under aggregation]
\label{lem:agg-to-periodic}
Let $\taumt_i \in (\Sigma_i \times \mathbb{N})^{*}$ be a finite metric-timed trace and let $x \in \mathbb{N}$.
Let
\[
\pi_i := \AGGI_x(\taumt_i) = \trace{A^{(i)}_1,\dots,A^{(i)}_K}.
\]
Then aggregation preserves inter-period order in the following sense:
\begin{align*}
&\forall\, k,\ell \in \{1,\dots,K\},\ k<\ell,\
\forall\, a \in A^{(i)}_k,\ \forall\, b \in A^{(i)}_{\ell},\
\forall\, t_a,t_b:\\&
\bigl((a,t_a)\in\taumt_i \land t_a\in I_k\bigr)\ \land\
\bigl((b,t_b)\in\taumt_i \land t_b\in I_{\ell}\bigr)
\ \Rightarrow\ t_a<t_b.
\end{align*}
\end{lemma}

\begin{proof}
 By definition of $\AGGI_x$, membership $a \in A^{(i)}_k$ and $b \in A^{(i)}_{\ell}$ yields witnesses
 $t_a \in I_k$ and $t_b \in I_{\ell}$ with $(a,t_a),(b,t_b) \in \taumt_i$.
 Since $k < \ell$ implies $I_k < I_{\ell}$ by construction of the period windows,
 we obtain $t_a < t_b$.
 \end{proof}

Nevertheless, aggregation has a cost, as it loses intra-period order, action multiplicity, and exact timestamps. Therefore, selecting the appropriate period normalization is crucial.

\begin{example}[Transforming timed words into periodic set traces, continued from Example~\ref{ex:timed-words-only}]
\label{ex:agg-30-locked}
By fixing the period to 30, we can decompose the 120 days into 4 horizons:
\[
\Ik{1}=[1,30],\qquad \Ik{2}=[31,60],\qquad \Ik{3}=[61,90],\qquad \Ik{4}=[91,120].
\]
The two timed traces $\taumt_1$ and $\taumt_2$ are transformed using the function $\AGGI_{30}$ transformation respectively into:
\[
\begin{aligned}
\pi_1&=\trace{%
\underbrace{\{\textsf{pay\_rent}\}}_{\Ik{1}},\
\underbrace{\{\textsf{start\_occ, \textsf{pay\_rent}}\}}_{\Ik{2}},\
\underbrace{\emptyset}_{\Ik{3}},\
\underbrace{\{\textsf{pay\_rent\_f}\}}_{\Ik{4}}},\\[2pt]
\pi_2&=\trace{%
\underbrace{\{\textsf{grant\_occ},\ \textsf{ack\_pay}\}}_{\Ik{1}},\
\underbrace{\{\textsf{ack\_pay}\}}_{\Ik{2}},\
\underbrace{\emptyset}_{\Ik{3}},
\underbrace{\{\textsf{ref\_pay\_f},\ \textsf{change\_lock}\}}_{\Ik{4}}}.
\end{aligned}
\]
By Lemma~\ref{lem:agg-to-periodic}, for agent~1 the element $\textsf{start\_occ}\in \Aik{1}{2}$ precedes
$\textsf{pay\_rent\_f}\in \Aik{1}{4}$ (witness times $35<95$), and similarly for agent~2.
\end{example}

\subsubsection{Step 2: Abstraction to a Collaboration Alphabet}
The second aspect of the abstraction is the notion of interaction alphabets. The action alphabets of both agents are merged into a single alphabet, and the trace encodes that when $a$ is an event, it indicates that an agent has either instantiated it or accepted to collaborate on it. Conversely, the absence of an action in the event at Set $I_k$ indicates that the agent either did not perform it or actively performed a blocking action to prevent it. This abstraction is demonstrated using the running example, showing that it maintains the same meaning while reducing the number of action types. An operator is then introduced to compute the successful interaction at each period of the synchronized trace. This transformation cannot be automated unless the set of enabling and interfering actions is explicitly stated in the normative specification; otherwise, the digitization engineer must define them manually, as is done here.

We consider three collaborative objectives that are identified in the Example~\ref{ME}:
\(\PAY\) (rent payment), \(\PAYF\) (penalty/late-fee payment), and \(\OCC\) (tenant’s occupancy).
We write \(\Sigma_C=\{\PAY,\PAYF,\OCC\}\).

In the next step, we need to define how the actions of the agents, namely $\Sigma_1$ and $\Sigma_2$, relate to collaborative action over $\Sigma_C$, more specifically, whether they are enabler or interference actions. We do not take the union \(\Sigma_1\cup\Sigma_2\) as a synchronization operator discussed in the \ref {operators}. Instead, we define a many-to-one \emph{abstraction} from concrete per-agent actions to the collaboration alphabet \(\Sigma_C\).
On the tenant side, \textsf{pay\_rent} and \textsf{pay\_rent\_f} are enablers because they instantiate the tenant’s contribution toward \PAY and \PAYF; \textsf{start\_occ} is an enabler for \OCC because it is the tenant’s side of taking possession. A chargeback \textsf{return\_payment} and \textsf{return\_payment\_f} are blocking: they nullify the very transfer that \PAY and \emph{PAY\_F} rely on. On the landlord side, \textsf{ack\_pay} enables \PAY, while \textsf{grant\_occ} enables \OCC by authorizing access. In contrast, \textsf{ref\_pay} blocks \PAY even if the tenant initiated payment, and \textsf{change\_lock}, \textsf{cut\_power}, or \textsf{enter\_flat} block \OCC by making continued possession impracticable or unlawful. This enabler/blocker partition is precisely what our “suggested/successful” abstraction needs: success in a period occurs when both sides propose the required enablers and neither side performs a blocker.


\paragraph{Distinguishing enabling from Blocking actions} For each agent \(i\in\{1,2\}\) we partition the alphabet into
\(\SigA{i}\) (actions that constitute \emph{active participation}, i.e., enablers)
and \(\SigI{i}\) (actions that constitute \emph{negative performance}, i.e., blockers), with
\(\Sig{i}=\SigA{i}\cup\SigI{i}\), assuming that they are disjoint. In our running example:
\[
\begin{aligned}
\SigA{1} &= \{\,\textsf{pay\_rent},\ \textsf{pay\_rent\_f},\ \textsf{start\_occ}\,\},\\
\SigI{1} &= \{\,\textsf{refuse\_inspection}\,\}.\\[4pt]
\SigA{2} &= \{\,\textsf{ack\_pay},\ \textsf{grant\_occ}\,\},\\
\SigI{2} &= \{\,\textsf{ref\_pay},\ \textsf{change\_lock},\ \textsf{ref\_pay\_f} ,\ \textsf{enter\_flat}\,\}.
\end{aligned}
\]
with:
\[
\Sig{1}=\SigA{1}\uplus\SigI{1},\qquad
\Sig{2}=\SigA{2}\uplus\SigI{2},\qquad
\Sigma=\Sig{1}\cup\Sig{2}.
\]

For brevity, below we write the \emph{enabler} and \emph{blocker} sets as
\[
E_i:=\SigA{i}\quad\text{and}\quad B_i:=\SigI{i}\qquad(i\in\{1,2\}).
\]
Presence of \(a\in E_i\) in period \(k\) signals that agent \(i\) took a
\emph{positively contributing} action; presence of \(b\in B_i\) signals a
\emph{defeating} (interfering) action. The absence of a symbol indicates it was not suggested/endorsed during that period.


\paragraph{Transformation sketch} After defining this relation, we can transform any periodic synchronous word  $\pi_1$ over $\Sigma_1$ and $\pi_2$ over  $\Sigma_2$ to a corresponding word over $\Sigma_C$, written $\pi_i^C$:
\begin{itemize}
\item If an action $a$ is on event $A$ from $\pi_i$ and that action is in $E_i$, then this action is transformed to its equivalent collaborative action and inserted on the resulting word $\pi_i^C$.
\item If an action $a$ is on event $A$ from $\pi_i$ and that action is in $B_i$, then this action is not transformed and not inserted on the resulting word $\pi_i^C$.
\end{itemize}
And additionally, we do not add any collaborative action not present in an event on the equivalent event in $\pi_i^C$ unless it is a continuous collaboration with implicit collaboration, as $\textsf{start\_occ}$ signals the start of occupying the flat, so it is kept inserted in the following events in the timed word of the tenant and landlord as long as tenant does not leave nor the landlord blocks actively the occupation.



\begin{example}[Transforming the periodic synchronized words over $\Sigma_1,\Sigma_2 $ to periodic synchronized words over $\Sigma_C$ ]\label{ex:collab}
Using the traces from Example~\ref{ex:agg-30-locked},
\[
\begin{aligned}
\pi_1&=\trace{%
\underbrace{\{\textsf{pay\_rent}\}}_{\Ik{1}},\ 
\underbrace{\{\textsf{start\_occ}, \textsf{pay\_rent} \}}_{\Ik{2}},\ 
\underbrace{\emptyset}_{\Ik{3}},\ 
\underbrace{\{\textsf{pay\_rent\_f}\}}_{\Ik{4}}
},\\[2pt]
\pi_2&=\trace{%
\underbrace{\{\textsf{grant\_occ},\ \textsf{ack\_pay}\}}_{\Ik{1}},\ 
\underbrace{\{\textsf{ack\_pay}\}}_{\Ik{2}},\ 
\underbrace{\emptyset}_{\Ik{3}},\ 
\underbrace{\{\textsf{ref\_pay\_f},\ \textsf{change\_lock}\}}_{\Ik{4}}
}.
\end{aligned}
\]
With \(E_1(\PAY)=\{\textsf{pay\_rent}\}\),\(E_1(\PAYF)=\{\textsf{pay\_rent\_f}\}\)
\(E_2(\PAY)=\{\textsf{ack\_pay}\}\),
\(B_2(\PAY)=\{\textsf{ref\_pay}\}\),
\(E_1(\OCC)=\{\textsf{start\_occ}\}\),
\(E_2(\OCC)=\{\textsf{grant\_occ}\}\),
\(B_2(\OCC)=\{\textsf{change\_lock}\}\).
Consequently, the collaboration alphabet is:
\[
\Sigma_C=\{\PAY,\ \PAYF,\ \OCC\}.
\]
The corresponding collaboration-trace abstractions of $\pi_1$ and $\pi_2$ are $\pi_1^C$ and $\pi_2^C$:
\[
\begin{aligned}
\pi_1^{C}&=\trace{%
\underbrace{\{\pay{1}\}}_{\Ik{1}},\ 
\underbrace{\{\occ{1},\ \pay{1}\}}_{\Ik{2}},\ 
\underbrace{\{\occ{1}\}}_{\Ik{3}},\ 
\underbrace{\{\payf{1}\}}_{\Ik{4}}
},\\[2pt]
\pi_2^{C}&=\trace{%
\underbrace{\{\occ{2},\ \pay{2}\}}_{\Ik{1}},\ 
\underbrace{\{\occ{2},\ \pay{2}\}}_{\Ik{2}},\ 
\underbrace{\{\occ{2}\}}_{\Ik{3}},\ 
\underbrace{\emptyset}_{\Ik{4}}
}.
\end{aligned}
\]
Reading: in month \(\Ik{1}\), agent~1 positively contributes to $\PAY$, and agent~2 allows $\OCC$\ and accepts $\PAY$.
In \(\Ik{2}\), agent~1 pays the rent and occupies the flat and agent~2 contributes to $\PAY$ and allows the occupation $\OCC$. In \(\Ik{3}\), agent~1 keeps $\OCC$ but does not pay, and the landlord keeps allowing $\OCC$. In \(\Ik{4}\), the landlord blocks both $\PAY$ and denies $\OCC$, although the tenant wants to keep occupying the flat and pays.
\end{example}

  
  
  \subsubsection{Optional Step: Successful Collaboration Trace}
  
   The abstraction introduced so far separates agent-local attempts and interference while preserving all information required for responsibility analysis.
    In some situations, however, it is useful to additionally extract the \emph{jointly successful} outcomes that emerge when both agents contribute compatibly within the same contractual period.
     We introduce an optional transformation that computes such outcomes explicitly. The construction follows the same underlying principle as lockstep synchronization with handshakes  inspired from Definition~\ref{def:collapsed-hs}: a collaborative action is realized at a given period if and only if both agents propose it in that period. Technically, this is captured by erasing agent tags and intersecting the per-period action sets. Unlike earlier abstraction steps, this operator is not used as the primary semantic basis of the framework, since it intentionally discards information about obstruction and responsibility. Instead, it serves as a derived view that characterizes successful collaboration in isolation, making precise the connection between our attempt-based abstraction and classical handshake-based synchronization models.
  
  \begin{definition}[Successful collaboration operator]\label{successcomb}
  Let  $\Sigma$ be an alphabet and let $\Sigma^{(1)}:=\{\,a^{(1)}\mid a\in\Sigma\,\}$ and
  $\Sigma^{(2)}:=\{\,a^{(2)}\mid a\in\Sigma\,\}$ be disjoint tagged copies.
  The \emph{successful collaboration operator}, written $\mathsf{Succ}$ of two periodic synchronous traces $\pi_1$ over $\Sigma^{(1)}$ and $\pi_2$ over $\Sigma^{(2)}$ on the same maximum horizon $T$ is defined event-wise by:
  \[\forall k\in\{1,\dots,T\},
  \mathrm{Succ}(\pi_1,\pi_2)[k]
  \ := \unlab\!\big(\pi_1[k]\big) \cap\ \unlab\!\big(\pi_2[k]\big).
  \]
  where the function $\unlab$ is removing any of the agent identifiers tag from an event, \eg  $\unlab(\{\OCC^{2}\})=\{\OCC\}$ .
  \end{definition}
  \begin{example}[Successful collaboration]
  From the two transformed traces  $\pi_1^{C}$ and $\pi_2^{C}$ from the Example~\ref{ex:collab}.
  We illustrate \(\mathrm{Succ}(\pi_1^{C},\pi_2^{C})\)  in \ref{example:succ-meet}.
  \end{example}

  \boxalignfigure{ \resizebox{0.96\textwidth}{!}{
  \begin{tikzpicture}[y=2cm,x=3cm]
    % Uniform rectangle nodes for all events (no colors)
    \tikzset{
      event/.style={
        draw,
        rectangle,    % fixed width for all nodes
        minimum height=9mm, 
        minimum width=20mm, % fixed height for all nodes
        align=center,
        rounded corners=2pt,
        font=\small
      }
    }
  
    % top row: agent 1 (tagged)
    \node[event] at (1,0)   (t1) {$\{\pay{1}\}$};
    \node[event] at (2.5,0)   (t2) {$\{\occ{1},\pay{1}\}$};
    \node[event] at (3.7,0)   (t3) {$\{\occ{1}\}$};
    \node[event] at (4.8,0)   (t4) {$\{\payf{1}\}$};
  
    % middle row: agent 2 (tagged)
    \node[event] at (1,-1)  (l1) {$\{\occ{2},\pay{2}\}$};
    \node[event] at (2.5,-1)  (l2) {$\{\occ{2},\pay{2}\}$};
    \node[event] at (3.7,-1)  (l3) {$\{\occ{2}\}$};
    \node[event] at (4.8,-1)  (l4) {$\emptyset$};
  
    % bottom row: success = unlabel + intersection
    \node[event] at (1,-2) (h1) {$\{\PAY\}$};
    \node[event] at (2.5,-2) (h2) {$\{\OCC,\PAY\}$};
    \node[event] at (3.7,-2) (h3) {$\{\OCC\}$};
    \node[event] at (4.8,-2) (h4) {$\emptyset$};
  

    % time/progression connectors
    \path[shorten >=0pt]
      (0,0) node[left] {$\pi_1^{C}$} edge[|-]
      (t1) (t1) edge (t2) (t2) edge (t3) (t3) edge (t4) (t4) edge[->] +(1,0)
      (0,-1) node[left] {$\pi_2^{C}$} edge[|-]
      (l1) (l1) edge (l2) (l2) edge (l3) (l3) edge (l4) (l4) edge[->] +(1,0)
      (0,-2) node[left, align=center] {$\mathrm{Succ}(\pi_1^{C}, \pi_2^{C})$ } edge[|-]
      (h1) (h1) edge (h2) (h2) edge (h3) (h3) edge (h4) (h4) edge[->] +(1,0);
  \end{tikzpicture}}}
  {Example: successful collaboration computation example}
  {example:succ-meet}
  
  \noindent\textbf{Basic properties.}
  Since \(\mathrm{Succ}\) is a point-wise set intersection after tag erasure,
  it inherits three immediate facts:
  \emph{(i) Commutative and idempotent}:
  \(\mathrm{Succ}(\pi_1,\pi_2)=\mathrm{Succ}(\pi_2,\pi_1)\) and
  \(\mathrm{Succ}(\pi,\pi)=\unlab(\pi)\).
  \emph{(ii) Monotone (pointwise \(\subseteq\))}: writing
  \(\pi\le\pi'\) to mean
  \(\forall k:\ \unlab(\pi[k])\subseteq\unlab(\pi'[k])\),
  if \(\pi_1\le\pi_1'\) and \(\pi_2\le\pi_2'\) then
  \(\mathrm{Succ}(\pi_1,\pi_2)\le \mathrm{Succ}(\pi_1',\pi_2')\).
  \emph{(iii) Absorbing empty trace}:
  if \(\forall k,\ \pi_2[k]=\emptyset\),
  then \(\forall k,\ \mathrm{Succ}(\pi_1,\pi_2)[k]=\emptyset\).
  
  \begin{remark}{Relation to \(\parallel_{\mathrm{hs}}^{A}\).}
  If we declare every collaborative objective to be a handshake,
  \(A=\Sigma_C\), then the lockstep-with-handshakes product enforces that
  \(\PAY\), \(\PAYF\), \(\OCC\) can only appear at a period when both agents
  present the same letter. Concretely, if we view each period’s set
  \(A^{(i)}_k\) as the multiset of letters occurring “at that round” and apply
  \(\parallel_{\mathrm{hs}}^{A}\) round-wise, then after collapsing paired
  handshakes to a single shared symbol (via \(\mathsf{coll}_A\)) and unlabeling,
  we obtain exactly the success:
  \[
  \mathrm{Succ}(\pi_1,\pi_2)
  \ =\
  \unlab\!\big(\mathsf{coll}_{\Sigma_C}\big(\pi_1\parallel_{\mathrm{hs}}^{\Sigma_C}\pi_2\big)\big),
  \]
  i.e., \(\mathrm{Succ}\) is the set-theoretic intersection semantics of
  lockstep-plus-handshakes on the collaboration alphabet.    
  \end{remark}
  However, this abstraction masks the specific source of interference, effectively hiding the agent responsible for the failure. As our framework aims to explicitly assign blame, we introduce this operator primarily as an optional view to characterize joint success.
  We now move to reasoning about strategies from agents, where each agent makes a plan based on the other agent's past behavior.
  \subsection{Interaction Strategies as Moore Machines}
  Most monitoring approaches analyse compliance only after an execution has occurred. This chapter goes further by modelling how agents plan their interaction in anticipation of each other’s behavior. By representing strategies as Moore machines, we make responsibility analyzable as an ex ante property of interacting plans, not merely as a retrospective judgement over completed traces.
  
  


  
  
  
  \subsubsection{Strategy Model}
  
  We capture interaction strategies with \emph{input/output} models that operate at the period granularity.
  At each period $k$, each agent $i$ observes the other agent's period-$k$ output and updates its
  internal state to produce its own period-$(k{+}1)$ output. We use \emph{Moore machines} so that an
  agent’s output at period $k$ depends only on its current state (perfect monitoring with one-period delay).
  A synchronous feedback composition couples the two machines.
  
  % In the preamble (once):
  % \newcommand{\PAY}{\mathsf{PAY}}
  % \newcommand{\PAYF}{\mathsf{PAYF}}
  % \newcommand{\OCC}{\mathsf{OCC}}
  % \newcommand{\unlab}{\mathsf{unlab}}
  
  \begin{definition}[Deterministic Moore machine]
  \label{def:moore}
  A deterministic Moore machine for agent $i$ is a 6-tuple
  \[
  M_i \;=\; (S_i, s^0_i,\ \Sigma_I^i,\ \Sigma_O^i,\ \delta_i,\ \lambda_i),
  \]
  where:
  \begin{itemize}
    \item $S_i$ is a finite set of states with initial state $s^0_i\in S_i$;
    \item $\Sigma_I^i$ is the input alphabet (the other agent’s \emph{untagged} collaborative letters);
    \item $\Sigma_O^i$ is the set of output symbols;
    \item $\delta_i: S_i \times 2^{\Sigma_I} \to S_i$ is a deterministic transition function;
    \item $\lambda_i: S_i \to 2^{\Sigma_O}$ is the output function.
  \end{itemize}
  Given an input stream $X=(X_0,X_1,\dots)$ with $X_k\subseteq\Sigma_I$, the induced run is
  $s^0_i,s^1_i,\dots$ with $s^{k+1}_i=\delta_i(s^k_i,X_k)$ and outputs $Y_k=\lambda_i(s^k_i)$.
  \end{definition}
  
  \begin{definition}[Run and output of a deterministic Moore machine]
    \label{def:moore-run}
    Let 
    \[
    M_i \;=\; (S_i, s^0_i,\ \Sigma_I^i,\ \Sigma_O^i,\ \delta_i,\ \lambda_i)
    \]
    be a deterministic Moore machine for agent $i$ as in Definition~\ref{def:moore}.
    An \emph{input stream} for $M_i$ is a finite or infinite sequence 
    $X = (X_0,X_1,\dots)$ with $X_k \subseteq \Sigma_I^i$ for all positions $k$.
    
    \medskip
    \noindent\textbf{Run.}
    The \emph{run of $M_i$ on $X$} is the unique sequence of states
    \[
    \rho_i(X) \;=\; (s^0_i,s^1_i,s^2_i,\dots)
    \]
    inductively defined by
    \[
    s^{0}_i := s^0_i,
    \qquad
    s^{k+1}_i := \delta_i(s^k_i, X_k)
    \quad\text{for all }k \ge 1.
    \]
    
    \noindent For finite input $X$ of length $n{+}1$ we write $|X|=n{+}1$ and 
    $\rho_i(X) = (s^0_i,\dots,s^{n+1}_i)$.
    
    \medskip
    \noindent\textbf{Extended transition function.}
    For later use, we define the extended transition function
    \[
    \delta_i^{*} : S_i \times (2^{\Sigma_I^i})^{*} \to S_i
    \]
    by
    \[
    \delta_i^{*}(s, \varepsilon) := s,
    \qquad
    \delta_i^{*}(s, X_0\cdot X') := 
    \delta_i^{*}\bigl(\delta_i(s,X_0),\,X'\bigr),
    \]
    for $X_0 \in 2^{\Sigma_I^i}$ and $X' \in (2^{\Sigma_I^i})^{*}$.
    For a finite input word $X$, we write
    \[
    \delta_i(s^0_i,X) \;:=\; \delta_i^{*}(s^0_i,X),
    \]
    so that the last state of the run on $X$ is $\delta_i(s^0_i,X)$.
    
    \medskip
    \noindent\textbf{Output word and terminal output.}
    The \emph{output word} induced by $M_i$ on $X$ is
    \[
    \lambda_i^{\omega}(X) \;:=\; (Y_0,Y_1,\dots)
    \quad\text{with}\quad
    Y_k := \lambda_i(s^k_i).
    \]
    For a finite input word $X$ the \emph{terminal output} of $M_i$ on $X$ is
    \[
    \lambda_i\bigl(\delta_i(s^0_i,X)\bigr),
    \]
    which is the output associated with the last state of the run on $X$.
    \end{definition}
  
  \subsubsection{Synchronous Feedback Composition}
  
  We present the property of two Moore machines that can feed each other and progress together.
  
  \begin{definition}[Complementary Moore machines]
  \[\text{Let } 
  M_i \;=\; (S_i, s^0_i,\ \Sigma_I^i,\ \Sigma_O^i,\ \delta_i,\ \lambda_i) \text{ and } M_j \;=\; (S_j, s^0_j,\ \Sigma_I^j,\ \Sigma_O^j,\ \delta_j,\ \lambda_j) 
  \]
  be two deterministic Moore machines, we say that \emph{$M_i$ and $M_j$ are complementary} if and only if:
  \[ \Sigma_I^i = \Sigma_O^j \text{ and } \Sigma_O^i = \Sigma_I^j.\]
  \end{definition}
  In the following, we introduce an example of how to use Moore machines to capture two strategies that the landlord and the tenant should consider in the motivating example.
  \begin{example}[Interaction strategies and their Moore encodings]
  \label{ex:twomoore}
  Consider the two first informal strategies $\strat_1^1$ and $\strat_2^1$ from respectively the tenant(1) and the landlord(2):
  
  \medskip
  \noindent\textbf{tenant $\strat_1^1$.}
  “I pay in the first month; from the second month on, I occupy and keep paying as long as the landlord does not stop me. If the landlord stops my occupancy, I stop paying.”
  
  \noindent\textbf{landlord $\strat_2^1$.}
  “I enable occupancy from the first month and accept payment; if the tenant fails to pay for \emph{two consecutive} months, I stop enabling occupancy.”
  We encode both of those strategies using: $\Sigma_C^{(1)}:=\{a^{(1)}\mid a\in\Sigma_C\}$ and
  $\Sigma_C^{(2)}:=\{a^{(2)}\mid a\in\Sigma_C\}$ be the tagged disjoint copies.
  Both machines use $S=\{s_0,s_1,s_2\}$ with initial state $s_0$.
  Transitions are guarded by the current letters of the agent \emph{other} (seen as a set).

  The tenant strategy and the landlord strategy are depicted explicitly by their Moore machine encoding in Figure~\ref{fig:moore-tenant-prod} and Figure~\ref{fig:moore-landlord-prods}, respectively.
  
  
  \[
  \begin{aligned}
  M_1^1&=(S,s_0,\ \Sigma_I^{(1)},\Sigma_O^{(1)},\ \delta_1,\lambda_1),
  &\Sigma_I^{(1)}&=2^{\Sigma_C^{(2)}},& \Sigma_O^{(1)}&=2^{\Sigma_C^{(1)}},\\
  M_2^1&=(S,s_0,\ \Sigma_I^{(2)},\Sigma_O^{(2)},\ \delta_2,\lambda_2),
  &\Sigma_I^{(2)}&=2^{\Sigma_C^{(1)}},& \Sigma_O^{(2)}&=2^{\Sigma_C^{(2)}}.
  \end{aligned}
  \]
  For $X\subseteq\Sigma_C^{(2)}$, $Y\subseteq\Sigma_C^{(1)}$:
  \[
  \delta_1(s_0,X)=\begin{cases}s_1&\OCC^{(2)}\in X\\ s_0&\text{otherwise}\end{cases},\ \ 
  \delta_1(s_1,X)=\begin{cases}s_1&\OCC^{(2)}\in X\\ s_2&\text{otherwise}\end{cases},\ \ 
  \delta_1(s_2,X)=s_2,
  \]
  \[
  \delta_2(s_0,Y)=\begin{cases}s_0&\PAY^{(1)}\in Y\\ s_1&\text{otherwise}\end{cases},\ \ 
  \delta_2(s_1,Y)=\begin{cases}s_0&\PAYF^{(1)}\in Y\\ s_2&\PAY^{(1)}\in Y\\ s_1&\text{otherwise}\end{cases},\ \ 
  \delta_2(s_2,Y)=s_2.
  \]
  
  Notice that the two Moore machines are complementary.
  \end{example}
  
  Now we move to the step where both strategies are fixed and transformed to compute their outcome. To do so, we introduce the product of two complementary Moore machines.
  
  
  \begin{definition}[Product of Complementary Deterministic Moore Machines]
  
  \[\text{Let }
  M_i \;=\; (S_i, s^0_i,\ \Sigma_I^j,\ \Sigma_O^i,\ \delta_i,\ \lambda_i)
  \quad\text{and}\quad
  M_j \;=\; (S_j, s^0_j,\ \Sigma_I^i,\ \Sigma_O^j,\ \delta_j,\ \lambda_j)
  \]
  be two deterministic complementary Moore machines.
  The \emph{product} of $M_i$ and $M_j$ is the automaton
  \[
  M_i \otimes M_j \;=\; (\,\Sigma,\ Q,\ q_0,\ \delta,\ F\,)
  \]
  where
  \begin{itemize}
      \item $\Sigma = 2^{\Sigma_O^i \cup \Sigma_O^j}$ is the \emph{joint alphabet},
      \item $Q = S_i \times S_j$ is the \emph{state space},
      \item $q_0 = (s^0_i, s^0_j)$ is the \emph{initial state},
      \item $F = \emptyset$ ,
      \item $\delta \subseteq Q \times \Sigma \times Q$ is the \emph{transition relation}, defined by
      \[
      \big((s_i,s_j),\, A,\, (s'_i,s'_j)\big) \in \delta
      \]
      if and only if
      \[
      A = \lambda_i(s_i) \cup \lambda_j(s_j), 
      \quad s'_i = \delta_i(s_i,\lambda_j(s_j)), 
      \quad s'_j = \delta_j(s_j,\lambda_i(s_i)).
      \]
  \end{itemize}
  The \emph{language} $L(M_i \otimes M_j) \subseteq \Sigma^\omega$ consists of all infinite words
  \[
  \trace{A_1, A_2 \dots}
  \]
  such that there exists a run
  \[
  (s^0_i, s^0_j) \xrightarrow{A_1} (s_{i,1}, s_{j,1}) \xrightarrow{A_2} (s_{i,2}, s_{j,2}) \xrightarrow{A_3} \dots
  \]
  with $A_k = \lambda_i(s_{i,k}) \cup \lambda_j(s_{j,k})$ for all $k \geq 1$.
  \end{definition}
  
  
  
  \begin{lemma}[Unique run and word of product machines]
  \label{lem:product-word}
  Let
  \[
  M_i = (S_i, s^0_i,\ \Sigma_I^j,\ \Sigma_O^i,\ \delta_i,\ \lambda_i)
  \quad\text{and}\quad
  M_j = (S_j, s^0_j,\ \Sigma_I^i,\ \Sigma_O^j,\ \delta_j,\ \lambda_j)
  \]
  be two complementary deterministic Moore machines.  
  Then their product $M_i \otimes M_j$ admits a \emph{unique run}
  \[
  (s^0_i,s^0_j)\,(s_{i,1},s_{j,1})\,(s_{i,2},s_{j,2})\dots
  \]
  and this run induces a \emph{unique word}
  \[
  \pi \;=\; \trace{A_1,A_1,A_2,\dots} \;\in\; \big(2^{\Sigma_O^i \cup \Sigma_O^j}\big)^\omega,
  \]
  where
  \[
  A_t \;=\; \lambda_i(s_{i,t}) \cup \lambda_j(s_{j,t}), \qquad t \ge 0,
  \]
  and the successor states are determined by
  \[
  s_{i,t+1} = \delta_i(s_{i,t},\,\lambda_j(s_{j,t})),\qquad
  s_{j,t+1} = \delta_j(s_{j,t},\,\lambda_i(s_{i,t})).
  \]
  \end{lemma}
  
  \begin{proof}
  Determinism ensures that for every product state $(s_{i,t},s_{j,t})$ there is exactly one
  successor $(s_{i,t+1},s_{j,t+1})$, determined by the mutual feedback of outputs.
  By induction on $t$, this yields a unique run of the product automaton starting from $(s^0_i,s^0_j)$.
  Collecting the joint outputs at each step produces the word $\pi$, which is therefore unique.
  If the run stabilizes in a sink state with constant outputs, $\pi$ is ultimately periodic
  otherwise $\pi$ is infinite.
  \end{proof}
  
  \begin{example}[Product automaton sketch for $M_1^1 \times M_2^1$]
  \label{ex:product-automaton}
  We now project the two Moore machines $M_1^1$ (tenant) and $M_2^1$ (landlord) of
  Example~\ref{ex:twomoore} into their synchronous product $M_1^1 \times M_2^1$.
  Each state of the product records the joint output of both agents in that period, denoted by $\{A_1,A_2\}$, with $A_1\in 2^{\Sigma_C^{(1)}}$ and $A_2\in 2^{\Sigma_C^{(2)}}$.
  The initial state corresponds to $(s^0_1,s^0_2)$; subsequent states reflect how both machines
  progress under synchronous feedback. Once a stable pair of states is reached, the product
  loops, generating the same joint output forever.

  The individual Moore machines underlying the product construction are recalled in Figure~\ref{fig:moore-tenant-prod} and Figure~\ref{fig:moore-landlord-prods}, while their synchronous product is summarized in Figure~\ref{fig:product-sketch} and presented as a whole in \ref{fig:moore-product-full}.
  \begin{figure}[h]
  \centering
  \begin{subfigure}[t]{0.70\textwidth}
  \centering
  \scalebox{0.9}{
  \begin{tikzpicture}[shorten >=1pt,node distance=4cm,on grid,auto,]
    % tenant machine M_1^1
    \node[state,initial] (s_0) {$s_0^1/\mathrm{A_1}$};
    \node[state,right=of s_0] (s_1) {$s_1^1/\mathrm{B_1}$};
    \node[state,right=of s_1] (s_2) {$s_2^1/\mathrm{C_1}$};
  
    \path[->]
      (s_0) edge[bend left=10] node {$\OCC^{(2)}$} (s_1)
      (s_1) edge[loop above] node {$\OCC^{(2)}$} ()
            edge[bend left=10] node {$\overline{\OCC^{(2)}}$} (s_2);
  \end{tikzpicture}}
  \caption{$M_1^1$ (tenant), with\\ $\mathrm{A_1}=\{\PAY^{(1)}\}$, $\mathrm{B_1}=\{\OCC^{(1)},\PAY^{(1)}\}$, $\mathrm{C_1}=\emptyset$.}
  \label{fig:moore-tenant-prod}
  \end{subfigure}
  \vspace{0.5cm}
  \begin{subfigure}[t]{0.70\textwidth}
  \centering
  \scalebox{0.9}{
  \begin{tikzpicture}[shorten >=1pt,node distance=4cm,on grid,auto]
    % landlord machine M_2^1
    \node[state,initial] (s_0) {$s_0^2/\mathrm{A_2}$};
    \node[state,right=of s_0] (s_1) {$s_1^2/\mathrm{A_2}$};
    \node[state,right=of s_1] (s_2) {$s_2^2/\mathrm{B_2}$};
  
    \path[->]
      (s_0) edge[loop above] node {$\PAY^{(1)}$} ()
            edge[bend left=10] node {$\overline{\PAY^{(1)}}$} (s_1)
      (s_1) edge[bend left=10] node {$\PAYF^{(1)}$} (s_0)
            edge[bend left=10] node {$\PAY^{(1)}$} (s_2);
  \end{tikzpicture}}
  \caption{$M_2^1$ (landlord), with : $\mathrm{A_2}=\{\OCC^{(2)},\PAY^{(2)}\}$, $\mathrm{B_2}=\emptyset$}
  \label{fig:moore-landlord-prods}
  \end{subfigure}
  \vspace{0.5cm}
  \begin{subfigure}[t]{0.70\textwidth}
  \centering
  \begin{tikzpicture}[shorten >=1pt,node distance=4cm,on grid,auto,
    every state/.style={inner sep=6pt,font=\scriptsize}]
    % States show pairs of original machine states
    \node[state,initial] (s0) {$(s_0^1,s_0^2)$};
    \node[state, right=of s0] (s1) {$(s_0^1,s_1^2)$};
  
    % Transitions are labeled with the union of outputs
    \path[->]
      (s0) edge node {$A_1 \cup A_2$} (s1)
      (s1) edge[loop right] node {$B_1 \cup A_2$} (s1);
  \end{tikzpicture}
  \caption{Product automaton $M_1^1 \times M_2^1$, with states as pairs $(s_i^1,s_j^2)$ and transitions labeled by the joint outputs.}
  \label{fig:product-sketch}
  \end{subfigure}
  
  \caption{tenant’s machine $M_1^1$, landlord’s machine $M_2^1$, and their product 
  automaton $M_1^1 \times M_2^1$. 
  Each product state is labeled by the joint output $\lambda_1(s_i^1)\cup\lambda_2(s_j^2)$.
  In the transition, the $\overline{\PAY^{1}}$ in the Moore machine $M_j$ is a shorthand for any input action set not containing the action $\PAY^{1}$, similarly $\PAY^{1}$ is a shorthand for any input set containing $\PAY^{1}$.} 
  \label{fig:moore-product-full}
  \end{figure}
  
  \noindent
  Concretely, the run of the product $M_1^1 \times M_2^1$ in  Figure~\ref{fig:product-sketch}, corresponds to the omega-word\\
  $\trace{\{\PAY^{(1)},\OCC^{(2)},\PAY^{(2)}\}~\
   (\{\OCC^{(1)},\PAY^{(1)},\OCC^{(2)},\PAY^{(2)}\})^\omega}.$
  \end{example}
  This section establishes a disciplined abstraction pipeline that bridges concrete executions and normative reasoning. Starting from raw metric-timed observations, we progressively lifted behavior into agent-local periodic traces and then into a collaboration-oriented representation aligned with the contractual calendar.
   The resulting model makes attempts, interference, and potential joint outcomes explicit without introducing interpretative assumptions or discarding observable behavior. Also, the modelization of strategies makes explicit how agents reason prospectively about each other’s behavior, enabling the analysis of compliance not only as an ex post property of traces (after the interaction has occurred), but as an ex ante property of interacting plans (before actions are taken, at the level of intended behavior).
  Crucially, this abstraction separates what agents did from what jointly succeeded, preserving exactly the distinctions required for responsibility and blame attribution. The collaborative periodic trace thus serves as the semantic interface between concrete interaction data and the normative machinery introduced next.
 
  
  \section{The Two-Agents Collaborative Normative Logic \cDL}
  The abstraction developed in the previous section provides the execution model on which normative reasoning will be grounded. 
  Having isolated agent-local attempts, interference, and collaborative outcomes at the level of contractual periods, we are now in a position to define a logic whose semantics are directly tied to this structure. 
  The Two-Agents Collaborative Normative Logic (\cDL) is designed to speak about obligations, permissions, reparations, and powers over collaborative objectives, rather than low-level events.
   Its formulas are interpreted over the collaborative periodic traces constructed earlier, ensuring that normative evaluation is sensitive to attempts and obstruction rather than mere success or failure.
    In this way, \cDL does not abstract away interaction, but instead builds on the interaction model to provide precise, blame-aware contractual semantics.

  \subsection{Syntax of \cDL}
  
  In \ref{fig:cdl-syntax}, the syntax of \cDL\ is organized into three blocks: regular expressions, literals, and contracts.
  \medskip
  \paragraph{Regular expressions (\emph{re}).}
  This block specifies \emph{when} clauses apply by describing patterns over monthly positions.
  An \emph{atom} is a tagged action-set \(A \subseteq \Sigma\) stating what the two parties did in a month.
  Complex expressions are formed with \emph{union} \((re \mid re)\), \emph{concatenation} \((re \cdot re)\) for next-month sequencing,
  \emph{power} \(re^n\) (exactly \(n\) repetitions), and \emph{Kleene plus} \(re^+\) (one or more repetitions).
  The \emph{wildcard} \(\Gamma\) is the union of all $A \subseteq \Sigma$ used to skip a position, and \(\emptyset\) denotes the \emph{empty set of actions}.
  These constructs enable patterns such as “a repair is requested this month” (an atom), “after any number of months if Agent $1$ asks for termination (\(\Gamma \cdot\)), or “three consecutive months” \((re)^3\).
  \begin{figure}
  \centering
  \fbox{%
  \begin{minipage}{0.96\textwidth}
  \captionof{figure}{Syntax of \cDL}
  \label{fig:cdl-syntax}
  \small
  Given a collaboration alphabet $\Sigma_C$ and a party index $p \in \{1,2\}$, we define the tagged action alphabet as
  $
  \Gamma := \Sigma_C^{(1)} \cup \Sigma_C^{(2)}.
  $
 Let $a \in \Sigma_C$ denote a collaborative action, $A \in 2^{\Gamma}$ a party-tagged action set, and $n \in \mathbb{N}^*$ a non-zero natural number.
  The syntax of \cDL\ is defined inductively by the grammar below:
  
  \medskip
  \[
  \begin{alignedat}{3}
  \textbf{Regular expressions}\quad
  \re\ &::=&\ \mathsf{A}                                      && \hfill[\text{tagged action set}] \\
     &\mid&\ \Gamma                             && \hfill[\text{wildcard}] \\
     &\mid&\ \varepsilon                             && \hfill[\text{empty word}] \\
     &\mid&\ \emptyset                              &&  \hfill\quad\qquad [\text{empty set of actions}] \\
     &\mid&\ (\re \mid \re)                           && \hfill[\text{union}] \\
     &\mid&\ \re \cdot \re                           && \hfill[\text{concatenation}] \\
     &\mid&\ \re^{n}                                  && \hfill[\text{n-repetition}] \\
     &\mid&\ \re^{+}                                  && \hfill[\text{Kleene plus}] \\[6pt]
  %
  \textbf{Literals}\quad
  \ell\ &::=&\ \obl[p]{a}                           && \hfill[\text{obligation}] \\
       &\mid&\ \frb[p]{a}                           && \hfill[\text{prohibition}] \\
       &\mid&\ \perm[p]{a}                          && \hfill[\text{permission}] \\
       &\mid&\ \top                                 && \hfill[\text{valid}] \\
       &\mid&\ \bot                                 && \hfill[\text{invalid}] \\[6pt]
  %
  \textbf{Contracts}\quad
  C\ &::=&\ \ell                                    && \hfill[\text{literal}] \\
    &\mid&\ C \wedge C                              && \hfill[\text{conjunction}] \\
    &\mid&\ C ; C                                   && \hfill[\text{sequence}] \\
    &\mid&\ C \repair C                             && \hfill[\text{reparation}] \\
    &\mid&\ \trig[re]{C}                   && \hfill[\text{triggered}] \\
    &\mid&\ \guard[re]{C}                           && \hfill[\text{guarded}] \\
    &\mid&\ C^n                                     && \hfill[\text{n-repetition}]\\
    &\mid&\ \repit{C}                               && \hfill[\text{infinite-repetition}]
  \end{alignedat}
  \]
  \end{minipage}}
  \end{figure}
  
 
  \paragraph{Literals (\emph{\(\ell\)}).}
  This block provides the primitive deontic statements for a single month:
  \emph{obligation} \(\obl[p]{a}\), \emph{prohibition} \(\frb[p]{a}\), and \emph{power} \(\perm[p]{a}\),
  plus the constants \emph{valid} \(\top\) and \emph{invalid} \(\bot\).
  Here \(p \in \{1,2\}\) identifies the party (tenant or landlord) and \(a \in \Sigma_C\) is a collaboration action.
  Intuitively, literals say \emph{what} is required/forbidden/allowed of \emph{whom}, independently of timing. 
  \paragraph{Contracts (\emph{C}).}
  This block composes literals into full specifications using:
  \emph{conjunction} \((C \wedge C)\) to combine requirements in the same time position;
  \emph{sequence} \((C;C)\) for next-time progression;
  \emph{reparation} \((C \repair C')\) for contrary-to-duty fall-backs saying you are requested to perform $C$, if you fail you must conform to $C'$ in the next time position;
  \emph{triggered} clauses \(\trig[re]{C}\) that activate \(C\) when a pattern \(re\) occurs;
  \emph{guarded} clauses \(\guard[re]{C}\) that encapsulate conditions under which conforming to a contract is no longer necessary; 
  \emph{n-repetition} clauses enforces the repetition of the enforcement of a contract $n$ times, with $n \in \mathbb{N^*}$; and finally, \emph{repetition} \(\repit{C}\) for the infinite repetition of the enforcement of a contract.
  Together, these constructs could be used to capture the clauses of a contract, the conditions under which they are activated or terminated, and how the clauses relate to each other regarding reparations or the timing of their application. More specifically, the combination of repetition and a guarded contract can capture the notion of open-ended contracts.
   In the following example, we illustrate how we could capture our use case.
  \subsection{Illustrating the Encoding in \cDL for the Motivating Example}
  \begin{example}[Encoding the rental clauses in \cDL]
  \label{ex:contract-encoding}
  We now illustrate how the rental agreement introduced in Example~\ref{ME} 
  can be systematically encoded in the \cDL\ syntax (see \ref{fig:cdl-syntax}).  
  We define the collaboration alphabet that captures all joint actions relevant to the contract:
  \[
  \Sigma_C = \{\PAY,\ \PAYF,\ \OCC,\ \notifrepair,\ \notifterm,\ \REPAIR\}.
  \]
  Each element corresponds to a collaborative outcome:
  \PAY\ (rent payment), \PAYF\ (late fee payment), \OCC\ (occupancy), 
  \notifrepair\ (tenant’s repair request), \notifterm\ (termination notice), 
  and \REPAIR\ (landlord performing repair).
  
  \medskip
  The encoding proceeds clause by clause, following the contract structure:
  
  \begin{itemize}
    \item \textbf{C1 (tenant pays rent):}  
    The tenant is obliged to pay the rent each month.  
    \[
    C_1 := \obl[1]{\PAY}.
    \]
  
    \item \textbf{C2 (landlord guarantees occupancy):}  
    The tenant gets the power to occupy the flat. 
    Thus, the landlord is required not to interfere with the tenant’s occupancy, 
    encoded as a permission to allow the collaborative outcome \OCC.  
    \[
    C_2 := \perm[1]{\OCC}.
    \]
  
    \item \textbf{C3 (Late-payment reparation):}  
    Clause C3 introduces a contrary-to-duty (CTD) structure: if the tenant fails to fulfill the primary obligation (C1), a compensatory obligation to pay the late fee arises.  
    This relationship is encoded as a reparation construct:
    \[
    C_3 := \obl[1]{\PAY}\ \repair\ \obl[1]{\PAYF}.
    \]
  
    \item \textbf{C4 (Triggered repair request):}  
    The tenant’s request for repairs activates the landlord’s duty to perform them within the following month.  
    This is expressed using a triggered clause:
    \[
    C_4 := 
    \trig[\{\notifrepair^{(1)}\}]{\obl[2]{\REPAIR}}.
    \]
  
    \item \textbf{C5 (Termination and continuation):}  
    The tenant may terminate the contract unilaterally by issuing a termination notice.
    Semantically, this action imposes a temporal limit on the otherwise open-ended obligations defined in the previous clauses.
    Specifically, once the termination notice is issued, the duties to guarantee occupancy ($C_2$), pay rent or reparations ($C_3$), and perform repairs ($C_4$) must persist for exactly three additional months before ceasing.
    To capture this behavior in \cDL, we do not define a single global guard; rather, we apply the guarding condition individually to each relevant sub-contract\footnote{The reason is that these clauses operate on distinct cycles; this concept will be clarified later in this section.}.
    This ensures that each specific duty is correctly terminated after the notice period:
    \begin{align}
      C_{5\to2} &:= \guard[\,\Gamma^+ \cdot \{\notifterm^{(1)}\} \cdot \Gamma^{3}\,]\big( C_2 \big),\\
      C_{5\to3} &:= \guard[\,\Gamma^+ \cdot \{\notifterm^{(1)}\} \cdot \Gamma^{3}\,]\big( C_3 \big),\\
      C_{5\to4} &:= \guard[\,\Gamma^+ \cdot \{\notifterm^{(1)}\} \cdot \Gamma^{3}\,]\big( C_4 \big).
    \end{align}
  \end{itemize}
  
  \medskip
  This step-by-step encoding shows how \cDL\ integrates temporal regular patterns, deontic modalities, 
  and event-triggered obligations in a single formalism.  
  Clauses (C1–C5) together specify a full-cycle contract where collaborative actions such as payment, occupancy, repair, and termination are modeled as 
  conditional and time-bounded obligations between the two agents.
  \end{example}
  
  The syntax above fixes \emph{what} can be expressed in \cDL.
Regular-expression guards determine \emph{when} a clause becomes relevant, while deontic literals determine \emph{which} collaborative objective is required, forbidden, or allowed, and by which party.
The encoding example shows that typical rental clauses can be represented compositionally using sequencing, reparation, triggering, and guarding.

Crucially, the interpretation of these collaborative objectives relies on the interaction model established in \ref{sec:multiagent-sync}. Recall that we explicitly distinguished \emph{attempts} captured in the periodic set traces from \emph{successful collaboration} defined in Definition~\ref{successcomb}. Consequently, although the syntax refers to a collaborative action $a$, the evaluation logic is grounded in the agent-specific attempts $a^{(p)}$ preserved by our abstraction. This ensures that an agent is judged on their active participation rather than the joint outcome, preventing blame assignment when a compliant attempt is blocked by another party.

What remains is to define \emph{how} such contracts are evaluated on traces.
In \cDL, parts of a contract are \emph{relative} to the prior satisfaction or violation of other parts of the same contract.
In particular, reparations, guarded clauses, and termination conditions depend on identifying the exact prefix at which a primary obligation is first fulfilled or first breached.
As a consequence, contract evaluation requires an exact and deterministic decomposition of traces into phases occurring before and after a decisive instant.

The next section introduces a non-classical, prefix-based semantic discipline that enforces such a decomposition.
By isolating unique satisfaction and violation frontiers, this semantics ensures a single, well-defined progression of contractual states, which is essential for the correct interpretation of triggers, reparations, and contractual termination.


\input{tightmotivation.tex}


\input{forwardtight.tex}



